function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

var n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
var D={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D;}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState");};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};
function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D;}var I=H.prototype=new G;I.constructor=H;objectAssign(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h;}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return {$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
function N(a,b){return {$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return "object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return "$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return {result:a,keyPrefix:b,func:c,context:e,count:0}}
function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a);}
function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0;}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e);}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++);}
function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a));}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b);}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}
var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:objectAssign};var Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b);},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};
var Component=F;var Fragment=r;var Profiler=u;var PureComponent=H;var StrictMode=t;var Suspense=y;var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
var cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=objectAssign({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h]);}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f;}return {$$typeof:p,type:a.type,
key:d,ref:g,props:e,_owner:k}};var createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};var createElement=M;var createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};var createRef=function(){return {current:null}};var forwardRef=function(a){return {$$typeof:x,render:a}};var isValidElement=O;
var lazy=function(a){return {$$typeof:A,_ctor:a,_status:-1,_result:null}};var memo=function(a,b){return {$$typeof:z,type:a,compare:void 0===b?null:b}};var useCallback=function(a,b){return Z().useCallback(a,b)};var useContext=function(a,b){return Z().useContext(a,b)};var useDebugValue=function(){};var useEffect=function(a,b){return Z().useEffect(a,b)};var useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
var useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};var useMemo=function(a,b){return Z().useMemo(a,b)};var useReducer=function(a,b,c){return Z().useReducer(a,b,c)};var useRef=function(a){return Z().useRef(a)};var useState=function(a){return Z().useState(a)};var version="16.14.0";

var react_production_min = {
	Children: Children,
	Component: Component,
	Fragment: Fragment,
	Profiler: Profiler,
	PureComponent: PureComponent,
	StrictMode: StrictMode,
	Suspense: Suspense,
	__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
	cloneElement: cloneElement,
	createContext: createContext,
	createElement: createElement,
	createFactory: createFactory,
	createRef: createRef,
	forwardRef: forwardRef,
	isValidElement: isValidElement,
	lazy: lazy,
	memo: memo,
	useCallback: useCallback,
	useContext: useContext,
	useDebugValue: useDebugValue,
	useEffect: useEffect,
	useImperativeHandle: useImperativeHandle,
	useLayoutEffect: useLayoutEffect,
	useMemo: useMemo,
	useReducer: useReducer,
	useRef: useRef,
	useState: useState,
	version: version
};

var react = createCommonjsModule(function (module) {

{
  module.exports = react_production_min;
}
});
var react_1 = react.Component;
var react_2 = react.PureComponent;
var react_3 = react.Fragment;
var react_4 = react.Children;
var react_5 = react.cloneElement;
var react_6 = react.createElement;
var react_7 = react.forwardRef;
var react_8 = react.useState;
var react_9 = react.useCallback;
var react_10 = react.useContext;
var react_11 = react.useDebugValue;
var react_12 = react.useImperativeHandle;
var react_13 = react.useMemo;
var react_14 = react.useEffect;
var react_15 = react.useLayoutEffect;
var react_16 = react.useRef;
var react_17 = react.useReducer;

var scheduler_production_min = createCommonjsModule(function (module, exports) {
var f,g,h,k,l;
if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null;}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0));};g=function(a,b){q=setTimeout(a,b);};h=function(){clearTimeout(q);};k=function(){return !1};l=exports.unstable_forceFrameRate=function(){};}else {var w=window.performance,x=window.Date,
y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");}if("object"===
typeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else {var B=x.now();exports.unstable_now=function(){return x.now()-B};}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5;};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null);}catch(b){throw I.postMessage(null),b;}}else C=!1;};f=function(a){D=a;C||(C=!0,I.postMessage(null));};g=function(a,b){E=y(function(){a(exports.unstable_now());},b);};h=function(){z(E);E=-1;};}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}
function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
function V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O);}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else {var b=L(O);null!==b&&g(W,b.startTime-a);}}
function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b);}else M(N);Q=L(N);}if(null!==Q)var m=!0;else {var n=L(O);null!==n&&g(W,n.startTime-b);m=!1;}return m}finally{Q=null,R=c,S=!1;}}
function Y(a){switch(a){case 1:return -1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null;};exports.unstable_continueExecution=function(){T||S||(T=!0,f(X));};
exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R;}var c=R;R=b;try{return a()}finally{R=c;}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=Z;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=R;R=a;try{return b()}finally{R=c;}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a);}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};
exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c;}}};
});
var scheduler_production_min_1 = scheduler_production_min.unstable_now;
var scheduler_production_min_2 = scheduler_production_min.unstable_forceFrameRate;
var scheduler_production_min_3 = scheduler_production_min.unstable_IdlePriority;
var scheduler_production_min_4 = scheduler_production_min.unstable_ImmediatePriority;
var scheduler_production_min_5 = scheduler_production_min.unstable_LowPriority;
var scheduler_production_min_6 = scheduler_production_min.unstable_NormalPriority;
var scheduler_production_min_7 = scheduler_production_min.unstable_Profiling;
var scheduler_production_min_8 = scheduler_production_min.unstable_UserBlockingPriority;
var scheduler_production_min_9 = scheduler_production_min.unstable_cancelCallback;
var scheduler_production_min_10 = scheduler_production_min.unstable_continueExecution;
var scheduler_production_min_11 = scheduler_production_min.unstable_getCurrentPriorityLevel;
var scheduler_production_min_12 = scheduler_production_min.unstable_getFirstCallbackNode;
var scheduler_production_min_13 = scheduler_production_min.unstable_next;
var scheduler_production_min_14 = scheduler_production_min.unstable_pauseExecution;
var scheduler_production_min_15 = scheduler_production_min.unstable_requestPaint;
var scheduler_production_min_16 = scheduler_production_min.unstable_runWithPriority;
var scheduler_production_min_17 = scheduler_production_min.unstable_scheduleCallback;
var scheduler_production_min_18 = scheduler_production_min.unstable_shouldYield;
var scheduler_production_min_19 = scheduler_production_min.unstable_wrapCallback;

var scheduler = createCommonjsModule(function (module) {

{
  module.exports = scheduler_production_min;
}
});

function u$1(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!react)throw Error(u$1(227));
function ba$1(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l);}catch(m){this.onError(m);}}var da=!1,ea=null,fa=!1,ha=null,ia={onError:function(a){da=!0;ea=a;}};function ja(a,b,c,d,e,f,g,h,k){da=!1;ea=null;ba$1.apply(ia,arguments);}function ka(a,b,c,d,e,f,g,h,k){ja.apply(this,arguments);if(da){if(da){var l=ea;da=!1;ea=null;}else throw Error(u$1(198));fa||(fa=!0,ha=l);}}var la=null,ma=null,na=null;
function oa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=na(c);ka(d,b,void 0,a);a.currentTarget=null;}var pa=null,qa={};
function ra(){if(pa)for(var a in qa){var b=qa[a],c=pa.indexOf(a);if(!(-1<c))throw Error(u$1(96,a));if(!sa[c]){if(!b.extractEvents)throw Error(u$1(97,a));sa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;if(ta.hasOwnProperty(h))throw Error(u$1(99,h));ta[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ua(k[e],g,h);e=!0;}else f.registrationName?(ua(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(u$1(98,d,a));}}}}
function ua(a,b,c){if(va[a])throw Error(u$1(100,a));va[a]=b;wa[a]=b.eventTypes[c].dependencies;}var sa=[],ta={},va={},wa={};function xa(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!qa.hasOwnProperty(c)||qa[c]!==d){if(qa[c])throw Error(u$1(102,c));qa[c]=d;b=!0;}}b&&ra();}var ya=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),za=null,Aa=null,Ba=null;
function Ca(a){if(a=ma(a)){if("function"!==typeof za)throw Error(u$1(280));var b=a.stateNode;b&&(b=la(b),za(a.stateNode,a.type,b));}}function Da(a){Aa?Ba?Ba.push(a):Ba=[a]:Aa=a;}function Ea(){if(Aa){var a=Aa,b=Ba;Ba=Aa=null;Ca(a);if(b)for(a=0;a<b.length;a++)Ca(b[a]);}}function Fa(a,b){return a(b)}function Ga(a,b,c,d,e){return a(b,c,d,e)}function Ha(){}var Ia=Fa,Ja=!1,Ka=!1;function La(){if(null!==Aa||null!==Ba)Ha(),Ea();}
function Ma(a,b,c){if(Ka)return a(b,c);Ka=!0;try{return Ia(a,b,c)}finally{Ka=!1,La();}}var Na=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Oa=Object.prototype.hasOwnProperty,Pa={},Qa={};
function Ra(a){if(Oa.call(Qa,a))return !0;if(Oa.call(Pa,a))return !1;if(Na.test(a))return Qa[a]=!0;Pa[a]=!0;return !1}function Sa(a,b,c,d){if(null!==c&&0===c.type)return !1;switch(typeof b){case "function":case "symbol":return !0;case "boolean":if(d)return !1;if(null!==c)return !c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return !1}}
function Ta(a,b,c,d){if(null===b||"undefined"===typeof b||Sa(a,b,c,d))return !0;if(d)return !1;if(null!==c)switch(c.type){case 3:return !b;case 4:return !1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return !1}function v$1(a,b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;}var C$1={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){C$1[a]=new v$1(a,0,!1,a,null,!1);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];C$1[b]=new v$1(b,1,!1,a[1],null,!1);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){C$1[a]=new v$1(a,2,!1,a.toLowerCase(),null,!1);});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){C$1[a]=new v$1(a,2,!1,a,null,!1);});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){C$1[a]=new v$1(a,3,!1,a.toLowerCase(),null,!1);});
["checked","multiple","muted","selected"].forEach(function(a){C$1[a]=new v$1(a,3,!0,a,null,!1);});["capture","download"].forEach(function(a){C$1[a]=new v$1(a,4,!1,a,null,!1);});["cols","rows","size","span"].forEach(function(a){C$1[a]=new v$1(a,6,!1,a,null,!1);});["rowSpan","start"].forEach(function(a){C$1[a]=new v$1(a,5,!1,a.toLowerCase(),null,!1);});var Ua=/[\-:]([a-z])/g;function Va(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(Ua,
Va);C$1[b]=new v$1(b,1,!1,a,null,!1);});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Ua,Va);C$1[b]=new v$1(b,1,!1,a,"http://www.w3.org/1999/xlink",!1);});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Ua,Va);C$1[b]=new v$1(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1);});["tabIndex","crossOrigin"].forEach(function(a){C$1[a]=new v$1(a,1,!1,a.toLowerCase(),null,!1);});
C$1.xlinkHref=new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){C$1[a]=new v$1(a,1,!1,a.toLowerCase(),null,!0);});var Wa=react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Wa.hasOwnProperty("ReactCurrentDispatcher")||(Wa.ReactCurrentDispatcher={current:null});Wa.hasOwnProperty("ReactCurrentBatchConfig")||(Wa.ReactCurrentBatchConfig={suspense:null});
function Xa(a,b,c,d){var e=C$1.hasOwnProperty(b)?C$1[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Ta(b,c,e,d)&&(c=null),d||null===e?Ra(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))));}
var Ya=/^(.*)[\\\/]/,E$1="function"===typeof Symbol&&Symbol.for,Za=E$1?Symbol.for("react.element"):60103,$a=E$1?Symbol.for("react.portal"):60106,ab=E$1?Symbol.for("react.fragment"):60107,bb=E$1?Symbol.for("react.strict_mode"):60108,cb=E$1?Symbol.for("react.profiler"):60114,db=E$1?Symbol.for("react.provider"):60109,eb=E$1?Symbol.for("react.context"):60110,fb=E$1?Symbol.for("react.concurrent_mode"):60111,gb=E$1?Symbol.for("react.forward_ref"):60112,hb=E$1?Symbol.for("react.suspense"):60113,ib=E$1?Symbol.for("react.suspense_list"):
60120,jb=E$1?Symbol.for("react.memo"):60115,kb=E$1?Symbol.for("react.lazy"):60116,lb=E$1?Symbol.for("react.block"):60121,mb="function"===typeof Symbol&&Symbol.iterator;function nb(a){if(null===a||"object"!==typeof a)return null;a=mb&&a[mb]||a["@@iterator"];return "function"===typeof a?a:null}function ob(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b);},function(b){0===a._status&&(a._status=2,a._result=b);});}}
function pb(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ab:return "Fragment";case $a:return "Portal";case cb:return "Profiler";case bb:return "StrictMode";case hb:return "Suspense";case ib:return "SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case eb:return "Context.Consumer";case db:return "Context.Provider";case gb:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
"ForwardRef");case jb:return pb(a.type);case lb:return pb(a.render);case kb:if(a=1===a._status?a._result:null)return pb(a)}return null}function qb(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=pb(a.type);c=null;d&&(c=pb(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ya,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f;}b+=c;a=a.return;}while(a);return b}
function rb(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return ""}}function sb(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function tb(a){var b=sb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
null;delete a[b];}}}}function xb(a){a._valueTracker||(a._valueTracker=tb(a));}function yb(a){if(!a)return !1;var b=a._valueTracker;if(!b)return !0;var c=b.getValue();var d="";a&&(d=sb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function zb(a,b){var c=b.checked;return objectAssign({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
function Ab(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=rb(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function Bb(a,b){b=b.checked;null!=b&&Xa(a,"checked",b,!1);}
function Cb(a,b){Bb(a,b);var c=rb(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Db(a,b.type,c):b.hasOwnProperty("defaultValue")&&Db(a,b.type,rb(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
function Eb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
function Db(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c);}function Fb(a){var b="";react.Children.forEach(a,function(a){null!=a&&(b+=a);});return b}function Gb(a,b){a=objectAssign({children:void 0},b);if(b=Fb(b.children))a.children=b;return a}
function Hb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0);}else {c=""+rb(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=!0);}}
function Ib(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(u$1(91));return objectAssign({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Jb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(u$1(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(u$1(93));c=c[0];}b=c;}null==b&&(b="");c=b;}a._wrapperState={initialValue:rb(c)};}
function Kb(a,b){var c=rb(b.value),d=rb(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function Lb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b);}var Mb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function Nb(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}function Ob(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var Pb,Qb=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if(a.namespaceURI!==Mb.svg||"innerHTML"in a)a.innerHTML=b;else {Pb=Pb||document.createElement("div");Pb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=Pb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
function Rb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}function Sb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Tb={animationend:Sb("Animation","AnimationEnd"),animationiteration:Sb("Animation","AnimationIteration"),animationstart:Sb("Animation","AnimationStart"),transitionend:Sb("Transition","TransitionEnd")},Ub={},Vb={};
ya&&(Vb=document.createElement("div").style,"AnimationEvent"in window||(delete Tb.animationend.animation,delete Tb.animationiteration.animation,delete Tb.animationstart.animation),"TransitionEvent"in window||delete Tb.transitionend.transition);function Wb(a){if(Ub[a])return Ub[a];if(!Tb[a])return a;var b=Tb[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Vb)return Ub[a]=b[c];return a}
var Xb=Wb("animationend"),Yb=Wb("animationiteration"),Zb=Wb("animationstart"),$b=Wb("transitionend"),ac="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bc=new ("function"===typeof WeakMap?WeakMap:Map);function cc(a){var b=bc.get(a);void 0===b&&(b=new Map,bc.set(a,b));return b}
function dc(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else {a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function ec(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function fc(a){if(dc(a)!==a)throw Error(u$1(188));}
function gc(a){var b=a.alternate;if(!b){b=dc(a);if(null===b)throw Error(u$1(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return fc(e),a;if(f===d)return fc(e),b;f=f.sibling;}throw Error(u$1(188));}if(c.return!==d.return)c=e,d=f;else {for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling;}if(!g)throw Error(u$1(189));}}if(c.alternate!==d)throw Error(u$1(190));}if(3!==c.tag)throw Error(u$1(188));return c.stateNode.current===c?a:b}function hc(a){a=gc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else {if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return null}
function ic(a,b){if(null==b)throw Error(u$1(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function jc(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a);}var kc=null;
function lc(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)oa(a,b[d],c[d]);else b&&oa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a);}}function mc(a){null!==a&&(kc=ic(kc,a));a=kc;kc=null;if(a){jc(a,lc);if(kc)throw Error(u$1(95));if(fa)throw a=ha,fa=!1,ha=null,a;}}
function nc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function oc(a){if(!ya)return !1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}var pc=[];function qc(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>pc.length&&pc.push(a);}
function rc(a,b,c,d){if(pc.length){var e=pc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return {topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}
function sc(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else {for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo;}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=tc(d);}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=nc(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,k=0;k<sa.length;k++){var l=sa[k];l&&(l=l.extractEvents(d,b,f,e,g))&&(h=
ic(h,l));}mc(h);}}function uc(a,b,c){if(!c.has(a)){switch(a){case "scroll":vc(b,"scroll",!0);break;case "focus":case "blur":vc(b,"focus",!0);vc(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":oc(a)&&vc(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===ac.indexOf(a)&&F$1(a,b);}c.set(a,null);}}
var wc,xc,yc,zc=!1,Ac=[],Bc=null,Cc=null,Dc=null,Ec=new Map,Fc=new Map,Gc=[],Hc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),Ic="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");
function Jc(a,b){var c=cc(b);Hc.forEach(function(a){uc(a,b,c);});Ic.forEach(function(a){uc(a,b,c);});}function Kc(a,b,c,d,e){return {blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,container:d}}
function Lc(a,b){switch(a){case "focus":case "blur":Bc=null;break;case "dragenter":case "dragleave":Cc=null;break;case "mouseover":case "mouseout":Dc=null;break;case "pointerover":case "pointerout":Ec.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fc.delete(b.pointerId);}}function Mc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Kc(b,c,d,e,f),null!==b&&(b=Nc(b),null!==b&&xc(b)),a;a.eventSystemFlags|=d;return a}
function Oc(a,b,c,d,e){switch(b){case "focus":return Bc=Mc(Bc,a,b,c,d,e),!0;case "dragenter":return Cc=Mc(Cc,a,b,c,d,e),!0;case "mouseover":return Dc=Mc(Dc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Ec.set(f,Mc(Ec.get(f)||null,a,b,c,d,e));return !0;case "gotpointercapture":return f=e.pointerId,Fc.set(f,Mc(Fc.get(f)||null,a,b,c,d,e)),!0}return !1}
function Pc(a){var b=tc(a.target);if(null!==b){var c=dc(b);if(null!==c)if(b=c.tag,13===b){if(b=ec(c),null!==b){a.blockedOn=b;scheduler.unstable_runWithPriority(a.priority,function(){yc(c);});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null;}function Qc(a){if(null!==a.blockedOn)return !1;var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Nc(b);null!==c&&xc(c);a.blockedOn=b;return !1}return !0}
function Sc(a,b,c){Qc(a)&&c.delete(b);}function Tc(){for(zc=!1;0<Ac.length;){var a=Ac[0];if(null!==a.blockedOn){a=Nc(a.blockedOn);null!==a&&wc(a);break}var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:Ac.shift();}null!==Bc&&Qc(Bc)&&(Bc=null);null!==Cc&&Qc(Cc)&&(Cc=null);null!==Dc&&Qc(Dc)&&(Dc=null);Ec.forEach(Sc);Fc.forEach(Sc);}function Uc(a,b){a.blockedOn===b&&(a.blockedOn=null,zc||(zc=!0,scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority,Tc)));}
function Vc(a){function b(b){return Uc(b,a)}if(0<Ac.length){Uc(Ac[0],a);for(var c=1;c<Ac.length;c++){var d=Ac[c];d.blockedOn===a&&(d.blockedOn=null);}}null!==Bc&&Uc(Bc,a);null!==Cc&&Uc(Cc,a);null!==Dc&&Uc(Dc,a);Ec.forEach(b);Fc.forEach(b);for(c=0;c<Gc.length;c++)d=Gc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Gc.length&&(c=Gc[0],null===c.blockedOn);)Pc(c),null===c.blockedOn&&Gc.shift();}
var Wc={},Yc=new Map,Zc=new Map,$c=["abort","abort",Xb,"animationEnd",Yb,"animationIteration",Zb,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking",
"seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",$b,"transitionEnd","waiting","waiting"];function ad(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Zc.set(d,b);Yc.set(d,f);Wc[e]=f;}}
ad("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0);
ad("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);ad($c,2);for(var bd="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),cd=0;cd<bd.length;cd++)Zc.set(bd[cd],0);
var dd=scheduler.unstable_UserBlockingPriority,ed=scheduler.unstable_runWithPriority,fd=!0;function F$1(a,b){vc(b,a,!1);}function vc(a,b,c){var d=Zc.get(b);switch(void 0===d?2:d){case 0:d=gd.bind(null,b,1,a);break;case 1:d=hd.bind(null,b,1,a);break;default:d=id.bind(null,b,1,a);}c?a.addEventListener(b,d,!0):a.addEventListener(b,d,!1);}function gd(a,b,c,d){Ja||Ha();var e=id,f=Ja;Ja=!0;try{Ga(e,a,b,c,d);}finally{(Ja=f)||La();}}function hd(a,b,c,d){ed(dd,id.bind(null,a,b,c,d));}
function id(a,b,c,d){if(fd)if(0<Ac.length&&-1<Hc.indexOf(a))a=Kc(null,a,b,c,d),Ac.push(a);else {var e=Rc(a,b,c,d);if(null===e)Lc(a,d);else if(-1<Hc.indexOf(a))a=Kc(e,a,b,c,d),Ac.push(a);else if(!Oc(e,a,b,c,d)){Lc(a,d);a=rc(a,d,null,b);try{Ma(sc,a);}finally{qc(a);}}}}
function Rc(a,b,c,d){c=nc(d);c=tc(c);if(null!==c){var e=dc(c);if(null===e)c=null;else {var f=e.tag;if(13===f){c=ec(e);if(null!==c)return c;c=null;}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null;}else e!==c&&(c=null);}}a=rc(a,d,c,b);try{Ma(sc,a);}finally{qc(a);}return null}
var jd={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},kd=["Webkit","ms","Moz","O"];Object.keys(jd).forEach(function(a){kd.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);jd[b]=jd[a];});});function ld(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||jd.hasOwnProperty(a)&&jd[a]?(""+b).trim():b+"px"}
function md(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ld(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var nd=objectAssign({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function od(a,b){if(b){if(nd[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(u$1(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(u$1(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(u$1(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(u$1(62,""));}}
function pd(a,b){if(-1===a.indexOf("-"))return "string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return !1;default:return !0}}var qd=Mb.html;function rd(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=cc(a);b=wa[b];for(var d=0;d<b.length;d++)uc(b[d],a,c);}function sd(){}
function td(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function ud(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function vd(a,b){var c=ud(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return {node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=ud(c);}}
function wd(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?wd(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function xd(){for(var a=window,b=td();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=!1;}if(c)a=b.contentWindow;else break;b=td(a.document);}return b}
function yd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}var zd="$",Ad="/$",Bd="$?",Cd="$!",Dd=null,Ed=null;function Fd(a,b){switch(a){case "button":case "input":case "select":case "textarea":return !!b.autoFocus}return !1}
function Gd(a,b){return "textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var Hd="function"===typeof setTimeout?setTimeout:void 0,Id="function"===typeof clearTimeout?clearTimeout:void 0;function Jd(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}
function Kd(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===zd||c===Cd||c===Bd){if(0===b)return a;b--;}else c===Ad&&b++;}a=a.previousSibling;}return null}var Ld=Math.random().toString(36).slice(2),Md="__reactInternalInstance$"+Ld,Nd="__reactEventHandlers$"+Ld,Od="__reactContainere$"+Ld;
function tc(a){var b=a[Md];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Od]||c[Md]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Kd(a);null!==a;){if(c=a[Md])return c;a=Kd(a);}return b}a=c;c=a.parentNode;}return null}function Nc(a){a=a[Md]||a[Od];return !a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pd(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(u$1(33));}function Qd(a){return a[Nd]||null}
function Rd(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}
function Sd(a,b){var c=a.stateNode;if(!c)return null;var d=la(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1;}if(a)return null;if(c&&"function"!==typeof c)throw Error(u$1(231,
b,typeof c));return c}function Td(a,b,c){if(b=Sd(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a);}function Ud(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=Rd(b);for(b=c.length;0<b--;)Td(c[b],"captured",a);for(b=0;b<c.length;b++)Td(c[b],"bubbled",a);}}
function Vd(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Sd(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a));}function Wd(a){a&&a.dispatchConfig.registrationName&&Vd(a._targetInst,null,a);}function Xd(a){jc(a,Ud);}var Yd=null,Zd=null,$d=null;
function ae(){if($d)return $d;var a,b=Zd,c=b.length,d,e="value"in Yd?Yd.value:Yd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return $d=e.slice(a,1<d?1-d:void 0)}function be(){return !0}function ce(){return !1}
function G$1(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?be:ce;this.isPropagationStopped=ce;return this}
objectAssign(G$1.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=be);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=be);},persist:function(){this.isPersistent=be;},isPersistent:ce,destructor:function(){var a=this.constructor.Interface,
b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=ce;this._dispatchInstances=this._dispatchListeners=null;}});G$1.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
G$1.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;objectAssign(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=objectAssign({},d.Interface,a);c.extend=d.extend;de(c);return c};de(G$1);function ee(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
function fe(a){if(!(a instanceof this))throw Error(u$1(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a);}function de(a){a.eventPool=[];a.getPooled=ee;a.release=fe;}var ge=G$1.extend({data:null}),he=G$1.extend({data:null}),ie=[9,13,27,32],je=ya&&"CompositionEvent"in window,ke=null;ya&&"documentMode"in document&&(ke=document.documentMode);
var le=ya&&"TextEvent"in window&&!ke,me=ya&&(!je||ke&&8<ke&&11>=ke),ne=String.fromCharCode(32),oe={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},pe=!1;
function qe(a,b){switch(a){case "keyup":return -1!==ie.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return !0;default:return !1}}function re(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var se=!1;function te(a,b){switch(a){case "compositionend":return re(b);case "keypress":if(32!==b.which)return null;pe=!0;return ne;case "textInput":return a=b.data,a===ne&&pe?null:a;default:return null}}
function ue(a,b){if(se)return "compositionend"===a||!je&&qe(a,b)?(a=ae(),$d=Zd=Yd=null,se=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return me&&"ko"!==b.locale?null:b.data;default:return null}}
var ve={eventTypes:oe,extractEvents:function(a,b,c,d){var e;if(je)b:{switch(a){case "compositionstart":var f=oe.compositionStart;break b;case "compositionend":f=oe.compositionEnd;break b;case "compositionupdate":f=oe.compositionUpdate;break b}f=void 0;}else se?qe(a,c)&&(f=oe.compositionEnd):"keydown"===a&&229===c.keyCode&&(f=oe.compositionStart);f?(me&&"ko"!==c.locale&&(se||f!==oe.compositionStart?f===oe.compositionEnd&&se&&(e=ae()):(Yd=d,Zd="value"in Yd?Yd.value:Yd.textContent,se=!0)),f=ge.getPooled(f,
b,c,d),e?f.data=e:(e=re(c),null!==e&&(f.data=e)),Xd(f),e=f):e=null;(a=le?te(a,c):ue(a,c))?(b=he.getPooled(oe.beforeInput,b,c,d),b.data=a,Xd(b)):b=null;return null===e?b:null===b?e:[e,b]}},we={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function xe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!we[a.type]:"textarea"===b?!0:!1}
var ye={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function ze(a,b,c){a=G$1.getPooled(ye.change,a,b,c);a.type="change";Da(c);Xd(a);return a}var Ae=null,Be=null;function Ce(a){mc(a);}function De(a){var b=Pd(a);if(yb(b))return a}function Ee(a,b){if("change"===a)return b}var Fe=!1;ya&&(Fe=oc("input")&&(!document.documentMode||9<document.documentMode));
function Ge(){Ae&&(Ae.detachEvent("onpropertychange",He),Be=Ae=null);}function He(a){if("value"===a.propertyName&&De(Be))if(a=ze(Be,a,nc(a)),Ja)mc(a);else {Ja=!0;try{Fa(Ce,a);}finally{Ja=!1,La();}}}function Ie(a,b,c){"focus"===a?(Ge(),Ae=b,Be=c,Ae.attachEvent("onpropertychange",He)):"blur"===a&&Ge();}function Je(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return De(Be)}function Ke(a,b){if("click"===a)return De(b)}function Le(a,b){if("input"===a||"change"===a)return De(b)}
var Me={eventTypes:ye,_isInputEventSupported:Fe,extractEvents:function(a,b,c,d){var e=b?Pd(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Ee;else if(xe(e))if(Fe)g=Le;else {g=Je;var h=Ie;}else (f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Ke);if(g&&(g=g(a,b)))return ze(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Db(e,"number",e.value);}},Ne=G$1.extend({view:null,detail:null}),
Oe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pe(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Oe[a])?!!b[a]:!1}function Qe(){return Pe}
var Re=0,Se=0,Te=!1,Ue=!1,Ve=Ne.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Qe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=Re;Re=a.screenX;return Te?"mousemove"===a.type?a.screenX-b:0:(Te=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
var b=Se;Se=a.screenY;return Ue?"mousemove"===a.type?a.screenY-b:0:(Ue=!0,0)}}),We=Ve.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Xe={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
dependencies:["pointerout","pointerover"]}},Ye={eventTypes:Xe,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?tc(b):null,null!==b){var h=dc(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null;}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===
a){var k=Ve;var l=Xe.mouseLeave;var m=Xe.mouseEnter;var p="mouse";}else if("pointerout"===a||"pointerover"===a)k=We,l=Xe.pointerLeave,m=Xe.pointerEnter,p="pointer";a=null==g?f:Pd(g);f=null==b?f:Pd(b);l=k.getPooled(l,g,c,d);l.type=p+"leave";l.target=a;l.relatedTarget=f;c=k.getPooled(m,b,c,d);c.type=p+"enter";c.target=f;c.relatedTarget=a;d=g;p=b;if(d&&p)a:{k=d;m=p;g=0;for(a=k;a;a=Rd(a))g++;a=0;for(b=m;b;b=Rd(b))a++;for(;0<g-a;)k=Rd(k),g--;for(;0<a-g;)m=Rd(m),a--;for(;g--;){if(k===m||k===m.alternate)break a;
k=Rd(k);m=Rd(m);}k=null;}else k=null;m=k;for(k=[];d&&d!==m;){g=d.alternate;if(null!==g&&g===m)break;k.push(d);d=Rd(d);}for(d=[];p&&p!==m;){g=p.alternate;if(null!==g&&g===m)break;d.push(p);p=Rd(p);}for(p=0;p<k.length;p++)Vd(k[p],"bubbled",l);for(p=d.length;0<p--;)Vd(d[p],"captured",c);return 0===(e&64)?[l]:[l,c]}};function Ze(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var $e="function"===typeof Object.is?Object.is:Ze,af=Object.prototype.hasOwnProperty;
function bf(a,b){if($e(a,b))return !0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return !1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return !1;for(d=0;d<c.length;d++)if(!af.call(b,c[d])||!$e(a[c[d]],b[c[d]]))return !1;return !0}
var cf=ya&&"documentMode"in document&&11>=document.documentMode,df={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},ef=null,ff=null,gf=null,hf=!1;
function jf(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(hf||null==ef||ef!==td(c))return null;c=ef;"selectionStart"in c&&yd(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return gf&&bf(gf,c)?null:(gf=c,a=G$1.getPooled(df.select,ff,a,b),a.type="select",a.target=ef,Xd(a),a)}
var kf={eventTypes:df,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=cc(e);f=wa.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0;}f=!e;}if(f)return null;e=b?Pd(b):window;switch(a){case "focus":if(xe(e)||"true"===e.contentEditable)ef=e,ff=b,gf=null;break;case "blur":gf=ff=ef=null;break;case "mousedown":hf=!0;break;case "contextmenu":case "mouseup":case "dragend":return hf=!1,jf(c,d);case "selectionchange":if(cf)break;
case "keydown":case "keyup":return jf(c,d)}return null}},lf=G$1.extend({animationName:null,elapsedTime:null,pseudoElement:null}),mf=G$1.extend({clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),nf=Ne.extend({relatedTarget:null});function of(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
var pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},qf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},rf=Ne.extend({key:function(a){if(a.key){var b=pf[a.key]||a.key;if("Unidentified"!==b)return b}return "keypress"===a.type?(a=of(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?qf[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Qe,charCode:function(a){return "keypress"===
a.type?of(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===a.type?of(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),sf=Ve.extend({dataTransfer:null}),tf=Ne.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Qe}),uf=G$1.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),vf=Ve.extend({deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in
a?-a.wheelDeltaX:0},deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),wf={eventTypes:Wc,extractEvents:function(a,b,c,d){var e=Yc.get(a);if(!e)return null;switch(a){case "keypress":if(0===of(c))return null;case "keydown":case "keyup":a=rf;break;case "blur":case "focus":a=nf;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=
Ve;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=sf;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=tf;break;case Xb:case Yb:case Zb:a=lf;break;case $b:a=uf;break;case "scroll":a=Ne;break;case "wheel":a=vf;break;case "copy":case "cut":case "paste":a=mf;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=
We;break;default:a=G$1;}b=a.getPooled(e,b,c,d);Xd(b);return b}};if(pa)throw Error(u$1(101));pa=Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ra();var xf=Nc;la=Qd;ma=xf;na=Pd;xa({SimpleEventPlugin:wf,EnterLeaveEventPlugin:Ye,ChangeEventPlugin:Me,SelectEventPlugin:kf,BeforeInputEventPlugin:ve});var yf=[],zf=-1;function H$1(a){0>zf||(a.current=yf[zf],yf[zf]=null,zf--);}
function I$1(a,b){zf++;yf[zf]=a.current;a.current=b;}var Af={},J$1={current:Af},K$1={current:!1},Bf=Af;function Cf(a,b){var c=a.type.contextTypes;if(!c)return Af;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function L$1(a){a=a.childContextTypes;return null!==a&&void 0!==a}
function Df(){H$1(K$1);H$1(J$1);}function Ef(a,b,c){if(J$1.current!==Af)throw Error(u$1(168));I$1(J$1,b);I$1(K$1,c);}function Ff(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(u$1(108,pb(b)||"Unknown",e));return objectAssign({},c,{},d)}function Gf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Af;Bf=J$1.current;I$1(J$1,a);I$1(K$1,K$1.current);return !0}
function Hf(a,b,c){var d=a.stateNode;if(!d)throw Error(u$1(169));c?(a=Ff(a,b,Bf),d.__reactInternalMemoizedMergedChildContext=a,H$1(K$1),H$1(J$1),I$1(J$1,a)):H$1(K$1);I$1(K$1,c);}
var If=scheduler.unstable_runWithPriority,Jf=scheduler.unstable_scheduleCallback,Kf=scheduler.unstable_cancelCallback,Lf=scheduler.unstable_requestPaint,Mf=scheduler.unstable_now,Nf=scheduler.unstable_getCurrentPriorityLevel,Of=scheduler.unstable_ImmediatePriority,Pf=scheduler.unstable_UserBlockingPriority,Qf=scheduler.unstable_NormalPriority,Rf=scheduler.unstable_LowPriority,Sf=scheduler.unstable_IdlePriority,Tf={},Uf=scheduler.unstable_shouldYield,Vf=void 0!==Lf?Lf:function(){},Wf=null,Xf=null,Yf=!1,Zf=Mf(),$f=1E4>Zf?Mf:function(){return Mf()-Zf};
function ag(){switch(Nf()){case Of:return 99;case Pf:return 98;case Qf:return 97;case Rf:return 96;case Sf:return 95;default:throw Error(u$1(332));}}function bg(a){switch(a){case 99:return Of;case 98:return Pf;case 97:return Qf;case 96:return Rf;case 95:return Sf;default:throw Error(u$1(332));}}function cg(a,b){a=bg(a);return If(a,b)}function dg(a,b,c){a=bg(a);return Jf(a,b,c)}function eg(a){null===Wf?(Wf=[a],Xf=Jf(Of,fg)):Wf.push(a);return Tf}function gg(){if(null!==Xf){var a=Xf;Xf=null;Kf(a);}fg();}
function fg(){if(!Yf&&null!==Wf){Yf=!0;var a=0;try{var b=Wf;cg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});Wf=null;}catch(c){throw null!==Wf&&(Wf=Wf.slice(a+1)),Jf(Of,gg),c;}finally{Yf=!1;}}}function hg(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function ig(a,b){if(a&&a.defaultProps){b=objectAssign({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);}return b}var jg={current:null},kg=null,lg=null,mg=null;function ng(){mg=lg=kg=null;}
function og(a){var b=jg.current;H$1(jg);a.type._context._currentValue=b;}function pg(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return;}}function qg(a,b){kg=a;mg=lg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(rg=!0),a.firstContext=null);}
function sg(a,b){if(mg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)mg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===lg){if(null===kg)throw Error(u$1(308));lg=b;kg.dependencies={expirationTime:0,firstContext:b,responders:null};}else lg=lg.next=b;}return a._currentValue}var tg=!1;function ug(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null};}
function vg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects});}function wg(a,b){a={expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null};return a.next=a}function xg(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b;}}
function yg(a,b){var c=a.alternate;null!==c&&vg(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b);}
function zg(a,b,c,d){var e=a.updateQueue;tg=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h;}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&(h.baseQueue=g));}if(null!==f){h=f.next;var k=e.baseState,l=0,m=null,p=null,x=null;if(null!==h){var z=h;do{g=z.expirationTime;if(g<d){var ca={expirationTime:z.expirationTime,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null};null===x?(p=x=
ca,m=k):x=x.next=ca;g>l&&(l=g);}else {null!==x&&(x=x.next={expirationTime:1073741823,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null});Ag(g,z.suspenseConfig);a:{var D=a,t=z;g=b;ca=c;switch(t.tag){case 1:D=t.payload;if("function"===typeof D){k=D.call(ca,k,g);break a}k=D;break a;case 3:D.effectTag=D.effectTag&-4097|64;case 0:D=t.payload;g="function"===typeof D?D.call(ca,k,g):D;if(null===g||void 0===g)break a;k=objectAssign({},k,g);break a;case 2:tg=!0;}}null!==z.callback&&
(a.effectTag|=32,g=e.effects,null===g?e.effects=[z]:g.push(z));}z=z.next;if(null===z||z===h)if(g=e.shared.pending,null===g)break;else z=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null;}while(1)}null===x?m=k:x.next=p;e.baseState=m;e.baseQueue=x;Bg(l);a.expirationTime=l;a.memoizedState=k;}}
function Cg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(u$1(191,d));d.call(e);}}}var Dg=Wa.ReactCurrentBatchConfig,Eg=(new react.Component).refs;function Fg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:objectAssign({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c);}
var Jg={isMounted:function(a){return (a=a._reactInternalFiber)?dc(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d);},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d);},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=Gg(),d=Dg.suspense;
c=Hg(c,a,d);d=wg(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);xg(a,d);Ig(a,c);}};function Kg(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!bf(c,d)||!bf(e,f):!0}
function Lg(a,b,c){var d=!1,e=Af;var f=b.contextType;"object"===typeof f&&null!==f?f=sg(f):(e=L$1(b)?Bf:J$1.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Cf(a,e):Af);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Jg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function Mg(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Jg.enqueueReplaceState(b,b.state,null);}
function Ng(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Eg;ug(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=sg(f):(f=L$1(b)?Bf:J$1.current,e.context=Cf(a,f));zg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Fg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||
(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Jg.enqueueReplaceState(e,e.state,null),zg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.effectTag|=4);}var Og=Array.isArray;
function Pg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(u$1(309));var d=c.stateNode;}if(!d)throw Error(u$1(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Eg&&(b=d.refs={});null===a?delete b[e]:b[e]=a;};b._stringRef=e;return b}if("string"!==typeof a)throw Error(u$1(284));if(!c._owner)throw Error(u$1(290,a));}return a}
function Qg(a,b){if("textarea"!==a.type)throw Error(u$1(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}
function Rg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8;}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Sg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Tg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Pg(a,b,c),d.return=a,d;d=Ug(c.type,c.key,c.props,null,a.mode,d);d.ref=Pg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
c.implementation)return b=Vg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Wg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Tg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Za:return c=Ug(b.type,b.key,b.props,null,a.mode,c),c.ref=Pg(a,null,b),c.return=a,c;case $a:return b=Vg(b,a.mode,c),b.return=a,b}if(Og(b)||
nb(b))return b=Wg(b,a.mode,c,null),b.return=a,b;Qg(a,b);}return null}function x(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Za:return c.key===e?c.type===ab?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case $a:return c.key===e?l(a,b,c,d):null}if(Og(c)||nb(c))return null!==e?null:m(a,b,c,d,null);Qg(a,c);}return null}function z(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Za:return a=a.get(null===d.key?c:d.key)||null,d.type===ab?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case $a:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Og(d)||nb(d))return a=a.get(c)||null,m(b,a,d,e,null);Qg(b,d);}return null}function ca(e,g,h,k){for(var l=null,t=null,m=g,y=g=0,A=null;null!==m&&y<h.length;y++){m.index>y?(A=m,m=null):A=m.sibling;var q=x(e,m,h[y],k);if(null===q){null===m&&(m=A);break}a&&
m&&null===q.alternate&&b(e,m);g=f(q,g,y);null===t?l=q:t.sibling=q;t=q;m=A;}if(y===h.length)return c(e,m),l;if(null===m){for(;y<h.length;y++)m=p(e,h[y],k),null!==m&&(g=f(m,g,y),null===t?l=m:t.sibling=m,t=m);return l}for(m=d(e,m);y<h.length;y++)A=z(m,e,y,h[y],k),null!==A&&(a&&null!==A.alternate&&m.delete(null===A.key?y:A.key),g=f(A,g,y),null===t?l=A:t.sibling=A,t=A);a&&m.forEach(function(a){return b(e,a)});return l}function D(e,g,h,l){var k=nb(h);if("function"!==typeof k)throw Error(u$1(150));h=k.call(h);
if(null==h)throw Error(u$1(151));for(var m=k=null,t=g,y=g=0,A=null,q=h.next();null!==t&&!q.done;y++,q=h.next()){t.index>y?(A=t,t=null):A=t.sibling;var D=x(e,t,q.value,l);if(null===D){null===t&&(t=A);break}a&&t&&null===D.alternate&&b(e,t);g=f(D,g,y);null===m?k=D:m.sibling=D;m=D;t=A;}if(q.done)return c(e,t),k;if(null===t){for(;!q.done;y++,q=h.next())q=p(e,q.value,l),null!==q&&(g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);return k}for(t=d(e,t);!q.done;y++,q=h.next())q=z(t,e,y,q.value,l),null!==q&&(a&&null!==
q.alternate&&t.delete(null===q.key?y:q.key),g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);a&&t.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ab&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Za:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ab){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,
k.sibling);d=e(k,f.props);d.ref=Pg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling;}f.type===ab?(d=Wg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ug(f.type,f.key,f.props,null,a.mode,h),h.ref=Pg(a,d,f),h.return=a,a=h);}return g(a);case $a:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else {c(a,d);break}else b(a,d);d=
d.sibling;}d=Vg(f,a.mode,h);d.return=a;a=d;}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Tg(f,a.mode,h),d.return=a,a=d),g(a);if(Og(f))return ca(a,d,f,h);if(nb(f))return D(a,d,f,h);l&&Qg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,Error(u$1(152,a.displayName||a.name||"Component"));}return c(a,d)}}var Xg=Rg(!0),Yg=Rg(!1),Zg={},$g={current:Zg},ah={current:Zg},bh={current:Zg};
function ch(a){if(a===Zg)throw Error(u$1(174));return a}function dh(a,b){I$1(bh,b);I$1(ah,a);I$1($g,Zg);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Ob(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Ob(b,a);}H$1($g);I$1($g,b);}function eh(){H$1($g);H$1(ah);H$1(bh);}function fh(a){ch(bh.current);var b=ch($g.current);var c=Ob(b,a.type);b!==c&&(I$1(ah,a),I$1($g,c));}function gh(a){ah.current===a&&(H$1($g),H$1(ah));}var M$1={current:0};
function hh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===Bd||c.data===Cd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}return null}function ih(a,b){return {responder:a,props:b}}
var jh=Wa.ReactCurrentDispatcher,kh=Wa.ReactCurrentBatchConfig,lh=0,N$1=null,O$1=null,P$1=null,mh=!1;function Q$1(){throw Error(u$1(321));}function nh(a,b){if(null===b)return !1;for(var c=0;c<b.length&&c<a.length;c++)if(!$e(a[c],b[c]))return !1;return !0}
function oh(a,b,c,d,e,f){lh=f;N$1=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;jh.current=null===a||null===a.memoizedState?ph:qh;a=c(d,e);if(b.expirationTime===lh){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(u$1(301));f+=1;P$1=O$1=null;b.updateQueue=null;jh.current=rh;a=c(d,e);}while(b.expirationTime===lh)}jh.current=sh;b=null!==O$1&&null!==O$1.next;lh=0;P$1=O$1=N$1=null;mh=!1;if(b)throw Error(u$1(300));return a}
function th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P$1?N$1.memoizedState=P$1=a:P$1=P$1.next=a;return P$1}function uh(){if(null===O$1){var a=N$1.alternate;a=null!==a?a.memoizedState:null;}else a=O$1.next;var b=null===P$1?N$1.memoizedState:P$1.next;if(null!==b)P$1=b,O$1=a;else {if(null===a)throw Error(u$1(310));O$1=a;a={memoizedState:O$1.memoizedState,baseState:O$1.baseState,baseQueue:O$1.baseQueue,queue:O$1.queue,next:null};null===P$1?N$1.memoizedState=P$1=a:P$1=P$1.next=a;}return P$1}
function vh(a,b){return "function"===typeof b?b(a):b}
function wh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u$1(311));c.lastRenderedReducer=a;var d=O$1,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g;}d.baseQueue=e=f;c.pending=null;}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.expirationTime;if(l<lh){var m={expirationTime:k.expirationTime,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null};null===h?(g=h=m,f=d):h=h.next=m;l>N$1.expirationTime&&
(N$1.expirationTime=l,Bg(l));}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),Ag(l,k.suspenseConfig),d=k.eagerReducer===a?k.eagerState:a(d,k.action);k=k.next;}while(null!==k&&k!==e);null===h?f=d:h.next=g;$e(d,b.memoizedState)||(rg=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d;}return [b.memoizedState,c.dispatch]}
function xh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u$1(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);$e(f,b.memoizedState)||(rg=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f;}return [f,d]}
function yh(a){var b=th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:vh,lastRenderedState:a};a=a.dispatch=zh.bind(null,N$1,a);return [b.memoizedState,a]}function Ah(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N$1.updateQueue;null===b?(b={lastEffect:null},N$1.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}
function Bh(){return uh().memoizedState}function Ch(a,b,c,d){var e=th();N$1.effectTag|=a;e.memoizedState=Ah(1|b,c,void 0,void 0===d?null:d);}function Dh(a,b,c,d){var e=uh();d=void 0===d?null:d;var f=void 0;if(null!==O$1){var g=O$1.memoizedState;f=g.destroy;if(null!==d&&nh(d,g.deps)){Ah(b,c,f,d);return}}N$1.effectTag|=a;e.memoizedState=Ah(1|b,c,f,d);}function Eh(a,b){return Ch(516,4,a,b)}function Fh(a,b){return Dh(516,4,a,b)}function Gh(a,b){return Dh(4,2,a,b)}
function Hh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null);};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null;}}function Ih(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Dh(4,2,Hh.bind(null,b,a),c)}function Jh(){}function Kh(a,b){th().memoizedState=[a,void 0===b?null:b];return a}function Lh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function Mh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Nh(a,b,c){var d=ag();cg(98>d?98:d,function(){a(!0);});cg(97<d?97:d,function(){var d=kh.suspense;kh.suspense=void 0===b?null:b;try{a(!1),c();}finally{kh.suspense=d;}});}
function zh(a,b,c){var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===N$1||null!==f&&f===N$1)mh=!0,e.expirationTime=lh,N$1.expirationTime=lh;else {if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.eagerReducer=f;e.eagerState=h;if($e(h,g))return}catch(k){}finally{}Ig(a,
d);}}
var sh={readContext:sg,useCallback:Q$1,useContext:Q$1,useEffect:Q$1,useImperativeHandle:Q$1,useLayoutEffect:Q$1,useMemo:Q$1,useReducer:Q$1,useRef:Q$1,useState:Q$1,useDebugValue:Q$1,useResponder:Q$1,useDeferredValue:Q$1,useTransition:Q$1},ph={readContext:sg,useCallback:Kh,useContext:sg,useEffect:Eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Ch(4,2,Hh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Ch(4,2,a,b)},useMemo:function(a,b){var c=th();b=void 0===b?null:b;a=a();c.memoizedState=[a,
b];return a},useReducer:function(a,b,c){var d=th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=zh.bind(null,N$1,a);return [d.memoizedState,a]},useRef:function(a){var b=th();a={current:a};return b.memoizedState=a},useState:yh,useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=yh(a),d=c[0],e=c[1];Eh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=
c;}},[a,b]);return d},useTransition:function(a){var b=yh(!1),c=b[0];b=b[1];return [Kh(Nh.bind(null,b,a),[b,a]),c]}},qh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:wh,useRef:Bh,useState:function(){return wh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=wh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=c;}},[a,b]);return d},useTransition:function(a){var b=
wh(vh),c=b[0];b=b[1];return [Lh(Nh.bind(null,b,a),[b,a]),c]}},rh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:xh,useRef:Bh,useState:function(){return xh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=xh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a);}finally{kh.suspense=c;}},[a,b]);return d},useTransition:function(a){var b=xh(vh),c=b[0];b=b[1];return [Lh(Nh.bind(null,
b,a),[b,a]),c]}},Oh=null,Ph=null,Qh=!1;function Rh(a,b){var c=Sh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c;}
function Th(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return !1;default:return !1}}
function Uh(a){if(Qh){var b=Ph;if(b){var c=b;if(!Th(a,b)){b=Jd(c.nextSibling);if(!b||!Th(a,b)){a.effectTag=a.effectTag&-1025|2;Qh=!1;Oh=a;return}Rh(Oh,c);}Oh=a;Ph=Jd(b.firstChild);}else a.effectTag=a.effectTag&-1025|2,Qh=!1,Oh=a;}}function Vh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;Oh=a;}
function Wh(a){if(a!==Oh)return !1;if(!Qh)return Vh(a),Qh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Gd(b,a.memoizedProps))for(b=Ph;b;)Rh(a,b),b=Jd(b.nextSibling);Vh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(u$1(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===Ad){if(0===b){Ph=Jd(a.nextSibling);break a}b--;}else c!==zd&&c!==Cd&&c!==Bd||b++;}a=a.nextSibling;}Ph=null;}}else Ph=Oh?Jd(a.stateNode.nextSibling):null;return !0}
function Xh(){Ph=Oh=null;Qh=!1;}var Yh=Wa.ReactCurrentOwner,rg=!1;function R$1(a,b,c,d){b.child=null===a?Yg(b,null,c,d):Xg(b,a.child,c,d);}function Zh(a,b,c,d,e){c=c.render;var f=b.ref;qg(b,e);d=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R$1(a,b,d,e);return b.child}
function ai(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!bi(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ci(a,b,g,d,e,f);a=Ug(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:bf,c(e,d)&&a.ref===b.ref))return $h(a,b,f);b.effectTag|=1;a=Sg(g,d);a.ref=b.ref;a.return=b;return b.child=a}
function ci(a,b,c,d,e,f){return null!==a&&bf(a.memoizedProps,d)&&a.ref===b.ref&&(rg=!1,e<f)?(b.expirationTime=a.expirationTime,$h(a,b,f)):di(a,b,c,d,f)}function ei(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128;}function di(a,b,c,d,e){var f=L$1(c)?Bf:J$1.current;f=Cf(b,f);qg(b,e);c=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R$1(a,b,c,e);return b.child}
function fi(a,b,c,d,e){if(L$1(c)){var f=!0;Gf(b);}else f=!1;qg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Lg(b,c,d),Ng(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=sg(l):(l=L$1(c)?Bf:J$1.current,l=Cf(b,l));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l);tg=!1;var x=b.memoizedState;g.state=x;zg(b,d,g,e);k=b.memoizedState;h!==d||x!==k||K$1.current||tg?("function"===typeof m&&(Fg(b,c,m,d),k=b.memoizedState),(h=tg||Kg(b,c,h,d,x,k,l))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===
typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1);}else g=b.stateNode,vg(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:ig(b.type,h),k=g.context,l=c.contextType,"object"===typeof l&&null!==l?l=sg(l):(l=L$1(c)?Bf:J$1.current,l=Cf(b,l)),m=c.getDerivedStateFromProps,(p="function"===typeof m||"function"===
typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l),tg=!1,k=b.memoizedState,g.state=k,zg(b,d,g,e),x=b.memoizedState,h!==d||k!==x||K$1.current||tg?("function"===typeof m&&(Fg(b,c,m,d),x=b.memoizedState),(m=tg||Kg(b,c,h,d,k,x,l))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,
x,l),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,l)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=l,d=m):
("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1);return gi(a,b,c,d,f,e)}
function gi(a,b,c,d,e,f){ei(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hf(b,c,!1),$h(a,b,f);d=b.stateNode;Yh.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Xg(b,a.child,null,f),b.child=Xg(b,null,h,f)):R$1(a,b,h,f);b.memoizedState=d.state;e&&Hf(b,c,!0);return b.child}function hi(a){var b=a.stateNode;b.pendingContext?Ef(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ef(a,b.context,!1);dh(a,b.containerInfo);}
var ii={dehydrated:null,retryTime:0};
function ji(a,b,c){var d=b.mode,e=b.pendingProps,f=M$1.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);I$1(M$1,f&1);if(null===a){void 0!==e.fallback&&Uh(b);if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=
b;e.sibling=c;b.memoizedState=ii;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Yg(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=Sg(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sg(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=ii;b.child=c;return d}c=Xg(b,a.child,e.children,c);b.memoizedState=null;return b.child=
c}a=a.child;if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=ii;b.child=e;return c}b.memoizedState=null;return b.child=Xg(b,a,e.children,c)}
function ki(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);pg(a.return,b);}function li(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f);}
function mi(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;R$1(a,b,d.children,c);d=M$1.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else {if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&ki(a,c);else if(19===a.tag)ki(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}d&=1;}I$1(M$1,d);if(0===(b.mode&2))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===hh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);li(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===hh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a;}li(b,!0,c,null,f,b.lastEffect);break;case "together":li(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null;}return b.child}
function $h(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Bg(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(u$1(153));if(null!==b.child){a=b.child;c=Sg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sg(a,a.pendingProps),c.return=b;c.sibling=null;}return b.child}var ni,oi,pi,qi;
ni=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}};oi=function(){};
pi=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;ch($g.current);a=null;switch(c){case "input":f=zb(g,f);d=zb(g,d);a=[];break;case "option":f=Gb(g,f);d=Gb(g,d);a=[];break;case "select":f=objectAssign({},f,{value:void 0});d=objectAssign({},d,{value:void 0});a=[];break;case "textarea":f=Ib(g,f);d=Ib(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=sd);}od(c,d);var h,k;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===
h)for(k in g=f[h],g)g.hasOwnProperty(k)&&(c||(c={}),c[k]="");else "dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(va.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var l=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&l!==g&&(null!=l||null!=g))if("style"===h)if(g){for(k in g)!g.hasOwnProperty(k)||l&&l.hasOwnProperty(k)||(c||(c={}),c[k]="");for(k in l)l.hasOwnProperty(k)&&g[k]!==l[k]&&(c||(c={}),
c[k]=l[k]);}else c||(a||(a=[]),a.push(h,c)),c=l;else "dangerouslySetInnerHTML"===h?(l=l?l.__html:void 0,g=g?g.__html:void 0,null!=l&&g!==l&&(a=a||[]).push(h,l)):"children"===h?g===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(h,""+l):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(va.hasOwnProperty(h)?(null!=l&&rd(e,h),a||g===l||(a=[])):(a=a||[]).push(h,l));}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4;}};
qi=function(a,b,c,d){c!==d&&(b.effectTag|=4);};function ri(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null;}}
function si(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return L$1(b.type)&&Df(),null;case 3:return eh(),H$1(K$1),H$1(J$1),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Wh(b)||(b.effectTag|=4),oi(b),null;case 5:gh(b);c=ch(bh.current);var e=b.type;if(null!==a&&null!=b.stateNode)pi(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else {if(!d){if(null===b.stateNode)throw Error(u$1(166));
return null}a=ch($g.current);if(Wh(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Md]=b;d[Nd]=f;switch(e){case "iframe":case "object":case "embed":F$1("load",d);break;case "video":case "audio":for(a=0;a<ac.length;a++)F$1(ac[a],d);break;case "source":F$1("error",d);break;case "img":case "image":case "link":F$1("error",d);F$1("load",d);break;case "form":F$1("reset",d);F$1("submit",d);break;case "details":F$1("toggle",d);break;case "input":Ab(d,f);F$1("invalid",d);rd(c,"onChange");break;case "select":d._wrapperState=
{wasMultiple:!!f.multiple};F$1("invalid",d);rd(c,"onChange");break;case "textarea":Jb(d,f),F$1("invalid",d),rd(c,"onChange");}od(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):va.hasOwnProperty(g)&&null!=h&&rd(c,g);}switch(e){case "input":xb(d);Eb(d,f,!0);break;case "textarea":xb(d);Lb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&
(d.onclick=sd);}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4);}else {g=9===c.nodeType?c:c.ownerDocument;a===qd&&(a=Nb(e));a===qd?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Md]=b;a[Nd]=d;ni(a,b,!1,!1);b.stateNode=a;g=pd(e,d);switch(e){case "iframe":case "object":case "embed":F$1("load",
a);h=d;break;case "video":case "audio":for(h=0;h<ac.length;h++)F$1(ac[h],a);h=d;break;case "source":F$1("error",a);h=d;break;case "img":case "image":case "link":F$1("error",a);F$1("load",a);h=d;break;case "form":F$1("reset",a);F$1("submit",a);h=d;break;case "details":F$1("toggle",a);h=d;break;case "input":Ab(a,d);h=zb(a,d);F$1("invalid",a);rd(c,"onChange");break;case "option":h=Gb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=objectAssign({},d,{value:void 0});F$1("invalid",a);rd(c,"onChange");break;case "textarea":Jb(a,
d);h=Ib(a,d);F$1("invalid",a);rd(c,"onChange");break;default:h=d;}od(e,h);var k=h;for(f in k)if(k.hasOwnProperty(f)){var l=k[f];"style"===f?md(a,l):"dangerouslySetInnerHTML"===f?(l=l?l.__html:void 0,null!=l&&Qb(a,l)):"children"===f?"string"===typeof l?("textarea"!==e||""!==l)&&Rb(a,l):"number"===typeof l&&Rb(a,""+l):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(va.hasOwnProperty(f)?null!=l&&rd(c,f):null!=l&&Xa(a,f,l,g));}switch(e){case "input":xb(a);Eb(a,d,!1);
break;case "textarea":xb(a);Lb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+rb(d.value));break;case "select":a.multiple=!!d.multiple;c=d.value;null!=c?Hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&Hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=sd);}Fd(e,d)&&(b.effectTag|=4);}null!==b.ref&&(b.effectTag|=128);}return null;case 6:if(a&&null!=b.stateNode)qi(a,b,a.memoizedProps,d);else {if("string"!==typeof d&&null===b.stateNode)throw Error(u$1(166));
c=ch(bh.current);ch($g.current);Wh(b)?(c=b.stateNode,d=b.memoizedProps,c[Md]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),c[Md]=b,b.stateNode=c);}return null;case 13:H$1(M$1);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Wh(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=
e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(M$1.current&1))S$1===ti&&(S$1=ui);else {if(S$1===ti||S$1===ui)S$1=vi;0!==wi&&null!==T$1&&(xi(T$1,U$1),yi(T$1,wi));}if(c||d)b.effectTag|=4;return null;case 4:return eh(),oi(b),null;case 10:return og(b),null;case 17:return L$1(b.type)&&Df(),null;case 19:H$1(M$1);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)ri(d,!1);else {if(S$1!==ti||null!==a&&0!==(a.effectTag&
64))for(f=b.child;null!==f;){a=hh(f);if(null!==a){b.effectTag|=64;ri(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,
e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;I$1(M$1,M$1.current&1|2);return b.child}f=f.sibling;}}else {if(!e)if(a=hh(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),ri(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=
b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*$f()-d.renderingStartTime>d.tailExpiration&&1<c&&(b.effectTag|=64,e=!0,ri(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f);}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=$f()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=$f(),c.sibling=null,b=M$1.current,I$1(M$1,e?b&1|2:b&1),c):null}throw Error(u$1(156,
b.tag));}function zi(a){switch(a.tag){case 1:L$1(a.type)&&Df();var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:eh();H$1(K$1);H$1(J$1);b=a.effectTag;if(0!==(b&64))throw Error(u$1(285));a.effectTag=b&-4097|64;return a;case 5:return gh(a),null;case 13:return H$1(M$1),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return H$1(M$1),null;case 4:return eh(),null;case 10:return og(a),null;default:return null}}function Ai(a,b){return {value:a,source:b,stack:qb(b)}}
var Bi="function"===typeof WeakSet?WeakSet:Set;function Ci(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=qb(c));null!==c&&pb(c.type);b=b.value;null!==a&&1===a.tag&&pb(a.type);try{console.error(b);}catch(e){setTimeout(function(){throw e;});}}function Di(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount();}catch(c){Ei(a,c);}}function Fi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null);}catch(c){Ei(a,c);}else b.current=null;}
function Gi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:ig(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b;}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(u$1(163));}
function Hi(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d();}c=c.next;}while(c!==b)}}function Ii(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d();}c=c.next;}while(c!==b)}}
function Ji(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:Ii(3,c);return;case 1:a=c.stateNode;if(c.effectTag&4)if(null===b)a.componentDidMount();else {var d=c.elementType===c.type?b.memoizedProps:ig(c.type,b.memoizedProps);a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate);}b=c.updateQueue;null!==b&&Cg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode;}Cg(c,b,a);}return;
case 5:a=c.stateNode;null===b&&c.effectTag&4&&Fd(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Vc(c))));return;case 19:case 17:case 20:case 21:return}throw Error(u$1(163));}
function Ki(a,b,c){"function"===typeof Li&&Li(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;cg(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c();}catch(h){Ei(g,h);}}a=a.next;}while(a!==d)});}break;case 1:Fi(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Di(b,c);break;case 5:Fi(b);break;case 4:Mi(a,b,c);}}
function Ni(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Ni(b);}function Oi(a){return 5===a.tag||3===a.tag||4===a.tag}
function Pi(a){a:{for(var b=a.return;null!==b;){if(Oi(b)){var c=b;break a}b=b.return;}throw Error(u$1(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(u$1(161));}c.effectTag&16&&(Rb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Oi(c.return)){c=null;break a}c=c.return;}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;
if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child;}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Qi(a,c,b):Ri(a,c,b);}
function Qi(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=sd));else if(4!==d&&(a=a.child,null!==a))for(Qi(a,b,c),a=a.sibling;null!==a;)Qi(a,b,c),a=a.sibling;}
function Ri(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Ri(a,b,c),a=a.sibling;null!==a;)Ri(a,b,c),a=a.sibling;}
function Mi(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(u$1(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return;}e=!0;}if(5===d.tag||6===d.tag){a:for(var h=a,k=d,l=c,m=k;;)if(Ki(h,m,l),null!==m.child&&4!==m.tag)m.child.return=m,m=m.child;else {if(m===k)break a;for(;null===m.sibling;){if(null===m.return||m.return===k)break a;m=m.return;}m.sibling.return=m.return;m=m.sibling;}g?(h=
f,k=d.stateNode,8===h.nodeType?h.parentNode.removeChild(k):h.removeChild(k)):f.removeChild(d.stateNode);}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ki(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1);}d.sibling.return=d.return;d=d.sibling;}}
function Si(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Hi(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[Nd]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Bb(c,d);pd(a,e);b=pd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?md(c,h):"dangerouslySetInnerHTML"===g?Qb(c,h):"children"===g?Rb(c,h):Xa(c,g,h,b);}switch(a){case "input":Cb(c,d);break;
case "textarea":Kb(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?Hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?Hb(c,!!d.multiple,d.defaultValue,!0):Hb(c,!!d.multiple,d.multiple?[]:"",!1));}}}return;case 6:if(null===b.stateNode)throw Error(u$1(162));b.stateNode.nodeValue=b.memoizedProps;return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,Vc(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?
d=!1:(d=!0,c=b.child,Ti=$f());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=ld("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=
f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}Ui(b);return;case 19:Ui(b);return;case 17:return}throw Error(u$1(163));}function Ui(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Bi);b.forEach(function(b){var d=Vi.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d));});}}
var Wi="function"===typeof WeakMap?WeakMap:Map;function Xi(a,b,c){c=wg(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Yi||(Yi=!0,Zi=d);Ci(a,b);};return c}
function $i(a,b,c){c=wg(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ci(a,b);return d(e)};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===aj?aj=new Set([this]):aj.add(this),Ci(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""});});return c}
var bj=Math.ceil,cj=Wa.ReactCurrentDispatcher,dj=Wa.ReactCurrentOwner,V$1=0,ej=8,fj=16,gj=32,ti=0,hj=1,ij=2,ui=3,vi=4,jj=5,W$1=V$1,T$1=null,X$1=null,U$1=0,S$1=ti,kj=null,lj=1073741823,mj=1073741823,nj=null,wi=0,oj=!1,Ti=0,pj=500,Y$1=null,Yi=!1,Zi=null,aj=null,qj=!1,rj=null,sj=90,tj=null,uj=0,vj=null,wj=0;function Gg(){return (W$1&(fj|gj))!==V$1?1073741821-($f()/10|0):0!==wj?wj:wj=1073741821-($f()/10|0)}
function Hg(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=ag();if(0===(b&4))return 99===d?1073741823:1073741822;if((W$1&fj)!==V$1)return U$1;if(null!==c)a=hg(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=hg(a,150,100);break;case 97:case 96:a=hg(a,5E3,250);break;case 95:a=2;break;default:throw Error(u$1(326));}null!==T$1&&a===U$1&&--a;return a}
function Ig(a,b){if(50<uj)throw uj=0,vj=null,Error(u$1(185));a=xj(a,b);if(null!==a){var c=ag();1073741823===b?(W$1&ej)!==V$1&&(W$1&(fj|gj))===V$1?yj(a):(Z$1(a),W$1===V$1&&gg()):Z$1(a);(W$1&4)===V$1||98!==c&&99!==c||(null===tj?tj=new Map([[a,b]]):(c=tj.get(a),(void 0===c||c>b)&&tj.set(a,b)));}}
function xj(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return;}null!==e&&(T$1===e&&(Bg(b),S$1===vi&&xi(e,U$1)),yi(e,b));return e}
function zj(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Aj(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}
function Z$1(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=eg(yj.bind(null,a));else {var b=zj(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else {var d=Gg();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Tf&&Kf(c);}a.callbackExpirationTime=
b;a.callbackPriority=d;b=1073741823===b?eg(yj.bind(null,a)):dg(d,Bj.bind(null,a),{timeout:10*(1073741821-b)-$f()});a.callbackNode=b;}}}
function Bj(a,b){wj=0;if(b)return b=Gg(),Cj(a,b),Z$1(a),null;var c=zj(a);if(0!==c){b=a.callbackNode;if((W$1&(fj|gj))!==V$1)throw Error(u$1(327));Dj();a===T$1&&c===U$1||Ej(a,c);if(null!==X$1){var d=W$1;W$1|=fj;var e=Fj();do try{Gj();break}catch(h){Hj(a,h);}while(1);ng();W$1=d;cj.current=e;if(S$1===hj)throw b=kj,Ej(a,c),xi(a,c),Z$1(a),b;if(null===X$1)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=S$1,T$1=null,d){case ti:case hj:throw Error(u$1(345));case ij:Cj(a,2<c?2:c);break;case ui:xi(a,c);d=a.lastSuspendedTime;
c===d&&(a.nextKnownPendingLevel=Ij(e));if(1073741823===lj&&(e=Ti+pj-$f(),10<e)){if(oj){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Ej(a,c);break}}f=zj(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Hd(Jj.bind(null,a),e);break}Jj(a);break;case vi:xi(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ij(e));if(oj&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Ej(a,c);break}e=zj(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=
d;break}1073741823!==mj?d=10*(1073741821-mj)-$f():1073741823===lj?d=0:(d=10*(1073741821-lj)-5E3,e=$f(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*bj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Hd(Jj.bind(null,a),d);break}Jj(a);break;case jj:if(1073741823!==lj&&null!==nj){f=lj;var g=nj;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=$f()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){xi(a,c);a.timeoutHandle=
Hd(Jj.bind(null,a),d);break}}Jj(a);break;default:throw Error(u$1(329));}Z$1(a);if(a.callbackNode===b)return Bj.bind(null,a)}}return null}
function yj(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if((W$1&(fj|gj))!==V$1)throw Error(u$1(327));Dj();a===T$1&&b===U$1||Ej(a,b);if(null!==X$1){var c=W$1;W$1|=fj;var d=Fj();do try{Kj();break}catch(e){Hj(a,e);}while(1);ng();W$1=c;cj.current=d;if(S$1===hj)throw c=kj,Ej(a,b),xi(a,b),Z$1(a),c;if(null!==X$1)throw Error(u$1(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;T$1=null;Jj(a);Z$1(a);}return null}function Lj(){if(null!==tj){var a=tj;tj=null;a.forEach(function(a,c){Cj(c,a);Z$1(c);});gg();}}
function Mj(a,b){var c=W$1;W$1|=1;try{return a(b)}finally{W$1=c,W$1===V$1&&gg();}}function Nj(a,b){var c=W$1;W$1&=-2;W$1|=ej;try{return a(b)}finally{W$1=c,W$1===V$1&&gg();}}
function Ej(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Id(c));if(null!==X$1)for(c=X$1.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Df();break;case 3:eh();H$1(K$1);H$1(J$1);break;case 5:gh(d);break;case 4:eh();break;case 13:H$1(M$1);break;case 19:H$1(M$1);break;case 10:og(d);}c=c.return;}T$1=a;X$1=Sg(a.current,null);U$1=b;S$1=ti;kj=null;mj=lj=1073741823;nj=null;wi=0;oj=!1;}
function Hj(a,b){do{try{ng();jh.current=sh;if(mh)for(var c=N$1.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next;}lh=0;P$1=O$1=N$1=null;mh=!1;if(null===X$1||null===X$1.return)return S$1=hj,kj=b,X$1=null;a:{var e=a,f=X$1.return,g=X$1,h=b;b=U$1;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var k=h;if(0===(g.mode&2)){var l=g.alternate;l?(g.updateQueue=l.updateQueue,g.memoizedState=l.memoizedState,g.expirationTime=l.expirationTime):(g.updateQueue=
null,g.memoizedState=null);}var m=0!==(M$1.current&1),p=f;do{var x;if(x=13===p.tag){var z=p.memoizedState;if(null!==z)x=null!==z.dehydrated?!0:!1;else {var ca=p.memoizedProps;x=void 0===ca.fallback?!1:!0!==ca.unstable_avoidThisFallback?!0:m?!1:!0;}}if(x){var D=p.updateQueue;if(null===D){var t=new Set;t.add(k);p.updateQueue=t;}else D.add(k);if(0===(p.mode&2)){p.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else {var y=wg(1073741823,null);y.tag=2;xg(g,y);}g.expirationTime=1073741823;
break a}h=void 0;g=b;var A=e.pingCache;null===A?(A=e.pingCache=new Wi,h=new Set,A.set(k,h)):(h=A.get(k),void 0===h&&(h=new Set,A.set(k,h)));if(!h.has(g)){h.add(g);var q=Oj.bind(null,e,k,g);k.then(q,q);}p.effectTag|=4096;p.expirationTime=b;break a}p=p.return;}while(null!==p);h=Error((pb(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+qb(g));}S$1!==
jj&&(S$1=ij);h=Ai(h,g);p=f;do{switch(p.tag){case 3:k=h;p.effectTag|=4096;p.expirationTime=b;var B=Xi(p,k,b);yg(p,B);break a;case 1:k=h;var w=p.type,ub=p.stateNode;if(0===(p.effectTag&64)&&("function"===typeof w.getDerivedStateFromError||null!==ub&&"function"===typeof ub.componentDidCatch&&(null===aj||!aj.has(ub)))){p.effectTag|=4096;p.expirationTime=b;var vb=$i(p,k,b);yg(p,vb);break a}}p=p.return;}while(null!==p)}X$1=Pj(X$1);}catch(Xc){b=Xc;continue}break}while(1)}
function Fj(){var a=cj.current;cj.current=sh;return null===a?sh:a}function Ag(a,b){a<lj&&2<a&&(lj=a);null!==b&&a<mj&&2<a&&(mj=a,nj=b);}function Bg(a){a>wi&&(wi=a);}function Kj(){for(;null!==X$1;)X$1=Qj(X$1);}function Gj(){for(;null!==X$1&&!Uf();)X$1=Qj(X$1);}function Qj(a){var b=Rj(a.alternate,a,U$1);a.memoizedProps=a.pendingProps;null===b&&(b=Pj(a));dj.current=null;return b}
function Pj(a){X$1=a;do{var b=X$1.alternate;a=X$1.return;if(0===(X$1.effectTag&2048)){b=si(b,X$1,U$1);if(1===U$1||1!==X$1.childExpirationTime){for(var c=0,d=X$1.child;null!==d;){var e=d.expirationTime,f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling;}X$1.childExpirationTime=c;}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=X$1.firstEffect),null!==X$1.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=X$1.firstEffect),a.lastEffect=X$1.lastEffect),1<X$1.effectTag&&(null!==
a.lastEffect?a.lastEffect.nextEffect=X$1:a.firstEffect=X$1,a.lastEffect=X$1));}else {b=zi(X$1);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048);}b=X$1.sibling;if(null!==b)return b;X$1=a;}while(null!==X$1);S$1===ti&&(S$1=jj);return null}function Ij(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function Jj(a){var b=ag();cg(99,Sj.bind(null,a,b));return null}
function Sj(a,b){do Dj();while(null!==rj);if((W$1&(fj|gj))!==V$1)throw Error(u$1(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(u$1(177));a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ij(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=
d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===T$1&&(X$1=T$1=null,U$1=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=W$1;W$1|=gj;dj.current=null;Dd=fd;var g=xd();if(yd(g)){if("selectionStart"in g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var k=h.getSelection&&h.getSelection();if(k&&0!==k.rangeCount){h=k.anchorNode;var l=k.anchorOffset,
m=k.focusNode;k=k.focusOffset;try{h.nodeType,m.nodeType;}catch(wb){h=null;break a}var p=0,x=-1,z=-1,ca=0,D=0,t=g,y=null;b:for(;;){for(var A;;){t!==h||0!==l&&3!==t.nodeType||(x=p+l);t!==m||0!==k&&3!==t.nodeType||(z=p+k);3===t.nodeType&&(p+=t.nodeValue.length);if(null===(A=t.firstChild))break;y=t;t=A;}for(;;){if(t===g)break b;y===h&&++ca===l&&(x=p);y===m&&++D===k&&(z=p);if(null!==(A=t.nextSibling))break;t=y;y=t.parentNode;}t=A;}h=-1===x||-1===z?null:{start:x,end:z};}else h=null;}h=h||{start:0,end:0};}else h=
null;Ed={activeElementDetached:null,focusedElem:g,selectionRange:h};fd=!1;Y$1=e;do try{Tj();}catch(wb){if(null===Y$1)throw Error(u$1(330));Ei(Y$1,wb);Y$1=Y$1.nextEffect;}while(null!==Y$1);Y$1=e;do try{for(g=a,h=b;null!==Y$1;){var q=Y$1.effectTag;q&16&&Rb(Y$1.stateNode,"");if(q&128){var B=Y$1.alternate;if(null!==B){var w=B.ref;null!==w&&("function"===typeof w?w(null):w.current=null);}}switch(q&1038){case 2:Pi(Y$1);Y$1.effectTag&=-3;break;case 6:Pi(Y$1);Y$1.effectTag&=-3;Si(Y$1.alternate,Y$1);break;case 1024:Y$1.effectTag&=-1025;break;case 1028:Y$1.effectTag&=
-1025;Si(Y$1.alternate,Y$1);break;case 4:Si(Y$1.alternate,Y$1);break;case 8:l=Y$1,Mi(g,l,h),Ni(l);}Y$1=Y$1.nextEffect;}}catch(wb){if(null===Y$1)throw Error(u$1(330));Ei(Y$1,wb);Y$1=Y$1.nextEffect;}while(null!==Y$1);w=Ed;B=xd();q=w.focusedElem;h=w.selectionRange;if(B!==q&&q&&q.ownerDocument&&wd(q.ownerDocument.documentElement,q)){null!==h&&yd(q)&&(B=h.start,w=h.end,void 0===w&&(w=B),"selectionStart"in q?(q.selectionStart=B,q.selectionEnd=Math.min(w,q.value.length)):(w=(B=q.ownerDocument||document)&&B.defaultView||window,w.getSelection&&
(w=w.getSelection(),l=q.textContent.length,g=Math.min(h.start,l),h=void 0===h.end?g:Math.min(h.end,l),!w.extend&&g>h&&(l=h,h=g,g=l),l=vd(q,g),m=vd(q,h),l&&m&&(1!==w.rangeCount||w.anchorNode!==l.node||w.anchorOffset!==l.offset||w.focusNode!==m.node||w.focusOffset!==m.offset)&&(B=B.createRange(),B.setStart(l.node,l.offset),w.removeAllRanges(),g>h?(w.addRange(B),w.extend(m.node,m.offset)):(B.setEnd(m.node,m.offset),w.addRange(B))))));B=[];for(w=q;w=w.parentNode;)1===w.nodeType&&B.push({element:w,left:w.scrollLeft,
top:w.scrollTop});"function"===typeof q.focus&&q.focus();for(q=0;q<B.length;q++)w=B[q],w.element.scrollLeft=w.left,w.element.scrollTop=w.top;}fd=!!Dd;Ed=Dd=null;a.current=c;Y$1=e;do try{for(q=a;null!==Y$1;){var ub=Y$1.effectTag;ub&36&&Ji(q,Y$1.alternate,Y$1);if(ub&128){B=void 0;var vb=Y$1.ref;if(null!==vb){var Xc=Y$1.stateNode;switch(Y$1.tag){case 5:B=Xc;break;default:B=Xc;}"function"===typeof vb?vb(B):vb.current=B;}}Y$1=Y$1.nextEffect;}}catch(wb){if(null===Y$1)throw Error(u$1(330));Ei(Y$1,wb);Y$1=Y$1.nextEffect;}while(null!==Y$1);Y$1=
null;Vf();W$1=f;}else a.current=c;if(qj)qj=!1,rj=a,sj=b;else for(Y$1=e;null!==Y$1;)b=Y$1.nextEffect,Y$1.nextEffect=null,Y$1=b;b=a.firstPendingTime;0===b&&(aj=null);1073741823===b?a===vj?uj++:(uj=0,vj=a):uj=0;"function"===typeof Uj&&Uj(c.stateNode,d);Z$1(a);if(Yi)throw Yi=!1,a=Zi,Zi=null,a;if((W$1&ej)!==V$1)return null;gg();return null}function Tj(){for(;null!==Y$1;){var a=Y$1.effectTag;0!==(a&256)&&Gi(Y$1.alternate,Y$1);0===(a&512)||qj||(qj=!0,dg(97,function(){Dj();return null}));Y$1=Y$1.nextEffect;}}
function Dj(){if(90!==sj){var a=97<sj?97:sj;sj=90;return cg(a,Vj)}}function Vj(){if(null===rj)return !1;var a=rj;rj=null;if((W$1&(fj|gj))!==V$1)throw Error(u$1(331));var b=W$1;W$1|=gj;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Hi(5,c),Ii(5,c);}}catch(d){if(null===a)throw Error(u$1(330));Ei(a,d);}c=a.nextEffect;a.nextEffect=null;a=c;}W$1=b;gg();return !0}
function Wj(a,b,c){b=Ai(c,b);b=Xi(a,b,1073741823);xg(a,b);a=xj(a,1073741823);null!==a&&Z$1(a);}function Ei(a,b){if(3===a.tag)Wj(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Wj(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===aj||!aj.has(d))){a=Ai(b,a);a=$i(c,a,1073741823);xg(c,a);c=xj(c,1073741823);null!==c&&Z$1(c);break}}c=c.return;}}
function Oj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);T$1===a&&U$1===c?S$1===vi||S$1===ui&&1073741823===lj&&$f()-Ti<pj?Ej(a,U$1):oj=!0:Aj(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,Z$1(a)));}function Vi(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=Gg(),b=Hg(b,a,null));a=xj(a,b);null!==a&&Z$1(a);}var Rj;
Rj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||K$1.current)rg=!0;else {if(d<c){rg=!1;switch(b.tag){case 3:hi(b);Xh();break;case 5:fh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:L$1(b.type)&&Gf(b);break;case 4:dh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;I$1(jg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return ji(a,b,c);I$1(M$1,M$1.current&1);b=$h(a,b,c);return null!==b?b.sibling:null}I$1(M$1,M$1.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return mi(a,b,c);b.effectTag|=64;}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);I$1(M$1,M$1.current);if(!d)return null}return $h(a,b,c)}rg=!1;}}else rg=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Cf(b,J$1.current);qg(b,c);e=oh(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(L$1(d)){var f=!0;Gf(b);}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ug(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Fg(b,d,g,a);e.updater=Jg;b.stateNode=e;e._reactInternalFiber=b;Ng(b,d,a,c);b=gi(null,b,d,!0,f,c);}else b.tag=0,R$1(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ob(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Xj(e);a=ig(e,a);switch(f){case 0:b=di(null,b,e,a,c);break a;case 1:b=fi(null,b,e,a,c);break a;case 11:b=Zh(null,b,e,a,c);break a;case 14:b=ai(null,b,e,ig(e.type,a),d,c);break a}throw Error(u$1(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),di(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),fi(a,b,d,e,c);
case 3:hi(b);d=b.updateQueue;if(null===a||null===d)throw Error(u$1(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;vg(a,b);zg(b,d,null,c);d=b.memoizedState.element;if(d===e)Xh(),b=$h(a,b,c);else {if(e=b.stateNode.hydrate)Ph=Jd(b.stateNode.containerInfo.firstChild),Oh=b,e=Qh=!0;if(e)for(c=Yg(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else R$1(a,b,d,c),Xh();b=b.child;}return b;case 5:return fh(b),null===a&&Uh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Gd(d,e)?g=null:null!==f&&Gd(d,f)&&(b.effectTag|=16),ei(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(R$1(a,b,g,c),b=b.child),b;case 6:return null===a&&Uh(b),null;case 13:return ji(a,b,c);case 4:return dh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Xg(b,null,d,c):R$1(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),Zh(a,b,d,e,c);case 7:return R$1(a,b,b.pendingProps,c),b.child;case 8:return R$1(a,
b,b.pendingProps.children,c),b.child;case 12:return R$1(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I$1(jg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=$e(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!K$1.current){b=$h(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==
k){g=h.child;for(var l=k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=wg(c,null),l.tag=2,xg(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);pg(h.return,c);k.expirationTime<c&&(k.expirationTime=c);break}l=l.next;}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return;}h=
g;}R$1(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,qg(b,c),e=sg(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,R$1(a,b,d,c),b.child;case 14:return e=b.type,f=ig(e,b.pendingProps),f=ig(e.type,f),ai(a,b,e,f,d,c);case 15:return ci(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,L$1(d)?(a=!0,Gf(b)):a=!1,qg(b,c),Lg(b,d,e),Ng(b,d,e,c),gi(null,
b,d,!0,a,c);case 19:return mi(a,b,c)}throw Error(u$1(156,b.tag));};var Uj=null,Li=null;function Yj(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return !1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return !0;try{var c=b.inject(a);Uj=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64));}catch(e){}};Li=function(a){try{b.onCommitFiberUnmount(c,a);}catch(e){}};}catch(d){}return !0}
function Zj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null;}function Sh(a,b,c,d){return new Zj(a,b,c,d)}
function bi(a){a=a.prototype;return !(!a||!a.isReactComponent)}function Xj(a){if("function"===typeof a)return bi(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===gb)return 11;if(a===jb)return 14}return 2}
function Sg(a,b){var c=a.alternate;null===c?(c=Sh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function Ug(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)bi(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ab:return Wg(c.children,e,f,b);case fb:g=8;e|=7;break;case bb:g=8;e|=1;break;case cb:return a=Sh(12,c,b,e|8),a.elementType=cb,a.type=cb,a.expirationTime=f,a;case hb:return a=Sh(13,c,b,e),a.type=hb,a.elementType=hb,a.expirationTime=f,a;case ib:return a=Sh(19,c,b,e),a.elementType=ib,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case db:g=
10;break a;case eb:g=9;break a;case gb:g=11;break a;case jb:g=14;break a;case kb:g=16;d=null;break a;case lb:g=22;break a}throw Error(u$1(130,null==a?a:typeof a,""));}b=Sh(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Wg(a,b,c,d){a=Sh(7,a,d,b);a.expirationTime=c;return a}function Tg(a,b,c){a=Sh(6,a,null,b);a.expirationTime=c;return a}
function Vg(a,b,c){b=Sh(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function ak(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0;}
function Aj(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function xi(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0);}
function yi(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b));}function Cj(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b;}
function bk(a,b,c,d){var e=b.current,f=Gg(),g=Dg.suspense;f=Hg(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(dc(c)!==c||1!==c.tag)throw Error(u$1(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(L$1(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return;}while(null!==h);throw Error(u$1(171));}if(1===c.tag){var k=c.type;if(L$1(k)){c=Ff(c,k,h);break a}}c=h;}else c=Af;null===b.context?b.context=c:b.pendingContext=c;b=wg(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);xg(e,b);Ig(e,f);return f}function ck(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function dk(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b);}function ek(a,b){dk(a,b);(a=a.alternate)&&dk(a,b);}
function fk(a,b,c){c=null!=c&&!0===c.hydrate;var d=new ak(a,b,c),e=Sh(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ug(e);a[Od]=d.current;c&&0!==b&&Jc(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d;}fk.prototype.render=function(a){bk(a,this._internalRoot,null,null);};fk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;bk(null,a,null,function(){b[Od]=null;});};
function gk(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function hk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new fk(a,0,b?{hydrate:!0}:void 0)}
function ik(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=ck(g);h.call(a);};}bk(b,g,a,e);}else {f=c._reactRootContainer=hk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=ck(g);k.call(a);};}Nj(function(){bk(b,g,a,e);});}return ck(g)}function jk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:$a,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
wc=function(a){if(13===a.tag){var b=hg(Gg(),150,100);Ig(a,b);ek(a,b);}};xc=function(a){13===a.tag&&(Ig(a,3),ek(a,3));};yc=function(a){if(13===a.tag){var b=Gg();b=Hg(b,a,null);Ig(a,b);ek(a,b);}};
za=function(a,b,c){switch(b){case "input":Cb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Qd(d);if(!e)throw Error(u$1(90));yb(d);Cb(d,e);}}}break;case "textarea":Kb(a,c);break;case "select":b=c.value,null!=b&&Hb(a,!!c.multiple,b,!1);}};Fa=Mj;
Ga=function(a,b,c,d,e){var f=W$1;W$1|=4;try{return cg(98,a.bind(null,b,c,d,e))}finally{W$1=f,W$1===V$1&&gg();}};Ha=function(){(W$1&(1|fj|gj))===V$1&&(Lj(),Dj());};Ia=function(a,b){var c=W$1;W$1|=2;try{return a(b)}finally{W$1=c,W$1===V$1&&gg();}};function kk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!gk(b))throw Error(u$1(200));return jk(a,b,null,c)}var lk={Events:[Nc,Pd,Qd,xa,ta,Xd,function(a){jc(a,Wd);},Da,Ea,id,mc,Dj,{current:!1}]};
(function(a){var b=a.findFiberByHostInstance;return Yj(objectAssign({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Wa.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hc(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:tc,bundleType:0,version:"16.14.0",
rendererPackageName:"react-dom"});var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1=lk;var createPortal=kk;var findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw Error(u$1(188));throw Error(u$1(268,Object.keys(a)));}a=hc(b);a=null===a?null:a.stateNode;return a};
var flushSync=function(a,b){if((W$1&(fj|gj))!==V$1)throw Error(u$1(187));var c=W$1;W$1|=1;try{return cg(99,a.bind(null,b))}finally{W$1=c,gg();}};var hydrate=function(a,b,c){if(!gk(b))throw Error(u$1(200));return ik(null,a,b,!0,c)};var render=function(a,b,c){if(!gk(b))throw Error(u$1(200));return ik(null,a,b,!1,c)};
var unmountComponentAtNode=function(a){if(!gk(a))throw Error(u$1(40));return a._reactRootContainer?(Nj(function(){ik(null,null,a,!1,function(){a._reactRootContainer=null;a[Od]=null;});}),!0):!1};var unstable_batchedUpdates=Mj;var unstable_createPortal=function(a,b){return kk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};
var unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!gk(c))throw Error(u$1(200));if(null==a||void 0===a._reactInternalFiber)throw Error(u$1(38));return ik(a,b,c,!1,d)};var version$1="16.14.0";

var reactDom_production_min = {
	__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED$1,
	createPortal: createPortal,
	findDOMNode: findDOMNode,
	flushSync: flushSync,
	hydrate: hydrate,
	render: render,
	unmountComponentAtNode: unmountComponentAtNode,
	unstable_batchedUpdates: unstable_batchedUpdates,
	unstable_createPortal: unstable_createPortal,
	unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainer,
	version: version$1
};

var reactDom = createCommonjsModule(function (module) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

{
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = reactDom_production_min;
}
});
var reactDom_1 = reactDom.unstable_batchedUpdates;

/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error( formatProdErrorMessage(0) );
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error( formatProdErrorMessage(1) );
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error( formatProdErrorMessage(2) );
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error( formatProdErrorMessage(3) );
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error( formatProdErrorMessage(4) );
    }

    if (isDispatching) {
      throw new Error( formatProdErrorMessage(5) );
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error( formatProdErrorMessage(6) );
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error( formatProdErrorMessage(7) );
    }

    if (typeof action.type === 'undefined') {
      throw new Error( formatProdErrorMessage(8) );
    }

    if (isDispatching) {
      throw new Error( formatProdErrorMessage(9) );
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error( formatProdErrorMessage(10) );
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error( formatProdErrorMessage(11) );
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

var ReactReduxContext = /*#__PURE__*/react.createContext(null);

// Default to a dummy "batch" implementation that just runs the callback
function defaultNoopBatch(callback) {
  callback();
}

var batch = defaultNoopBatch; // Allow injecting another batching function later

var setBatch = function setBatch(newBatch) {
  return batch = newBatch;
}; // Supply a getter just to skip dealing with ESM bindings

var getBatch = function getBatch() {
  return batch;
};

// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

function createListenerCollection() {
  var batch = getBatch();
  var first = null;
  var last = null;
  return {
    clear: function clear() {
      first = null;
      last = null;
    },
    notify: function notify() {
      batch(function () {
        var listener = first;

        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get() {
      var listeners = [];
      var listener = first;

      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }

      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last = {
        callback: callback,
        next: null,
        prev: last
      };

      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }

      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;

        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }

        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}

var nullListeners = {
  notify: function notify() {},
  get: function get() {
    return [];
  }
};
function createSubscription(store, parentSub) {
  var unsubscribe;
  var listeners = nullListeners;

  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }

  function notifyNestedSubs() {
    listeners.notify();
  }

  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }

  function isSubscribed() {
    return Boolean(unsubscribe);
  }

  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }

  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = undefined;
      listeners.clear();
      listeners = nullListeners;
    }
  }

  var subscription = {
    addNestedSub: addNestedSub,
    notifyNestedSubs: notifyNestedSubs,
    handleChangeWrapper: handleChangeWrapper,
    isSubscribed: isSubscribed,
    trySubscribe: trySubscribe,
    tryUnsubscribe: tryUnsubscribe,
    getListeners: function getListeners() {
      return listeners;
    }
  };
  return subscription;
}

// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react_15 : react_14;

function Provider(_ref) {
  var store = _ref.store,
      context = _ref.context,
      children = _ref.children;
  var contextValue = react_13(function () {
    var subscription = createSubscription(store);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store: store,
      subscription: subscription
    };
  }, [store]);
  var previousState = react_13(function () {
    return store.getState();
  }, [store]);
  useIsomorphicLayoutEffect(function () {
    var subscription = contextValue.subscription;
    subscription.trySubscribe();

    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }

    return function () {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || ReactReduxContext;
  return /*#__PURE__*/react.createElement(Context.Provider, {
    value: contextValue
  }, children);
}

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n$1=b?Symbol.for("react.forward_ref"):60112,p$1=b?Symbol.for("react.suspense"):60113,q$1=b?
Symbol.for("react.suspense_list"):60120,r$1=b?Symbol.for("react.memo"):60115,t$1=b?Symbol.for("react.lazy"):60116,v$2=b?Symbol.for("react.block"):60121,w$1=b?Symbol.for("react.fundamental"):60117,x$1=b?Symbol.for("react.responder"):60118,y$1=b?Symbol.for("react.scope"):60119;
function z$1(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p$1:return a;default:switch(a=a&&a.$$typeof,a){case k:case n$1:case t$1:case r$1:case h:return a;default:return u}}case d:return u}}}function A$1(a){return z$1(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n$1;var Fragment$1=e;var Lazy=t$1;var Memo=r$1;var Portal=d;
var Profiler$1=g;var StrictMode$1=f;var Suspense$1=p$1;var isAsyncMode=function(a){return A$1(a)||z$1(a)===l};var isConcurrentMode=A$1;var isContextConsumer=function(a){return z$1(a)===k};var isContextProvider=function(a){return z$1(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z$1(a)===n$1};var isFragment=function(a){return z$1(a)===e};var isLazy=function(a){return z$1(a)===t$1};
var isMemo=function(a){return z$1(a)===r$1};var isPortal=function(a){return z$1(a)===d};var isProfiler=function(a){return z$1(a)===g};var isStrictMode=function(a){return z$1(a)===f};var isSuspense=function(a){return z$1(a)===p$1};
var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p$1||a===q$1||"object"===typeof a&&null!==a&&(a.$$typeof===t$1||a.$$typeof===r$1||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n$1||a.$$typeof===w$1||a.$$typeof===x$1||a.$$typeof===y$1||a.$$typeof===v$2)};var typeOf=z$1;

var reactIs_production_min = {
	AsyncMode: AsyncMode,
	ConcurrentMode: ConcurrentMode,
	ContextConsumer: ContextConsumer,
	ContextProvider: ContextProvider,
	Element: Element,
	ForwardRef: ForwardRef,
	Fragment: Fragment$1,
	Lazy: Lazy,
	Memo: Memo,
	Portal: Portal,
	Profiler: Profiler$1,
	StrictMode: StrictMode$1,
	Suspense: Suspense$1,
	isAsyncMode: isAsyncMode,
	isConcurrentMode: isConcurrentMode,
	isContextConsumer: isContextConsumer,
	isContextProvider: isContextProvider,
	isElement: isElement,
	isForwardRef: isForwardRef,
	isFragment: isFragment,
	isLazy: isLazy,
	isMemo: isMemo,
	isPortal: isPortal,
	isProfiler: isProfiler,
	isStrictMode: isStrictMode,
	isSuspense: isSuspense,
	isValidElementType: isValidElementType,
	typeOf: typeOf
};

var reactIs = createCommonjsModule(function (module) {

{
  module.exports = reactIs_production_min;
}
});
var reactIs_1 = reactIs.isValidElementType;
var reactIs_2 = reactIs.isContextConsumer;

var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1=60103,c$1=60106,d$1=60107,e$1=60108,f$1=60114,g$1=60109,h$1=60110,k$1=60112,l$1=60113,m$1=60120,n$2=60115,p$2=60116,q$2=60121,r$2=60122,u$2=60117,v$3=60129,w$2=60131;
if("function"===typeof Symbol&&Symbol.for){var x$2=Symbol.for;b$1=x$2("react.element");c$1=x$2("react.portal");d$1=x$2("react.fragment");e$1=x$2("react.strict_mode");f$1=x$2("react.profiler");g$1=x$2("react.provider");h$1=x$2("react.context");k$1=x$2("react.forward_ref");l$1=x$2("react.suspense");m$1=x$2("react.suspense_list");n$2=x$2("react.memo");p$2=x$2("react.lazy");q$2=x$2("react.block");r$2=x$2("react.server.block");u$2=x$2("react.fundamental");v$3=x$2("react.debug_trace_mode");w$2=x$2("react.legacy_hidden");}
function y$2(a){if("object"===typeof a&&null!==a){var t=a.$$typeof;switch(t){case b$1:switch(a=a.type,a){case d$1:case f$1:case e$1:case l$1:case m$1:return a;default:switch(a=a&&a.$$typeof,a){case h$1:case k$1:case p$2:case n$2:case g$1:return a;default:return t}}case c$1:return t}}}var z$2=g$1,A$2=b$1,B$1=k$1,C$2=d$1,D$1=p$2,E$2=n$2,F$2=c$1,G$2=f$1,H$2=e$1,I$2=l$1;var ContextConsumer$1=h$1;var ContextProvider$1=z$2;var Element$1=A$2;var ForwardRef$1=B$1;var Fragment$2=C$2;var Lazy$1=D$1;var Memo$1=E$2;var Portal$1=F$2;var Profiler$2=G$2;var StrictMode$2=H$2;
var Suspense$2=I$2;var isAsyncMode$1=function(){return !1};var isConcurrentMode$1=function(){return !1};var isContextConsumer$1=function(a){return y$2(a)===h$1};var isContextProvider$1=function(a){return y$2(a)===g$1};var isElement$1=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b$1};var isForwardRef$1=function(a){return y$2(a)===k$1};var isFragment$1=function(a){return y$2(a)===d$1};var isLazy$1=function(a){return y$2(a)===p$2};var isMemo$1=function(a){return y$2(a)===n$2};
var isPortal$1=function(a){return y$2(a)===c$1};var isProfiler$1=function(a){return y$2(a)===f$1};var isStrictMode$1=function(a){return y$2(a)===e$1};var isSuspense$1=function(a){return y$2(a)===l$1};var isValidElementType$1=function(a){return "string"===typeof a||"function"===typeof a||a===d$1||a===f$1||a===v$3||a===e$1||a===l$1||a===m$1||a===w$2||"object"===typeof a&&null!==a&&(a.$$typeof===p$2||a.$$typeof===n$2||a.$$typeof===g$1||a.$$typeof===h$1||a.$$typeof===k$1||a.$$typeof===u$2||a.$$typeof===q$2||a[0]===r$2)?!0:!1};
var typeOf$1=y$2;

var reactIs_production_min$1 = {
	ContextConsumer: ContextConsumer$1,
	ContextProvider: ContextProvider$1,
	Element: Element$1,
	ForwardRef: ForwardRef$1,
	Fragment: Fragment$2,
	Lazy: Lazy$1,
	Memo: Memo$1,
	Portal: Portal$1,
	Profiler: Profiler$2,
	StrictMode: StrictMode$2,
	Suspense: Suspense$2,
	isAsyncMode: isAsyncMode$1,
	isConcurrentMode: isConcurrentMode$1,
	isContextConsumer: isContextConsumer$1,
	isContextProvider: isContextProvider$1,
	isElement: isElement$1,
	isForwardRef: isForwardRef$1,
	isFragment: isFragment$1,
	isLazy: isLazy$1,
	isMemo: isMemo$1,
	isPortal: isPortal$1,
	isProfiler: isProfiler$1,
	isStrictMode: isStrictMode$1,
	isSuspense: isSuspense$1,
	isValidElementType: isValidElementType$1,
	typeOf: typeOf$1
};

var reactIs$1 = createCommonjsModule(function (module) {

{
  module.exports = reactIs_production_min$1;
}
});
var reactIs_1$1 = reactIs$1.isValidElementType;
var reactIs_2$1 = reactIs$1.isContextConsumer;

/**
 * A hook to access the value of the `ReactReduxContext`. This is a low-level
 * hook that you should usually not need to call directly.
 *
 * @returns {any} the value of the `ReactReduxContext`
 *
 * @example
 *
 * import React from 'react'
 * import { useReduxContext } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const { store } = useReduxContext()
 *   return <div>{store.getState()}</div>
 * }
 */

function useReduxContext() {
  var contextValue = react_10(ReactReduxContext);

  return contextValue;
}

/**
 * Hook factory, which creates a `useStore` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useStore` hook bound to the specified context.
 */

function createStoreHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }

  var useReduxContext$1 = context === ReactReduxContext ? useReduxContext : function () {
    return react_10(context);
  };
  return function useStore() {
    var _useReduxContext = useReduxContext$1(),
        store = _useReduxContext.store;

    return store;
  };
}
/**
 * A hook to access the redux store.
 *
 * @returns {any} the redux store
 *
 * @example
 *
 * import React from 'react'
 * import { useStore } from 'react-redux'
 *
 * export const ExampleComponent = () => {
 *   const store = useStore()
 *   return <div>{store.getState()}</div>
 * }
 */

var useStore = /*#__PURE__*/createStoreHook();

/**
 * Hook factory, which creates a `useDispatch` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useDispatch` hook bound to the specified context.
 */

function createDispatchHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }

  var useStore$1 = context === ReactReduxContext ? useStore : createStoreHook(context);
  return function useDispatch() {
    var store = useStore$1();
    return store.dispatch;
  };
}
/**
 * A hook to access the redux `dispatch` function.
 *
 * @returns {any|function} redux store's `dispatch` function
 *
 * @example
 *
 * import React, { useCallback } from 'react'
 * import { useDispatch } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const dispatch = useDispatch()
 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
 *   return (
 *     <div>
 *       <span>{value}</span>
 *       <button onClick={increaseCounter}>Increase counter</button>
 *     </div>
 *   )
 * }
 */

var useDispatch = /*#__PURE__*/createDispatchHook();

var refEquality = function refEquality(a, b) {
  return a === b;
};

function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
  var _useReducer = react_17(function (s) {
    return s + 1;
  }, 0),
      forceRender = _useReducer[1];

  var subscription = react_13(function () {
    return createSubscription(store, contextSub);
  }, [store, contextSub]);
  var latestSubscriptionCallbackError = react_16();
  var latestSelector = react_16();
  var latestStoreState = react_16();
  var latestSelectedState = react_16();
  var storeState = store.getState();
  var selectedState;

  try {
    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      var newSelectedState = selector(storeState); // ensure latest selected state is reused so that a custom equality function can result in identical references

      if (latestSelectedState.current === undefined || !equalityFn(newSelectedState, latestSelectedState.current)) {
        selectedState = newSelectedState;
      } else {
        selectedState = latestSelectedState.current;
      }
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }

    throw err;
  }

  useIsomorphicLayoutEffect(function () {
    latestSelector.current = selector;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = undefined;
  });
  useIsomorphicLayoutEffect(function () {
    function checkForUpdates() {
      try {
        var newStoreState = store.getState(); // Avoid calling selector multiple times if the store's state has not changed

        if (newStoreState === latestStoreState.current) {
          return;
        }

        var _newSelectedState = latestSelector.current(newStoreState);

        if (equalityFn(_newSelectedState, latestSelectedState.current)) {
          return;
        }

        latestSelectedState.current = _newSelectedState;
        latestStoreState.current = newStoreState;
      } catch (err) {
        // we ignore all errors here, since when the component
        // is re-rendered, the selectors are called again, and
        // will throw again, if neither props nor store state
        // changed
        latestSubscriptionCallbackError.current = err;
      }

      forceRender();
    }

    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function () {
      return subscription.tryUnsubscribe();
    };
  }, [store, subscription]);
  return selectedState;
}
/**
 * Hook factory, which creates a `useSelector` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useSelector` hook bound to the specified context.
 */


function createSelectorHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }

  var useReduxContext$1 = context === ReactReduxContext ? useReduxContext : function () {
    return react_10(context);
  };
  return function useSelector(selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }

    var _useReduxContext = useReduxContext$1(),
        store = _useReduxContext.store,
        contextSub = _useReduxContext.subscription;

    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
    react_11(selectedState);
    return selectedState;
  };
}
/**
 * A hook to access the redux store's state. This hook takes a selector function
 * as an argument. The selector is called with the store state.
 *
 * This hook takes an optional equality comparison function as the second parameter
 * that allows you to customize the way the selected state is compared to determine
 * whether the component needs to be re-rendered.
 *
 * @param {Function} selector the selector function
 * @param {Function=} equalityFn the function that will be used to determine equality
 *
 * @returns {any} the selected state
 *
 * @example
 *
 * import React from 'react'
 * import { useSelector } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const counter = useSelector(state => state.counter)
 *   return <div>{counter}</div>
 * }
 */

var useSelector = /*#__PURE__*/createSelectorHook();

// with standard React renderers (ReactDOM, React Native)

setBatch(reactDom_1);

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

// Drag & drop data formats
const SPLITTABLE_PANEL_CONTROL = 'splittable-panel-control';

// class names
const SPLITTABLE_PANEL_CLASS_NAME = 'splittable-panel';
const SEPARATOR_CONTAINER_CLASS_NAME = 'splittable-panel-separator-container';
const VERTICAL_SEPARATOR_CLASS_NAME = 'splittable-panel-v-separator';
const HORIZONTAL_SEPARATOR_CLASS_NAME = 'splittable-panel-h-separator';
const SPLITTABLE_PANEL_CONTROL_V_SPLIT_CLASS_NAME =
  'splittable-panel-control-v-split';
const SPLITTABLE_PANEL_CONTROL_H_SPLIT_CLASS_NAME =
  'splittable-panel-control-h-split';

const initialState = { rootPanel: {} };

// actions
const V_SPLIT = 'V_SPLIT';
const H_SPLIT = 'H_SPLIT';
const SET_DATA = 'SET_DATA';
const MOVE_SEPARATOR = 'MOVE_SEPARATOR';
const RESET_PANELS = 'RESET_PANELS';

// action creator creators
const vSplitCreator = (prefix = '') => splitAt => ({
  type: prefix + V_SPLIT,
  payload: { splitAt }
});

const hSplitCreator = (prefix = '') => splitAt => ({
  type: prefix + H_SPLIT,
  payload: { splitAt }
});

const setDataCreator = (prefix = '') => (setAt, data) => ({
  type: prefix + SET_DATA,
  payload: { setAt, data }
});

const moveSeparatorCreator = (prefix = '') => (id, moveTo) => ({
  type: prefix + MOVE_SEPARATOR,
  payload: { id, moveTo }
});

const resetPanelsCreator = (prefix = '') => (state = initialState) => ({
  type: prefix + RESET_PANELS,
  payload: { state }
});

// helper functions
const getPanelById = (state, id = '', depth = 0) => {
  let subpanel;
  switch (id[depth]) {
    case '_':
      subpanel = state.rootPanel;
      break
    case 'L':
      subpanel = state.splitX ? state.subpanel1 : null;
      break
    case 'R':
      subpanel = state.splitX ? state.subpanel2 : null;
      break
    case 'T':
      subpanel = state.splitY ? state.subpanel1 : null;
      break
    case 'B':
      subpanel = state.splitY ? state.subpanel2 : null;
      break
    default:
      subpanel = null;
  }
  if (!subpanel) {
    return null
  }
  depth += 1;
  if (id.length === depth) {
    return subpanel
  }
  return getPanelById(subpanel, id, depth)
};

// reducers
const atReducer = (panel, x, y, reducer) => {
  if (panel.splitX) {
    if (x < panel.splitX) {
      x /= panel.splitX;
      const prev = panel.subpanel1;
      const subpanel = atReducer(prev, x, y, reducer);
      return prev === subpanel ? panel : { ...panel, subpanel1: subpanel }
    } else {
      x = (x - panel.splitX) / (1.0 - panel.splitX);
      const prev = panel.subpanel2;
      const subpanel = atReducer(prev, x, y, reducer);
      return prev === subpanel ? panel : { ...panel, subpanel2: subpanel }
    }
  } else if (panel.splitY) {
    if (y < panel.splitY) {
      y /= panel.splitY;
      const prev = panel.subpanel1;
      const subpanel = atReducer(prev, x, y, reducer);
      return prev === subpanel ? panel : { ...panel, subpanel1: subpanel }
    } else {
      y = (y - panel.splitY) / (1.0 - panel.splitY);
      const prev = panel.subpanel2;
      const subpanel = atReducer(prev, x, y, reducer);
      return prev === subpanel ? panel : { ...panel, subpanel2: subpanel }
    }
  } else {
    return reducer(panel, x, y)
  }
};

const vSplitReducer = (rootPanel, x, y) =>
  atReducer(rootPanel, x, y, (targetPanel, localX, localY) => {
    const splitX = localX;
    if (splitX > 0.0 && splitX < 1.0) {
      return {
        ...targetPanel,
        splitX,
        subpanel1: targetPanel,
        subpanel2: targetPanel
      }
    } else {
      return targetPanel
    }
  });

const hSplitReducer = (rootPanel, x, y) =>
  atReducer(rootPanel, x, y, (targetPanel, localX, localY) => {
    const splitY = localY;
    if (splitY > 0.0 && splitY < 1.0) {
      return {
        ...targetPanel,
        splitY,
        subpanel1: targetPanel,
        subpanel2: targetPanel
      }
    } else {
      return targetPanel
    }
  });

const setDataReducer = (rootPanel, x, y, data) =>
  atReducer(rootPanel, x, y, (targetPanel, localX, localY) => {
    const prev = targetPanel.data || {};
    if (Object.keys(data).every(key => data[key] === prev[key])) {
      return targetPanel
    } else {
      return {
        ...targetPanel,
        data: { ...prev, ...data }
      }
    }
  });

// target panel must exist
const moveSeparatorReducer = (panel, id, moveToX, moveToY, depth = 1) => {
  if (id.length === depth) {
    if (panel.splitX) {
      if (moveToX <= 0.0) {
        return panel.subpanel2
      } else if (moveToX >= 1.0) {
        return panel.subpanel1
      } else {
        return { ...panel, splitX: moveToX }
      }
    } else if (panel.splitY) {
      if (moveToY <= 0.0) {
        return panel.subpanel2
      } else if (moveToY >= 1.0) {
        return panel.subpanel1
      } else {
        return { ...panel, splitY: moveToY }
      }
    }
  }
  let subpanelKey;
  switch (id[depth]) {
    case 'L':
      subpanelKey = 'subpanel1';
      moveToX /= panel.splitX;
      break
    case 'T':
      subpanelKey = 'subpanel1';
      moveToY /= panel.splitY;
      break
    case 'R':
      subpanelKey = 'subpanel2';
      moveToX = (moveToX - panel.splitX) / (1.0 - panel.splitX);
      break
    case 'B':
      subpanelKey = 'subpanel2';
      moveToY = (moveToY - panel.splitY) / (1.0 - panel.splitY);
      break
  }
  const prev = panel[subpanelKey];
  const subpanel = moveSeparatorReducer(prev, id, moveToX, moveToY, depth + 1);
  return subpanel === prev ? panel : { ...panel, [subpanelKey]: subpanel }
};

const splittablePanelRoot = (
  state = initialState,
  action = { type: '' }
) => {
  switch (action.type) {
    case RESET_PANELS: {
      return {
        ...action.payload.state
      }
    }
    case V_SPLIT: {
      const [x, y] = action.payload.splitAt;
      if (x > 0.0 && x < 1.0 && y > 0.0 && y < 1.0) {
        const prev = state.rootPanel;
        const rootPanel = vSplitReducer(prev, x, y);
        return rootPanel === prev ? state : { ...state, rootPanel }
      } else {
        // no effect
        return state
      }
    }
    case H_SPLIT: {
      const [x, y] = action.payload.splitAt;
      if (x > 0.0 && x < 1.0 && y > 0.0 && y < 1.0) {
        const prev = state.rootPanel;
        const rootPanel = hSplitReducer(prev, x, y);
        return rootPanel === prev ? state : { ...state, rootPanel }
      } else {
        // no effect
        return state
      }
    }
    case SET_DATA: {
      const payload = action.payload;
      const data = payload.data;
      if (Object.keys(data || {}).length === 0) {
        // no effect
        return state
      }
      const [x, y] = payload.setAt;
      if (x > 0.0 && x < 1.0 && y > 0.0 && y < 1.0) {
        const prev = state.rootPanel;
        const rootPanel = setDataReducer(prev, x, y, data);
        return rootPanel === prev ? state : { ...state, rootPanel }
      } else {
        // no effect
        return state
      }
    }
    case MOVE_SEPARATOR: {
      const payload = action.payload;
      const id = payload.id;
      const target = getPanelById(state, id);
      if (target && target.subpanel1) {
        const prev = state.rootPanel;
        const rootPanel = moveSeparatorReducer(prev, id, ...payload.moveTo);
        return rootPanel === prev ? state : { ...state, rootPanel }
      } else {
        // no target, or target is not splitted
        return state
      }
    }
    default: {
      return state
    }
  }
};

// components
const SplittablePanel = (
  { splitX, splitY, subpanel1, subpanel2, id, setMoveSeparatorTarget }
) => {
  const splitXPercent = react_13(
    () => splitX ? splitX * 100 + '%' : null,
    [splitX]
  );
  const splitYPercent = react_13(
    () => splitY ? splitY * 100 + '%' : null,
    [splitY]
  );
  const onMouseDown = react_9(
    e => {
      setMoveSeparatorTarget(id);
      e.preventDefault();
    },
    [id, setMoveSeparatorTarget]
  );
  const SeparatorX = react_13(
    () => react.createElement(
      'div',
      {
        className: VERTICAL_SEPARATOR_CLASS_NAME,
        onMouseDown
      }
    ),
    [onMouseDown]
  );
  const SeparatorY = react_13(
    () => react.createElement(
      'div',
      {
        className: HORIZONTAL_SEPARATOR_CLASS_NAME,
        onMouseDown
      }
    ),
    [onMouseDown]
  );
  const VSubpanel1 = react_13(
    () => react.createElement(
      SplittablePanel,
      {
        ...subpanel1,
        id: id + 'L',
        setMoveSeparatorTarget
      }
    ),
    [subpanel1, id, setMoveSeparatorTarget]
  );
  const VSubpanel2 = react_13(
    () => react.createElement(
      SplittablePanel,
      {
        ...subpanel2,
        id: id + 'R',
        setMoveSeparatorTarget
      }
    ),
    [subpanel2, id, setMoveSeparatorTarget]
  );
  const HSubpanel1 = react_13(
    () => react.createElement(
      SplittablePanel,
      {
        ...subpanel1,
        id: id + 'T',
        setMoveSeparatorTarget
      }
    ),
    [subpanel1, id, setMoveSeparatorTarget]
  );
  const HSubpanel2 = react_13(
    () => react.createElement(
      SplittablePanel,
      {
        ...subpanel2,
        id: id + 'B',
        setMoveSeparatorTarget
      }
    ),
    [subpanel2, id, setMoveSeparatorTarget]
  );
  const VSplitPanel = react_13(
    () => splitXPercent
      ? react.createElement(react.Fragment, null,
        react.createElement(
          'div',
          {
            className: SEPARATOR_CONTAINER_CLASS_NAME,
            style: { left: splitXPercent, width: '0%' }
          },
          SeparatorX
        ),
        react.createElement(
          'div',
          {
            className: SPLITTABLE_PANEL_CLASS_NAME,
            style: { width: splitXPercent }
          },
          VSubpanel1
        ),
        react.createElement(
          'div',
          {
            className: SPLITTABLE_PANEL_CLASS_NAME,
            style: {
              left: splitXPercent,
              width: `calc(100% - ${splitXPercent})`
            }
          },
          VSubpanel2
        )
      )
      : null,
    [splitXPercent, SeparatorX, VSubpanel1, VSubpanel2]
  );
  const HSplitPanel = react_13(
    () => splitYPercent
      ? react.createElement(react.Fragment, null,
        react.createElement(
          'div',
          {
            className: SEPARATOR_CONTAINER_CLASS_NAME,
            style: { top: splitYPercent, height: '0%' }
          },
          SeparatorY
        ),
        react.createElement(
          'div',
          {
            className: SPLITTABLE_PANEL_CLASS_NAME,
            style: { height: splitYPercent }
          },
          HSubpanel1
        ),
        react.createElement(
          'div',
          {
            className: SPLITTABLE_PANEL_CLASS_NAME,
            style: {
              top: splitYPercent,
              height: `calc(100% - ${splitYPercent})`
            }
          },
          HSubpanel2
        )
      )
      : null,
    [splitYPercent, SeparatorY, HSubpanel1, HSubpanel2]
  );
  return splitXPercent ? VSplitPanel : splitYPercent ? HSplitPanel : null
};

const VSplitButton = () => react_13(
  () => react.createElement(
    'div',
    {
      className: SPLITTABLE_PANEL_CONTROL_V_SPLIT_CLASS_NAME,
      draggable: true,
      onDragStart: e => {
        e.dataTransfer.setData(SPLITTABLE_PANEL_CONTROL, V_SPLIT);
        e.dataTransfer.setData('text/plain', '');
        e.dataTransfer.effectAllowed = 'copy';
      }
    }
  ),
  []
);

const HSplitButton = () => react_13(
  () => react.createElement(
    'div',
    {
      className: SPLITTABLE_PANEL_CONTROL_H_SPLIT_CLASS_NAME,
      draggable: true,
      onDragStart: e => {
        e.dataTransfer.setData(SPLITTABLE_PANEL_CONTROL, H_SPLIT);
        e.dataTransfer.setData('text/plain', '');
        e.dataTransfer.effectAllowed = 'copy';
      }
    }
  ),
  []
);

const allowDrop = e => {
  if (e.dataTransfer.types[0] === SPLITTABLE_PANEL_CONTROL) {
    e.dataTransfer.dropEffect = 'copy';
    e.preventDefault();
  }
};

const SplittablePanelRootCreator = (
  stateSelector = state => state,
  actionPrefix = ''
) => {
  const rootPanelSelector = state => stateSelector(state).rootPanel;
  const vSplit = vSplitCreator(actionPrefix);
  const hSplit = hSplitCreator(actionPrefix);
  const setData = setDataCreator(actionPrefix);
  const moveSeparator = moveSeparatorCreator(actionPrefix);
  const SplittablePanelRoot = ({ children }) => {
    const rootPanel = useSelector(rootPanelSelector);
    const dispatch = useDispatch();
    const ref = react_16(null);
    const [moveSeparatorTarget, setMoveSeparatorTarget] = react_8('');
    const onMouseMove = react_13(
      () => moveSeparatorTarget
        ? e => {
          const x = e.clientX;
          const y = e.clientY;
          const clientRect = ref.current.getBoundingClientRect();
          const left = clientRect.left;
          const right = clientRect.right;
          const top = clientRect.top;
          const bottom = clientRect.bottom;
          const splitX = (x - left) / (right - left);
          const splitY = (y - top) / (bottom - top);
          dispatch(moveSeparator(moveSeparatorTarget, [splitX, splitY]));
        }
        : null,
      [moveSeparatorTarget, dispatch]
    );
    const onMouseUp = react_13(
      () => onMouseMove
        ? e => {
          onMouseMove(e);
          setMoveSeparatorTarget('');
        }
        : null,
      [onMouseMove]
    );
    const onMouseLeave = react_13(
      () => onMouseMove
        ? e => {
          onMouseMove(e);
          setMoveSeparatorTarget('');
        }
        : null,
      [onMouseMove]
    );
    const onDrop = react_9(
      e => {
        const data = e.dataTransfer.getData(SPLITTABLE_PANEL_CONTROL);
        switch (data) {
          case V_SPLIT: {
            const x = e.clientX;
            const y = e.clientY;
            const clientRect = ref.current.getBoundingClientRect();
            const left = clientRect.left;
            const right = clientRect.right;
            const top = clientRect.top;
            const bottom = clientRect.bottom;
            const splitX = (x - left) / (right - left);
            const splitY = (y - top) / (bottom - top);
            dispatch(vSplit([splitX, splitY]));
            break
          }
          case H_SPLIT: {
            const x = e.clientX;
            const y = e.clientY;
            const clientRect = ref.current.getBoundingClientRect();
            const left = clientRect.left;
            const right = clientRect.right;
            const top = clientRect.top;
            const bottom = clientRect.bottom;
            const splitX = (x - left) / (right - left);
            const splitY = (y - top) / (bottom - top);
            dispatch(hSplit([splitX, splitY]));
            break
          }
          default: {
            const x = e.clientX;
            const y = e.clientY;
            const clientRect = ref.current.getBoundingClientRect();
            const left = clientRect.left;
            const right = clientRect.right;
            const top = clientRect.top;
            const bottom = clientRect.bottom;
            const setX = (x - left) / (right - left);
            const setY = (y - top) / (bottom - top);
            dispatch(setData([setX, setY], JSON.parse(data)));
            break
          }
        }
        e.preventDefault();
      },
      [dispatch]
    );
    const RootPanel = react_13(
      () => react.createElement(
        SplittablePanel,
        {
          ...rootPanel,
          id: '_',
          setMoveSeparatorTarget
        }
      ),
      [rootPanel]
    );
    return react_13(
      () => react.createElement(
        'div',
        {
          ref,
          className: SPLITTABLE_PANEL_CLASS_NAME,
          onMouseMove,
          onMouseUp,
          onMouseLeave,
          onDragEnter: allowDrop,
          onDragOver: allowDrop,
          onDrop
        },
        RootPanel,
        children
      ),
      [RootPanel, onMouseMove, onMouseUp, onMouseLeave, onDrop]
    )
  };
  return SplittablePanelRoot
};

/* @license-end */

// Cache implementation based on Erik Rasmussen's `lru-memoize`:
// https://github.com/erikras/lru-memoize
var NOT_FOUND = 'NOT_FOUND';

function createSingletonCache(equals) {
  var entry;
  return {
    get: function get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }

      return NOT_FOUND;
    },
    put: function put(key, value) {
      entry = {
        key: key,
        value: value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear() {
      entry = undefined;
    }
  };
}

function createLruCache(maxSize, equals) {
  var entries = [];

  function get(key) {
    var cacheIndex = entries.findIndex(function (entry) {
      return equals(key, entry.key);
    }); // We found a cached entry

    if (cacheIndex > -1) {
      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top

      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }

      return entry.value;
    } // No entry found in cache, return sentinel


    return NOT_FOUND;
  }

  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      // TODO Is unshift slow?
      entries.unshift({
        key: key,
        value: value
      });

      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }

  function getEntries() {
    return entries;
  }

  function clear() {
    entries = [];
  }

  return {
    get: get,
    put: put,
    getEntries: getEntries,
    clear: clear
  };
}

var defaultEqualityCheck = function defaultEqualityCheck(a, b) {
  return a === b;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.


    var length = prev.length;

    for (var i = 0; i < length; i++) {
      if (!equalityCheck(prev[i], next[i])) {
        return false;
      }
    }

    return true;
  };
}
// defaultMemoize now supports a configurable cache size with LRU behavior,
// and optional comparison of the result value with existing values
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck,
      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,
      _providedOptions$maxS = providedOptions.maxSize,
      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,
      resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons

  function memoized() {
    var value = cache.get(arguments);

    if (value === NOT_FOUND) {
      // @ts-ignore
      value = func.apply(null, arguments);

      if (resultEqualityCheck) {
        var entries = cache.getEntries();
        var matchingEntry = entries.find(function (entry) {
          return resultEqualityCheck(entry.value, value);
        });

        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }

      cache.put(arguments, value);
    }

    return value;
  }

  memoized.clearCache = function () {
    return cache.clear();
  };

  return memoized;
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep === 'function' ? "function " + (dep.name || 'unnamed') + "()" : typeof dep;
    }).join(', ');
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }

  var createSelector = function createSelector() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var _recomputations = 0;

    var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.
    // So, start by declaring the default value here.
    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)


    var directlyPassedOptions = {
      memoizeOptions: undefined
    }; // Normally, the result func or "output selector" is the last arg

    var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object

    if (typeof resultFunc === 'object') {
      directlyPassedOptions = resultFunc; // and pop the real result func off

      resultFunc = funcs.pop();
    }

    if (typeof resultFunc !== 'function') {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    } // Determine which set of options we're using. Prefer options passed directly,
    // but fall back to options given to createSelectorCreator.


    var _directlyPassedOption = directlyPassedOptions,
        _directlyPassedOption2 = _directlyPassedOption.memoizeOptions,
        memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer
    // is an array. In most libs I've looked at, it's an equality function or options object.
    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full
    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so
    // we wrap it in an array so we can apply it.

    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize.apply(void 0, [function () {
      _recomputations++; // apply arguments instead of spreading for performance.

      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.

    var selector = memoize(function () {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        // @ts-ignore
        params.push(dependencies[i].apply(null, arguments));
      } // apply arguments instead of spreading for performance.


      _lastResult = memoizedResultFunc.apply(null, params);
      return _lastResult;
    });
    Object.assign(selector, {
      resultFunc: resultFunc,
      memoizedResultFunc: memoizedResultFunc,
      dependencies: dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector;
  }; // @ts-ignore


  return createSelector;
}
var createSelector = /* #__PURE__ */createSelectorCreator(defaultMemoize);

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const _internalKey = new WeakMap();

class InternalKeyMap extends Map {
  delete (keys) {
    if (keys.length === 0) {
      return _internalKey.delete(this)
    }
    const key0 = keys[0];
    const child = super.get(key0);
    if (!child) {
      return false
    }
    const deleted = child.delete(keys.slice(1));
    if (deleted && child.size === 0 && !child.has([])) {
      super.delete(key0);
    }
    return deleted
  }

  get (keys) {
    if (keys.length === 0) {
      return _internalKey.get(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return undefined
    }
    return child.get(keys.slice(1))
  }

  has (keys) {
    if (keys.length === 0) {
      return _internalKey.has(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return false
    }
    return child.has(keys.slice(1))
  }

  set (keys, internalKey) {
    if (keys.length === 0) {
      _internalKey.set(this, internalKey);
      return this
    }
    const key0 = keys[0];
    let child = super.get(key0);
    if (!child) {
      child = new InternalKeyMap();
      super.set(key0, child);
    }
    child.set(keys.slice(1), internalKey);
    return this
  }
}

/**
 * @desc
 * The {@link MultiKeyMap} is the class for multi-key map.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class MultiKeyMap extends Map {
  /**
   * @desc
   * The constructor function of the {@link MultiKeyMap} class.
   *
   * @param {object} iterable
   * An iterable object of which elements are arrays of [keys, value] pairs.
   * Each `keys` is an array of keys.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { MultiKeyMap } from '@kkitahara/qc-tools'
   *
   * let a = new MultiKeyMap()
   * a.set([1, 2, 3], 1)
   * a.set([1, null], 2)
   * a.set([], 3)
   * a.set([undefined], 4)
   *
   * a.get([1, 2, 3]) // 1
   * a.get([1, null]) // 2
   * a.get([]) // 3
   * a.get([undefined]) // 4
   * a.get([1]) // undefined
   *
   * a.has([1, 2, 3]) // true
   * a.has([1, null]) // true
   * a.has([]) // true
   * a.has([undefined]) // true
   * a.has([1]) // false
   *
   * a.delete([1, 2, 3]) // true
   * a.delete([1, null]) // true
   * a.delete([]) // true
   * a.delete([undefined]) // true
   * a.delete([1]) // false
   *
   * a.has([1, 2, 3]) // false
   * a.has([1, null]) // false
   * a.has([]) // false
   * a.has([undefined]) // false
   * a.has([1]) // false
   *
   * a = new MultiKeyMap([
   *   [[1, 2, 3], 1],
   *   [[1, null], 2],
   *   [[], 3],
   *   [[undefined], 4]
   * ])
   * a.get([1, 2, 3]) // 1
   * a.get([1, null]) // 2
   * a.get([]) // 3
   * a.get([undefined]) // 4
   */
  constructor (...args) {
    super();
    _internalKey.set(this, new InternalKeyMap());
    const iterable = args[0];
    if (iterable !== undefined && iterable !== null) {
      for (const [keys, value] of iterable) {
        this.set(keys, value);
      }
    }
  }

  clear () {
    const internalKeyMap = _internalKey.get(this);
    for (const internalKey of this.keys()) {
      internalKeyMap.delete(internalKey);
    }
    super.clear();
  }

  /**
   * @desc
   * The {@link MultiKeyMap#delete} removes any value associated to the
   * `keys` from `this` map.
   *
   * @param {object[]} keys
   *
   * @return {boolean}
   * `true` if a value is successfully removed, and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  delete (keys) {
    const internalKeyMap = _internalKey.get(this);
    const internalKey = internalKeyMap.get(keys);
    if (internalKey) {
      internalKeyMap.delete(keys);
    }
    return super.delete(internalKey)
  }

  /**
   * @desc
   * The {@link MultiKeyMap#get} returns the value associated to the `keys`
   * if exist in `this` map, or `undefined` otherwise.
   *
   * @param {object[]} keys
   *
   * @return {object|undefined}
   * The value associated to the `keys` if exist, or `undefined.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get (keys) {
    const internalKey = _internalKey.get(this).get(keys);
    return super.get(internalKey)
  }

  /**
   * @desc
   * The {@link MultiKeyMap#has} returns `true` if a value is associated to
   * the `keys` in `this` map, or `false` otherwise.
   *
   * @param {object[]} keys
   *
   * @return {boolean}
   * `true` if a value is associated to the `keys`, or `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  has (keys) {
    return _internalKey.get(this).has(keys)
  }

  /**
   * @desc
   * The {@link MultiKeyMap#set} sets the `value` for the `keys` in `this`
   * map.
   * When a new entry is created, the given `keys` is used as the internal key.
   * Therefore, a mutation of the given `keys` should be avoided.
   *
   * @param {object[]} keys
   * @param {Any} value
   *
   * @return {MultiKeyMap}
   * `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  set (keys, value) {
    const internalKeyMap = _internalKey.get(this);
    let internalKey = internalKeyMap.get(keys);
    if (!internalKey) {
      internalKey = keys;
      internalKeyMap.set(keys, internalKey);
    }
    super.set(internalKey, value);
    return this
  }
}

Object.defineProperty(
  MultiKeyMap.prototype,
  Symbol.iterator,
  {
    value: MultiKeyMap.prototype.entries,
    writable: true,
    enumerable: false,
    configurable: true
  }
);

Object.defineProperty(
  MultiKeyMap.prototype,
  Symbol.toStringTag,
  {
    value: 'MultiKeyMap',
    writable: false,
    enumerable: false,
    configurable: true
  }
);

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const _value = new WeakMap();

/**
 * @desc
 * The {@link MultiKeyWeakMap} is the class for multi-key weak map.
 *
 * @version 1.0.0
 * @since 1.0.0
 *
 * @example
 * import { MultiKeyWeakMap } from '@kkitahara/qc-tools'
 *
 * let a = new MultiKeyWeakMap()
 * let b = {}
 * let c = {}
 * let d = {}
 *
 * a.set([b, c], 1)
 * a.set([c, b], 2)
 * a.set([b], 3)
 * a.set([c, b, d], 4)
 *
 * a.get([b, c]) // 1
 * a.get([c, b]) // 2
 * a.get([b]) // 3
 * a.get([c, b, d]) // 4
 * a.get([c]) // undefined
 * a.get([c, d, b]) // undefined
 *
 * a.has([b, c]) // true
 * a.has([c, b]) // true
 * a.has([b]) // true
 * a.has([c, b, d]) // true
 * a.has([c]) // false
 * a.has([c, d, b]) // false
 *
 * a.delete([b]) // true
 * a.delete([c, b, d]) // true
 * a.delete([c]) // false
 * a.delete([c, d, b]) // false
 *
 * a.has([b, c]) // true
 * a.has([c, b]) // true
 * a.has([b]) // false
 * a.has([c, b, d]) // false
 * a.has([c]) // false
 * a.has([c, d, b]) // false
 *
 * a = new MultiKeyWeakMap([
 *   [[b, c], 1],
 *   [[c, b], 2],
 *   [[b], 3],
 *   [[c, b, d], 4]])
 * a.get([b, c]) // 1
 * a.get([c, b]) // 2
 * a.get([b]) // 3
 * a.get([c, b, d]) // 4
 * a.get([c]) // undefined
 * a.get([c, d, b]) // undefined
 */
class MultiKeyWeakMap extends WeakMap {
  /**
   * @desc
   * The constructor function of the {@link MultiKeyWeakMap} class.
   *
   * @param {object} iterable
   * An iterable object of which elements are arrays of [keys, value] pairs.
   * Each `keys` is an array of keys.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (...args) {
    super();
    const iterable = args[0];
    if (iterable !== undefined && iterable !== null) {
      for (const [keys, value] of iterable) {
        this.set(keys, value);
      }
    }
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#delete} removes any value associated to the
   * `keys` from `this` weak map.
   *
   * @param {object[]} keys
   *
   * @return {boolean}
   * `true` if a value is successfully removed, and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  delete (keys) {
    if (keys.length === 0) {
      return _value.delete(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return false
    }
    return child.delete(keys.slice(1))
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#get} returns the value associated to the `keys`
   * if exist in `this` weak map, or `undefined` otherwise.
   *
   * @param {object[]} keys
   *
   * @return {object|undefined}
   * The value associated to the `keys` if exist, or `undefined.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get (keys) {
    if (keys.length === 0) {
      return _value.get(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return undefined
    }
    return child.get(keys.slice(1))
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#has} returns `true` if a value is associated to
   * the `keys` in `this` weak map, or `false` otherwise.
   *
   * @param {object[]} keys
   *
   * @return {boolean}
   * `true` if a value is associated to the `keys`, or `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  has (keys) {
    if (keys.length === 0) {
      return _value.has(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return false
    }
    return child.has(keys.slice(1))
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#set} sets the `value` for the `keys` in `this`
   * weak map.
   *
   * @param {object[]} keys
   * @param {Any} value
   *
   * @return {MultiKeyWeakMap}
   * `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  set (keys, value) {
    if (keys.length === 0) {
      _value.set(this, value);
      return this
    }
    const key0 = keys[0];
    let child = super.get(key0);
    if (!child) {
      child = new MultiKeyWeakMap();
      super.set(key0, child);
    }
    child.set(keys.slice(1), value);
    return this
  }
}

Object.defineProperty(
  MultiKeyWeakMap.prototype,
  Symbol.toStringTag,
  {
    value: 'MultiKeyWeakMap',
    writable: false,
    enumerable: false,
    configurable: true
  }
);

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/unicode-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @desc
 * this script contains data extracted from the Unicode&reg; Character
 * Database (CaseFolding.txt) by using an auxiliary script
 * (extractFullCaseFoldMapping.mjs).
 *
 * See NOTICE and LICENSE_UNICODE for more detail.
 *
 * Unicode is a registered trademark of Unicode, Inc. in the United States
 * and other countries.
 */

const map = new Map([
  ['\u{0041}', '\u{0061}'],
  ['\u{0042}', '\u{0062}'],
  ['\u{0043}', '\u{0063}'],
  ['\u{0044}', '\u{0064}'],
  ['\u{0045}', '\u{0065}'],
  ['\u{0046}', '\u{0066}'],
  ['\u{0047}', '\u{0067}'],
  ['\u{0048}', '\u{0068}'],
  ['\u{0049}', '\u{0069}'],
  ['\u{004A}', '\u{006A}'],
  ['\u{004B}', '\u{006B}'],
  ['\u{004C}', '\u{006C}'],
  ['\u{004D}', '\u{006D}'],
  ['\u{004E}', '\u{006E}'],
  ['\u{004F}', '\u{006F}'],
  ['\u{0050}', '\u{0070}'],
  ['\u{0051}', '\u{0071}'],
  ['\u{0052}', '\u{0072}'],
  ['\u{0053}', '\u{0073}'],
  ['\u{0054}', '\u{0074}'],
  ['\u{0055}', '\u{0075}'],
  ['\u{0056}', '\u{0076}'],
  ['\u{0057}', '\u{0077}'],
  ['\u{0058}', '\u{0078}'],
  ['\u{0059}', '\u{0079}'],
  ['\u{005A}', '\u{007A}'],
  ['\u{00B5}', '\u{03BC}'],
  ['\u{00C0}', '\u{00E0}'],
  ['\u{00C1}', '\u{00E1}'],
  ['\u{00C2}', '\u{00E2}'],
  ['\u{00C3}', '\u{00E3}'],
  ['\u{00C4}', '\u{00E4}'],
  ['\u{00C5}', '\u{00E5}'],
  ['\u{00C6}', '\u{00E6}'],
  ['\u{00C7}', '\u{00E7}'],
  ['\u{00C8}', '\u{00E8}'],
  ['\u{00C9}', '\u{00E9}'],
  ['\u{00CA}', '\u{00EA}'],
  ['\u{00CB}', '\u{00EB}'],
  ['\u{00CC}', '\u{00EC}'],
  ['\u{00CD}', '\u{00ED}'],
  ['\u{00CE}', '\u{00EE}'],
  ['\u{00CF}', '\u{00EF}'],
  ['\u{00D0}', '\u{00F0}'],
  ['\u{00D1}', '\u{00F1}'],
  ['\u{00D2}', '\u{00F2}'],
  ['\u{00D3}', '\u{00F3}'],
  ['\u{00D4}', '\u{00F4}'],
  ['\u{00D5}', '\u{00F5}'],
  ['\u{00D6}', '\u{00F6}'],
  ['\u{00D8}', '\u{00F8}'],
  ['\u{00D9}', '\u{00F9}'],
  ['\u{00DA}', '\u{00FA}'],
  ['\u{00DB}', '\u{00FB}'],
  ['\u{00DC}', '\u{00FC}'],
  ['\u{00DD}', '\u{00FD}'],
  ['\u{00DE}', '\u{00FE}'],
  ['\u{00DF}', '\u{0073}\u{0073}'],
  ['\u{0100}', '\u{0101}'],
  ['\u{0102}', '\u{0103}'],
  ['\u{0104}', '\u{0105}'],
  ['\u{0106}', '\u{0107}'],
  ['\u{0108}', '\u{0109}'],
  ['\u{010A}', '\u{010B}'],
  ['\u{010C}', '\u{010D}'],
  ['\u{010E}', '\u{010F}'],
  ['\u{0110}', '\u{0111}'],
  ['\u{0112}', '\u{0113}'],
  ['\u{0114}', '\u{0115}'],
  ['\u{0116}', '\u{0117}'],
  ['\u{0118}', '\u{0119}'],
  ['\u{011A}', '\u{011B}'],
  ['\u{011C}', '\u{011D}'],
  ['\u{011E}', '\u{011F}'],
  ['\u{0120}', '\u{0121}'],
  ['\u{0122}', '\u{0123}'],
  ['\u{0124}', '\u{0125}'],
  ['\u{0126}', '\u{0127}'],
  ['\u{0128}', '\u{0129}'],
  ['\u{012A}', '\u{012B}'],
  ['\u{012C}', '\u{012D}'],
  ['\u{012E}', '\u{012F}'],
  ['\u{0130}', '\u{0069}\u{0307}'],
  ['\u{0132}', '\u{0133}'],
  ['\u{0134}', '\u{0135}'],
  ['\u{0136}', '\u{0137}'],
  ['\u{0139}', '\u{013A}'],
  ['\u{013B}', '\u{013C}'],
  ['\u{013D}', '\u{013E}'],
  ['\u{013F}', '\u{0140}'],
  ['\u{0141}', '\u{0142}'],
  ['\u{0143}', '\u{0144}'],
  ['\u{0145}', '\u{0146}'],
  ['\u{0147}', '\u{0148}'],
  ['\u{0149}', '\u{02BC}\u{006E}'],
  ['\u{014A}', '\u{014B}'],
  ['\u{014C}', '\u{014D}'],
  ['\u{014E}', '\u{014F}'],
  ['\u{0150}', '\u{0151}'],
  ['\u{0152}', '\u{0153}'],
  ['\u{0154}', '\u{0155}'],
  ['\u{0156}', '\u{0157}'],
  ['\u{0158}', '\u{0159}'],
  ['\u{015A}', '\u{015B}'],
  ['\u{015C}', '\u{015D}'],
  ['\u{015E}', '\u{015F}'],
  ['\u{0160}', '\u{0161}'],
  ['\u{0162}', '\u{0163}'],
  ['\u{0164}', '\u{0165}'],
  ['\u{0166}', '\u{0167}'],
  ['\u{0168}', '\u{0169}'],
  ['\u{016A}', '\u{016B}'],
  ['\u{016C}', '\u{016D}'],
  ['\u{016E}', '\u{016F}'],
  ['\u{0170}', '\u{0171}'],
  ['\u{0172}', '\u{0173}'],
  ['\u{0174}', '\u{0175}'],
  ['\u{0176}', '\u{0177}'],
  ['\u{0178}', '\u{00FF}'],
  ['\u{0179}', '\u{017A}'],
  ['\u{017B}', '\u{017C}'],
  ['\u{017D}', '\u{017E}'],
  ['\u{017F}', '\u{0073}'],
  ['\u{0181}', '\u{0253}'],
  ['\u{0182}', '\u{0183}'],
  ['\u{0184}', '\u{0185}'],
  ['\u{0186}', '\u{0254}'],
  ['\u{0187}', '\u{0188}'],
  ['\u{0189}', '\u{0256}'],
  ['\u{018A}', '\u{0257}'],
  ['\u{018B}', '\u{018C}'],
  ['\u{018E}', '\u{01DD}'],
  ['\u{018F}', '\u{0259}'],
  ['\u{0190}', '\u{025B}'],
  ['\u{0191}', '\u{0192}'],
  ['\u{0193}', '\u{0260}'],
  ['\u{0194}', '\u{0263}'],
  ['\u{0196}', '\u{0269}'],
  ['\u{0197}', '\u{0268}'],
  ['\u{0198}', '\u{0199}'],
  ['\u{019C}', '\u{026F}'],
  ['\u{019D}', '\u{0272}'],
  ['\u{019F}', '\u{0275}'],
  ['\u{01A0}', '\u{01A1}'],
  ['\u{01A2}', '\u{01A3}'],
  ['\u{01A4}', '\u{01A5}'],
  ['\u{01A6}', '\u{0280}'],
  ['\u{01A7}', '\u{01A8}'],
  ['\u{01A9}', '\u{0283}'],
  ['\u{01AC}', '\u{01AD}'],
  ['\u{01AE}', '\u{0288}'],
  ['\u{01AF}', '\u{01B0}'],
  ['\u{01B1}', '\u{028A}'],
  ['\u{01B2}', '\u{028B}'],
  ['\u{01B3}', '\u{01B4}'],
  ['\u{01B5}', '\u{01B6}'],
  ['\u{01B7}', '\u{0292}'],
  ['\u{01B8}', '\u{01B9}'],
  ['\u{01BC}', '\u{01BD}'],
  ['\u{01C4}', '\u{01C6}'],
  ['\u{01C5}', '\u{01C6}'],
  ['\u{01C7}', '\u{01C9}'],
  ['\u{01C8}', '\u{01C9}'],
  ['\u{01CA}', '\u{01CC}'],
  ['\u{01CB}', '\u{01CC}'],
  ['\u{01CD}', '\u{01CE}'],
  ['\u{01CF}', '\u{01D0}'],
  ['\u{01D1}', '\u{01D2}'],
  ['\u{01D3}', '\u{01D4}'],
  ['\u{01D5}', '\u{01D6}'],
  ['\u{01D7}', '\u{01D8}'],
  ['\u{01D9}', '\u{01DA}'],
  ['\u{01DB}', '\u{01DC}'],
  ['\u{01DE}', '\u{01DF}'],
  ['\u{01E0}', '\u{01E1}'],
  ['\u{01E2}', '\u{01E3}'],
  ['\u{01E4}', '\u{01E5}'],
  ['\u{01E6}', '\u{01E7}'],
  ['\u{01E8}', '\u{01E9}'],
  ['\u{01EA}', '\u{01EB}'],
  ['\u{01EC}', '\u{01ED}'],
  ['\u{01EE}', '\u{01EF}'],
  ['\u{01F0}', '\u{006A}\u{030C}'],
  ['\u{01F1}', '\u{01F3}'],
  ['\u{01F2}', '\u{01F3}'],
  ['\u{01F4}', '\u{01F5}'],
  ['\u{01F6}', '\u{0195}'],
  ['\u{01F7}', '\u{01BF}'],
  ['\u{01F8}', '\u{01F9}'],
  ['\u{01FA}', '\u{01FB}'],
  ['\u{01FC}', '\u{01FD}'],
  ['\u{01FE}', '\u{01FF}'],
  ['\u{0200}', '\u{0201}'],
  ['\u{0202}', '\u{0203}'],
  ['\u{0204}', '\u{0205}'],
  ['\u{0206}', '\u{0207}'],
  ['\u{0208}', '\u{0209}'],
  ['\u{020A}', '\u{020B}'],
  ['\u{020C}', '\u{020D}'],
  ['\u{020E}', '\u{020F}'],
  ['\u{0210}', '\u{0211}'],
  ['\u{0212}', '\u{0213}'],
  ['\u{0214}', '\u{0215}'],
  ['\u{0216}', '\u{0217}'],
  ['\u{0218}', '\u{0219}'],
  ['\u{021A}', '\u{021B}'],
  ['\u{021C}', '\u{021D}'],
  ['\u{021E}', '\u{021F}'],
  ['\u{0220}', '\u{019E}'],
  ['\u{0222}', '\u{0223}'],
  ['\u{0224}', '\u{0225}'],
  ['\u{0226}', '\u{0227}'],
  ['\u{0228}', '\u{0229}'],
  ['\u{022A}', '\u{022B}'],
  ['\u{022C}', '\u{022D}'],
  ['\u{022E}', '\u{022F}'],
  ['\u{0230}', '\u{0231}'],
  ['\u{0232}', '\u{0233}'],
  ['\u{023A}', '\u{2C65}'],
  ['\u{023B}', '\u{023C}'],
  ['\u{023D}', '\u{019A}'],
  ['\u{023E}', '\u{2C66}'],
  ['\u{0241}', '\u{0242}'],
  ['\u{0243}', '\u{0180}'],
  ['\u{0244}', '\u{0289}'],
  ['\u{0245}', '\u{028C}'],
  ['\u{0246}', '\u{0247}'],
  ['\u{0248}', '\u{0249}'],
  ['\u{024A}', '\u{024B}'],
  ['\u{024C}', '\u{024D}'],
  ['\u{024E}', '\u{024F}'],
  ['\u{0345}', '\u{03B9}'],
  ['\u{0370}', '\u{0371}'],
  ['\u{0372}', '\u{0373}'],
  ['\u{0376}', '\u{0377}'],
  ['\u{037F}', '\u{03F3}'],
  ['\u{0386}', '\u{03AC}'],
  ['\u{0388}', '\u{03AD}'],
  ['\u{0389}', '\u{03AE}'],
  ['\u{038A}', '\u{03AF}'],
  ['\u{038C}', '\u{03CC}'],
  ['\u{038E}', '\u{03CD}'],
  ['\u{038F}', '\u{03CE}'],
  ['\u{0390}', '\u{03B9}\u{0308}\u{0301}'],
  ['\u{0391}', '\u{03B1}'],
  ['\u{0392}', '\u{03B2}'],
  ['\u{0393}', '\u{03B3}'],
  ['\u{0394}', '\u{03B4}'],
  ['\u{0395}', '\u{03B5}'],
  ['\u{0396}', '\u{03B6}'],
  ['\u{0397}', '\u{03B7}'],
  ['\u{0398}', '\u{03B8}'],
  ['\u{0399}', '\u{03B9}'],
  ['\u{039A}', '\u{03BA}'],
  ['\u{039B}', '\u{03BB}'],
  ['\u{039C}', '\u{03BC}'],
  ['\u{039D}', '\u{03BD}'],
  ['\u{039E}', '\u{03BE}'],
  ['\u{039F}', '\u{03BF}'],
  ['\u{03A0}', '\u{03C0}'],
  ['\u{03A1}', '\u{03C1}'],
  ['\u{03A3}', '\u{03C3}'],
  ['\u{03A4}', '\u{03C4}'],
  ['\u{03A5}', '\u{03C5}'],
  ['\u{03A6}', '\u{03C6}'],
  ['\u{03A7}', '\u{03C7}'],
  ['\u{03A8}', '\u{03C8}'],
  ['\u{03A9}', '\u{03C9}'],
  ['\u{03AA}', '\u{03CA}'],
  ['\u{03AB}', '\u{03CB}'],
  ['\u{03B0}', '\u{03C5}\u{0308}\u{0301}'],
  ['\u{03C2}', '\u{03C3}'],
  ['\u{03CF}', '\u{03D7}'],
  ['\u{03D0}', '\u{03B2}'],
  ['\u{03D1}', '\u{03B8}'],
  ['\u{03D5}', '\u{03C6}'],
  ['\u{03D6}', '\u{03C0}'],
  ['\u{03D8}', '\u{03D9}'],
  ['\u{03DA}', '\u{03DB}'],
  ['\u{03DC}', '\u{03DD}'],
  ['\u{03DE}', '\u{03DF}'],
  ['\u{03E0}', '\u{03E1}'],
  ['\u{03E2}', '\u{03E3}'],
  ['\u{03E4}', '\u{03E5}'],
  ['\u{03E6}', '\u{03E7}'],
  ['\u{03E8}', '\u{03E9}'],
  ['\u{03EA}', '\u{03EB}'],
  ['\u{03EC}', '\u{03ED}'],
  ['\u{03EE}', '\u{03EF}'],
  ['\u{03F0}', '\u{03BA}'],
  ['\u{03F1}', '\u{03C1}'],
  ['\u{03F4}', '\u{03B8}'],
  ['\u{03F5}', '\u{03B5}'],
  ['\u{03F7}', '\u{03F8}'],
  ['\u{03F9}', '\u{03F2}'],
  ['\u{03FA}', '\u{03FB}'],
  ['\u{03FD}', '\u{037B}'],
  ['\u{03FE}', '\u{037C}'],
  ['\u{03FF}', '\u{037D}'],
  ['\u{0400}', '\u{0450}'],
  ['\u{0401}', '\u{0451}'],
  ['\u{0402}', '\u{0452}'],
  ['\u{0403}', '\u{0453}'],
  ['\u{0404}', '\u{0454}'],
  ['\u{0405}', '\u{0455}'],
  ['\u{0406}', '\u{0456}'],
  ['\u{0407}', '\u{0457}'],
  ['\u{0408}', '\u{0458}'],
  ['\u{0409}', '\u{0459}'],
  ['\u{040A}', '\u{045A}'],
  ['\u{040B}', '\u{045B}'],
  ['\u{040C}', '\u{045C}'],
  ['\u{040D}', '\u{045D}'],
  ['\u{040E}', '\u{045E}'],
  ['\u{040F}', '\u{045F}'],
  ['\u{0410}', '\u{0430}'],
  ['\u{0411}', '\u{0431}'],
  ['\u{0412}', '\u{0432}'],
  ['\u{0413}', '\u{0433}'],
  ['\u{0414}', '\u{0434}'],
  ['\u{0415}', '\u{0435}'],
  ['\u{0416}', '\u{0436}'],
  ['\u{0417}', '\u{0437}'],
  ['\u{0418}', '\u{0438}'],
  ['\u{0419}', '\u{0439}'],
  ['\u{041A}', '\u{043A}'],
  ['\u{041B}', '\u{043B}'],
  ['\u{041C}', '\u{043C}'],
  ['\u{041D}', '\u{043D}'],
  ['\u{041E}', '\u{043E}'],
  ['\u{041F}', '\u{043F}'],
  ['\u{0420}', '\u{0440}'],
  ['\u{0421}', '\u{0441}'],
  ['\u{0422}', '\u{0442}'],
  ['\u{0423}', '\u{0443}'],
  ['\u{0424}', '\u{0444}'],
  ['\u{0425}', '\u{0445}'],
  ['\u{0426}', '\u{0446}'],
  ['\u{0427}', '\u{0447}'],
  ['\u{0428}', '\u{0448}'],
  ['\u{0429}', '\u{0449}'],
  ['\u{042A}', '\u{044A}'],
  ['\u{042B}', '\u{044B}'],
  ['\u{042C}', '\u{044C}'],
  ['\u{042D}', '\u{044D}'],
  ['\u{042E}', '\u{044E}'],
  ['\u{042F}', '\u{044F}'],
  ['\u{0460}', '\u{0461}'],
  ['\u{0462}', '\u{0463}'],
  ['\u{0464}', '\u{0465}'],
  ['\u{0466}', '\u{0467}'],
  ['\u{0468}', '\u{0469}'],
  ['\u{046A}', '\u{046B}'],
  ['\u{046C}', '\u{046D}'],
  ['\u{046E}', '\u{046F}'],
  ['\u{0470}', '\u{0471}'],
  ['\u{0472}', '\u{0473}'],
  ['\u{0474}', '\u{0475}'],
  ['\u{0476}', '\u{0477}'],
  ['\u{0478}', '\u{0479}'],
  ['\u{047A}', '\u{047B}'],
  ['\u{047C}', '\u{047D}'],
  ['\u{047E}', '\u{047F}'],
  ['\u{0480}', '\u{0481}'],
  ['\u{048A}', '\u{048B}'],
  ['\u{048C}', '\u{048D}'],
  ['\u{048E}', '\u{048F}'],
  ['\u{0490}', '\u{0491}'],
  ['\u{0492}', '\u{0493}'],
  ['\u{0494}', '\u{0495}'],
  ['\u{0496}', '\u{0497}'],
  ['\u{0498}', '\u{0499}'],
  ['\u{049A}', '\u{049B}'],
  ['\u{049C}', '\u{049D}'],
  ['\u{049E}', '\u{049F}'],
  ['\u{04A0}', '\u{04A1}'],
  ['\u{04A2}', '\u{04A3}'],
  ['\u{04A4}', '\u{04A5}'],
  ['\u{04A6}', '\u{04A7}'],
  ['\u{04A8}', '\u{04A9}'],
  ['\u{04AA}', '\u{04AB}'],
  ['\u{04AC}', '\u{04AD}'],
  ['\u{04AE}', '\u{04AF}'],
  ['\u{04B0}', '\u{04B1}'],
  ['\u{04B2}', '\u{04B3}'],
  ['\u{04B4}', '\u{04B5}'],
  ['\u{04B6}', '\u{04B7}'],
  ['\u{04B8}', '\u{04B9}'],
  ['\u{04BA}', '\u{04BB}'],
  ['\u{04BC}', '\u{04BD}'],
  ['\u{04BE}', '\u{04BF}'],
  ['\u{04C0}', '\u{04CF}'],
  ['\u{04C1}', '\u{04C2}'],
  ['\u{04C3}', '\u{04C4}'],
  ['\u{04C5}', '\u{04C6}'],
  ['\u{04C7}', '\u{04C8}'],
  ['\u{04C9}', '\u{04CA}'],
  ['\u{04CB}', '\u{04CC}'],
  ['\u{04CD}', '\u{04CE}'],
  ['\u{04D0}', '\u{04D1}'],
  ['\u{04D2}', '\u{04D3}'],
  ['\u{04D4}', '\u{04D5}'],
  ['\u{04D6}', '\u{04D7}'],
  ['\u{04D8}', '\u{04D9}'],
  ['\u{04DA}', '\u{04DB}'],
  ['\u{04DC}', '\u{04DD}'],
  ['\u{04DE}', '\u{04DF}'],
  ['\u{04E0}', '\u{04E1}'],
  ['\u{04E2}', '\u{04E3}'],
  ['\u{04E4}', '\u{04E5}'],
  ['\u{04E6}', '\u{04E7}'],
  ['\u{04E8}', '\u{04E9}'],
  ['\u{04EA}', '\u{04EB}'],
  ['\u{04EC}', '\u{04ED}'],
  ['\u{04EE}', '\u{04EF}'],
  ['\u{04F0}', '\u{04F1}'],
  ['\u{04F2}', '\u{04F3}'],
  ['\u{04F4}', '\u{04F5}'],
  ['\u{04F6}', '\u{04F7}'],
  ['\u{04F8}', '\u{04F9}'],
  ['\u{04FA}', '\u{04FB}'],
  ['\u{04FC}', '\u{04FD}'],
  ['\u{04FE}', '\u{04FF}'],
  ['\u{0500}', '\u{0501}'],
  ['\u{0502}', '\u{0503}'],
  ['\u{0504}', '\u{0505}'],
  ['\u{0506}', '\u{0507}'],
  ['\u{0508}', '\u{0509}'],
  ['\u{050A}', '\u{050B}'],
  ['\u{050C}', '\u{050D}'],
  ['\u{050E}', '\u{050F}'],
  ['\u{0510}', '\u{0511}'],
  ['\u{0512}', '\u{0513}'],
  ['\u{0514}', '\u{0515}'],
  ['\u{0516}', '\u{0517}'],
  ['\u{0518}', '\u{0519}'],
  ['\u{051A}', '\u{051B}'],
  ['\u{051C}', '\u{051D}'],
  ['\u{051E}', '\u{051F}'],
  ['\u{0520}', '\u{0521}'],
  ['\u{0522}', '\u{0523}'],
  ['\u{0524}', '\u{0525}'],
  ['\u{0526}', '\u{0527}'],
  ['\u{0528}', '\u{0529}'],
  ['\u{052A}', '\u{052B}'],
  ['\u{052C}', '\u{052D}'],
  ['\u{052E}', '\u{052F}'],
  ['\u{0531}', '\u{0561}'],
  ['\u{0532}', '\u{0562}'],
  ['\u{0533}', '\u{0563}'],
  ['\u{0534}', '\u{0564}'],
  ['\u{0535}', '\u{0565}'],
  ['\u{0536}', '\u{0566}'],
  ['\u{0537}', '\u{0567}'],
  ['\u{0538}', '\u{0568}'],
  ['\u{0539}', '\u{0569}'],
  ['\u{053A}', '\u{056A}'],
  ['\u{053B}', '\u{056B}'],
  ['\u{053C}', '\u{056C}'],
  ['\u{053D}', '\u{056D}'],
  ['\u{053E}', '\u{056E}'],
  ['\u{053F}', '\u{056F}'],
  ['\u{0540}', '\u{0570}'],
  ['\u{0541}', '\u{0571}'],
  ['\u{0542}', '\u{0572}'],
  ['\u{0543}', '\u{0573}'],
  ['\u{0544}', '\u{0574}'],
  ['\u{0545}', '\u{0575}'],
  ['\u{0546}', '\u{0576}'],
  ['\u{0547}', '\u{0577}'],
  ['\u{0548}', '\u{0578}'],
  ['\u{0549}', '\u{0579}'],
  ['\u{054A}', '\u{057A}'],
  ['\u{054B}', '\u{057B}'],
  ['\u{054C}', '\u{057C}'],
  ['\u{054D}', '\u{057D}'],
  ['\u{054E}', '\u{057E}'],
  ['\u{054F}', '\u{057F}'],
  ['\u{0550}', '\u{0580}'],
  ['\u{0551}', '\u{0581}'],
  ['\u{0552}', '\u{0582}'],
  ['\u{0553}', '\u{0583}'],
  ['\u{0554}', '\u{0584}'],
  ['\u{0555}', '\u{0585}'],
  ['\u{0556}', '\u{0586}'],
  ['\u{0587}', '\u{0565}\u{0582}'],
  ['\u{10A0}', '\u{2D00}'],
  ['\u{10A1}', '\u{2D01}'],
  ['\u{10A2}', '\u{2D02}'],
  ['\u{10A3}', '\u{2D03}'],
  ['\u{10A4}', '\u{2D04}'],
  ['\u{10A5}', '\u{2D05}'],
  ['\u{10A6}', '\u{2D06}'],
  ['\u{10A7}', '\u{2D07}'],
  ['\u{10A8}', '\u{2D08}'],
  ['\u{10A9}', '\u{2D09}'],
  ['\u{10AA}', '\u{2D0A}'],
  ['\u{10AB}', '\u{2D0B}'],
  ['\u{10AC}', '\u{2D0C}'],
  ['\u{10AD}', '\u{2D0D}'],
  ['\u{10AE}', '\u{2D0E}'],
  ['\u{10AF}', '\u{2D0F}'],
  ['\u{10B0}', '\u{2D10}'],
  ['\u{10B1}', '\u{2D11}'],
  ['\u{10B2}', '\u{2D12}'],
  ['\u{10B3}', '\u{2D13}'],
  ['\u{10B4}', '\u{2D14}'],
  ['\u{10B5}', '\u{2D15}'],
  ['\u{10B6}', '\u{2D16}'],
  ['\u{10B7}', '\u{2D17}'],
  ['\u{10B8}', '\u{2D18}'],
  ['\u{10B9}', '\u{2D19}'],
  ['\u{10BA}', '\u{2D1A}'],
  ['\u{10BB}', '\u{2D1B}'],
  ['\u{10BC}', '\u{2D1C}'],
  ['\u{10BD}', '\u{2D1D}'],
  ['\u{10BE}', '\u{2D1E}'],
  ['\u{10BF}', '\u{2D1F}'],
  ['\u{10C0}', '\u{2D20}'],
  ['\u{10C1}', '\u{2D21}'],
  ['\u{10C2}', '\u{2D22}'],
  ['\u{10C3}', '\u{2D23}'],
  ['\u{10C4}', '\u{2D24}'],
  ['\u{10C5}', '\u{2D25}'],
  ['\u{10C7}', '\u{2D27}'],
  ['\u{10CD}', '\u{2D2D}'],
  ['\u{13F8}', '\u{13F0}'],
  ['\u{13F9}', '\u{13F1}'],
  ['\u{13FA}', '\u{13F2}'],
  ['\u{13FB}', '\u{13F3}'],
  ['\u{13FC}', '\u{13F4}'],
  ['\u{13FD}', '\u{13F5}'],
  ['\u{1C80}', '\u{0432}'],
  ['\u{1C81}', '\u{0434}'],
  ['\u{1C82}', '\u{043E}'],
  ['\u{1C83}', '\u{0441}'],
  ['\u{1C84}', '\u{0442}'],
  ['\u{1C85}', '\u{0442}'],
  ['\u{1C86}', '\u{044A}'],
  ['\u{1C87}', '\u{0463}'],
  ['\u{1C88}', '\u{A64B}'],
  ['\u{1C90}', '\u{10D0}'],
  ['\u{1C91}', '\u{10D1}'],
  ['\u{1C92}', '\u{10D2}'],
  ['\u{1C93}', '\u{10D3}'],
  ['\u{1C94}', '\u{10D4}'],
  ['\u{1C95}', '\u{10D5}'],
  ['\u{1C96}', '\u{10D6}'],
  ['\u{1C97}', '\u{10D7}'],
  ['\u{1C98}', '\u{10D8}'],
  ['\u{1C99}', '\u{10D9}'],
  ['\u{1C9A}', '\u{10DA}'],
  ['\u{1C9B}', '\u{10DB}'],
  ['\u{1C9C}', '\u{10DC}'],
  ['\u{1C9D}', '\u{10DD}'],
  ['\u{1C9E}', '\u{10DE}'],
  ['\u{1C9F}', '\u{10DF}'],
  ['\u{1CA0}', '\u{10E0}'],
  ['\u{1CA1}', '\u{10E1}'],
  ['\u{1CA2}', '\u{10E2}'],
  ['\u{1CA3}', '\u{10E3}'],
  ['\u{1CA4}', '\u{10E4}'],
  ['\u{1CA5}', '\u{10E5}'],
  ['\u{1CA6}', '\u{10E6}'],
  ['\u{1CA7}', '\u{10E7}'],
  ['\u{1CA8}', '\u{10E8}'],
  ['\u{1CA9}', '\u{10E9}'],
  ['\u{1CAA}', '\u{10EA}'],
  ['\u{1CAB}', '\u{10EB}'],
  ['\u{1CAC}', '\u{10EC}'],
  ['\u{1CAD}', '\u{10ED}'],
  ['\u{1CAE}', '\u{10EE}'],
  ['\u{1CAF}', '\u{10EF}'],
  ['\u{1CB0}', '\u{10F0}'],
  ['\u{1CB1}', '\u{10F1}'],
  ['\u{1CB2}', '\u{10F2}'],
  ['\u{1CB3}', '\u{10F3}'],
  ['\u{1CB4}', '\u{10F4}'],
  ['\u{1CB5}', '\u{10F5}'],
  ['\u{1CB6}', '\u{10F6}'],
  ['\u{1CB7}', '\u{10F7}'],
  ['\u{1CB8}', '\u{10F8}'],
  ['\u{1CB9}', '\u{10F9}'],
  ['\u{1CBA}', '\u{10FA}'],
  ['\u{1CBD}', '\u{10FD}'],
  ['\u{1CBE}', '\u{10FE}'],
  ['\u{1CBF}', '\u{10FF}'],
  ['\u{1E00}', '\u{1E01}'],
  ['\u{1E02}', '\u{1E03}'],
  ['\u{1E04}', '\u{1E05}'],
  ['\u{1E06}', '\u{1E07}'],
  ['\u{1E08}', '\u{1E09}'],
  ['\u{1E0A}', '\u{1E0B}'],
  ['\u{1E0C}', '\u{1E0D}'],
  ['\u{1E0E}', '\u{1E0F}'],
  ['\u{1E10}', '\u{1E11}'],
  ['\u{1E12}', '\u{1E13}'],
  ['\u{1E14}', '\u{1E15}'],
  ['\u{1E16}', '\u{1E17}'],
  ['\u{1E18}', '\u{1E19}'],
  ['\u{1E1A}', '\u{1E1B}'],
  ['\u{1E1C}', '\u{1E1D}'],
  ['\u{1E1E}', '\u{1E1F}'],
  ['\u{1E20}', '\u{1E21}'],
  ['\u{1E22}', '\u{1E23}'],
  ['\u{1E24}', '\u{1E25}'],
  ['\u{1E26}', '\u{1E27}'],
  ['\u{1E28}', '\u{1E29}'],
  ['\u{1E2A}', '\u{1E2B}'],
  ['\u{1E2C}', '\u{1E2D}'],
  ['\u{1E2E}', '\u{1E2F}'],
  ['\u{1E30}', '\u{1E31}'],
  ['\u{1E32}', '\u{1E33}'],
  ['\u{1E34}', '\u{1E35}'],
  ['\u{1E36}', '\u{1E37}'],
  ['\u{1E38}', '\u{1E39}'],
  ['\u{1E3A}', '\u{1E3B}'],
  ['\u{1E3C}', '\u{1E3D}'],
  ['\u{1E3E}', '\u{1E3F}'],
  ['\u{1E40}', '\u{1E41}'],
  ['\u{1E42}', '\u{1E43}'],
  ['\u{1E44}', '\u{1E45}'],
  ['\u{1E46}', '\u{1E47}'],
  ['\u{1E48}', '\u{1E49}'],
  ['\u{1E4A}', '\u{1E4B}'],
  ['\u{1E4C}', '\u{1E4D}'],
  ['\u{1E4E}', '\u{1E4F}'],
  ['\u{1E50}', '\u{1E51}'],
  ['\u{1E52}', '\u{1E53}'],
  ['\u{1E54}', '\u{1E55}'],
  ['\u{1E56}', '\u{1E57}'],
  ['\u{1E58}', '\u{1E59}'],
  ['\u{1E5A}', '\u{1E5B}'],
  ['\u{1E5C}', '\u{1E5D}'],
  ['\u{1E5E}', '\u{1E5F}'],
  ['\u{1E60}', '\u{1E61}'],
  ['\u{1E62}', '\u{1E63}'],
  ['\u{1E64}', '\u{1E65}'],
  ['\u{1E66}', '\u{1E67}'],
  ['\u{1E68}', '\u{1E69}'],
  ['\u{1E6A}', '\u{1E6B}'],
  ['\u{1E6C}', '\u{1E6D}'],
  ['\u{1E6E}', '\u{1E6F}'],
  ['\u{1E70}', '\u{1E71}'],
  ['\u{1E72}', '\u{1E73}'],
  ['\u{1E74}', '\u{1E75}'],
  ['\u{1E76}', '\u{1E77}'],
  ['\u{1E78}', '\u{1E79}'],
  ['\u{1E7A}', '\u{1E7B}'],
  ['\u{1E7C}', '\u{1E7D}'],
  ['\u{1E7E}', '\u{1E7F}'],
  ['\u{1E80}', '\u{1E81}'],
  ['\u{1E82}', '\u{1E83}'],
  ['\u{1E84}', '\u{1E85}'],
  ['\u{1E86}', '\u{1E87}'],
  ['\u{1E88}', '\u{1E89}'],
  ['\u{1E8A}', '\u{1E8B}'],
  ['\u{1E8C}', '\u{1E8D}'],
  ['\u{1E8E}', '\u{1E8F}'],
  ['\u{1E90}', '\u{1E91}'],
  ['\u{1E92}', '\u{1E93}'],
  ['\u{1E94}', '\u{1E95}'],
  ['\u{1E96}', '\u{0068}\u{0331}'],
  ['\u{1E97}', '\u{0074}\u{0308}'],
  ['\u{1E98}', '\u{0077}\u{030A}'],
  ['\u{1E99}', '\u{0079}\u{030A}'],
  ['\u{1E9A}', '\u{0061}\u{02BE}'],
  ['\u{1E9B}', '\u{1E61}'],
  ['\u{1E9E}', '\u{0073}\u{0073}'],
  ['\u{1EA0}', '\u{1EA1}'],
  ['\u{1EA2}', '\u{1EA3}'],
  ['\u{1EA4}', '\u{1EA5}'],
  ['\u{1EA6}', '\u{1EA7}'],
  ['\u{1EA8}', '\u{1EA9}'],
  ['\u{1EAA}', '\u{1EAB}'],
  ['\u{1EAC}', '\u{1EAD}'],
  ['\u{1EAE}', '\u{1EAF}'],
  ['\u{1EB0}', '\u{1EB1}'],
  ['\u{1EB2}', '\u{1EB3}'],
  ['\u{1EB4}', '\u{1EB5}'],
  ['\u{1EB6}', '\u{1EB7}'],
  ['\u{1EB8}', '\u{1EB9}'],
  ['\u{1EBA}', '\u{1EBB}'],
  ['\u{1EBC}', '\u{1EBD}'],
  ['\u{1EBE}', '\u{1EBF}'],
  ['\u{1EC0}', '\u{1EC1}'],
  ['\u{1EC2}', '\u{1EC3}'],
  ['\u{1EC4}', '\u{1EC5}'],
  ['\u{1EC6}', '\u{1EC7}'],
  ['\u{1EC8}', '\u{1EC9}'],
  ['\u{1ECA}', '\u{1ECB}'],
  ['\u{1ECC}', '\u{1ECD}'],
  ['\u{1ECE}', '\u{1ECF}'],
  ['\u{1ED0}', '\u{1ED1}'],
  ['\u{1ED2}', '\u{1ED3}'],
  ['\u{1ED4}', '\u{1ED5}'],
  ['\u{1ED6}', '\u{1ED7}'],
  ['\u{1ED8}', '\u{1ED9}'],
  ['\u{1EDA}', '\u{1EDB}'],
  ['\u{1EDC}', '\u{1EDD}'],
  ['\u{1EDE}', '\u{1EDF}'],
  ['\u{1EE0}', '\u{1EE1}'],
  ['\u{1EE2}', '\u{1EE3}'],
  ['\u{1EE4}', '\u{1EE5}'],
  ['\u{1EE6}', '\u{1EE7}'],
  ['\u{1EE8}', '\u{1EE9}'],
  ['\u{1EEA}', '\u{1EEB}'],
  ['\u{1EEC}', '\u{1EED}'],
  ['\u{1EEE}', '\u{1EEF}'],
  ['\u{1EF0}', '\u{1EF1}'],
  ['\u{1EF2}', '\u{1EF3}'],
  ['\u{1EF4}', '\u{1EF5}'],
  ['\u{1EF6}', '\u{1EF7}'],
  ['\u{1EF8}', '\u{1EF9}'],
  ['\u{1EFA}', '\u{1EFB}'],
  ['\u{1EFC}', '\u{1EFD}'],
  ['\u{1EFE}', '\u{1EFF}'],
  ['\u{1F08}', '\u{1F00}'],
  ['\u{1F09}', '\u{1F01}'],
  ['\u{1F0A}', '\u{1F02}'],
  ['\u{1F0B}', '\u{1F03}'],
  ['\u{1F0C}', '\u{1F04}'],
  ['\u{1F0D}', '\u{1F05}'],
  ['\u{1F0E}', '\u{1F06}'],
  ['\u{1F0F}', '\u{1F07}'],
  ['\u{1F18}', '\u{1F10}'],
  ['\u{1F19}', '\u{1F11}'],
  ['\u{1F1A}', '\u{1F12}'],
  ['\u{1F1B}', '\u{1F13}'],
  ['\u{1F1C}', '\u{1F14}'],
  ['\u{1F1D}', '\u{1F15}'],
  ['\u{1F28}', '\u{1F20}'],
  ['\u{1F29}', '\u{1F21}'],
  ['\u{1F2A}', '\u{1F22}'],
  ['\u{1F2B}', '\u{1F23}'],
  ['\u{1F2C}', '\u{1F24}'],
  ['\u{1F2D}', '\u{1F25}'],
  ['\u{1F2E}', '\u{1F26}'],
  ['\u{1F2F}', '\u{1F27}'],
  ['\u{1F38}', '\u{1F30}'],
  ['\u{1F39}', '\u{1F31}'],
  ['\u{1F3A}', '\u{1F32}'],
  ['\u{1F3B}', '\u{1F33}'],
  ['\u{1F3C}', '\u{1F34}'],
  ['\u{1F3D}', '\u{1F35}'],
  ['\u{1F3E}', '\u{1F36}'],
  ['\u{1F3F}', '\u{1F37}'],
  ['\u{1F48}', '\u{1F40}'],
  ['\u{1F49}', '\u{1F41}'],
  ['\u{1F4A}', '\u{1F42}'],
  ['\u{1F4B}', '\u{1F43}'],
  ['\u{1F4C}', '\u{1F44}'],
  ['\u{1F4D}', '\u{1F45}'],
  ['\u{1F50}', '\u{03C5}\u{0313}'],
  ['\u{1F52}', '\u{03C5}\u{0313}\u{0300}'],
  ['\u{1F54}', '\u{03C5}\u{0313}\u{0301}'],
  ['\u{1F56}', '\u{03C5}\u{0313}\u{0342}'],
  ['\u{1F59}', '\u{1F51}'],
  ['\u{1F5B}', '\u{1F53}'],
  ['\u{1F5D}', '\u{1F55}'],
  ['\u{1F5F}', '\u{1F57}'],
  ['\u{1F68}', '\u{1F60}'],
  ['\u{1F69}', '\u{1F61}'],
  ['\u{1F6A}', '\u{1F62}'],
  ['\u{1F6B}', '\u{1F63}'],
  ['\u{1F6C}', '\u{1F64}'],
  ['\u{1F6D}', '\u{1F65}'],
  ['\u{1F6E}', '\u{1F66}'],
  ['\u{1F6F}', '\u{1F67}'],
  ['\u{1F80}', '\u{1F00}\u{03B9}'],
  ['\u{1F81}', '\u{1F01}\u{03B9}'],
  ['\u{1F82}', '\u{1F02}\u{03B9}'],
  ['\u{1F83}', '\u{1F03}\u{03B9}'],
  ['\u{1F84}', '\u{1F04}\u{03B9}'],
  ['\u{1F85}', '\u{1F05}\u{03B9}'],
  ['\u{1F86}', '\u{1F06}\u{03B9}'],
  ['\u{1F87}', '\u{1F07}\u{03B9}'],
  ['\u{1F88}', '\u{1F00}\u{03B9}'],
  ['\u{1F89}', '\u{1F01}\u{03B9}'],
  ['\u{1F8A}', '\u{1F02}\u{03B9}'],
  ['\u{1F8B}', '\u{1F03}\u{03B9}'],
  ['\u{1F8C}', '\u{1F04}\u{03B9}'],
  ['\u{1F8D}', '\u{1F05}\u{03B9}'],
  ['\u{1F8E}', '\u{1F06}\u{03B9}'],
  ['\u{1F8F}', '\u{1F07}\u{03B9}'],
  ['\u{1F90}', '\u{1F20}\u{03B9}'],
  ['\u{1F91}', '\u{1F21}\u{03B9}'],
  ['\u{1F92}', '\u{1F22}\u{03B9}'],
  ['\u{1F93}', '\u{1F23}\u{03B9}'],
  ['\u{1F94}', '\u{1F24}\u{03B9}'],
  ['\u{1F95}', '\u{1F25}\u{03B9}'],
  ['\u{1F96}', '\u{1F26}\u{03B9}'],
  ['\u{1F97}', '\u{1F27}\u{03B9}'],
  ['\u{1F98}', '\u{1F20}\u{03B9}'],
  ['\u{1F99}', '\u{1F21}\u{03B9}'],
  ['\u{1F9A}', '\u{1F22}\u{03B9}'],
  ['\u{1F9B}', '\u{1F23}\u{03B9}'],
  ['\u{1F9C}', '\u{1F24}\u{03B9}'],
  ['\u{1F9D}', '\u{1F25}\u{03B9}'],
  ['\u{1F9E}', '\u{1F26}\u{03B9}'],
  ['\u{1F9F}', '\u{1F27}\u{03B9}'],
  ['\u{1FA0}', '\u{1F60}\u{03B9}'],
  ['\u{1FA1}', '\u{1F61}\u{03B9}'],
  ['\u{1FA2}', '\u{1F62}\u{03B9}'],
  ['\u{1FA3}', '\u{1F63}\u{03B9}'],
  ['\u{1FA4}', '\u{1F64}\u{03B9}'],
  ['\u{1FA5}', '\u{1F65}\u{03B9}'],
  ['\u{1FA6}', '\u{1F66}\u{03B9}'],
  ['\u{1FA7}', '\u{1F67}\u{03B9}'],
  ['\u{1FA8}', '\u{1F60}\u{03B9}'],
  ['\u{1FA9}', '\u{1F61}\u{03B9}'],
  ['\u{1FAA}', '\u{1F62}\u{03B9}'],
  ['\u{1FAB}', '\u{1F63}\u{03B9}'],
  ['\u{1FAC}', '\u{1F64}\u{03B9}'],
  ['\u{1FAD}', '\u{1F65}\u{03B9}'],
  ['\u{1FAE}', '\u{1F66}\u{03B9}'],
  ['\u{1FAF}', '\u{1F67}\u{03B9}'],
  ['\u{1FB2}', '\u{1F70}\u{03B9}'],
  ['\u{1FB3}', '\u{03B1}\u{03B9}'],
  ['\u{1FB4}', '\u{03AC}\u{03B9}'],
  ['\u{1FB6}', '\u{03B1}\u{0342}'],
  ['\u{1FB7}', '\u{03B1}\u{0342}\u{03B9}'],
  ['\u{1FB8}', '\u{1FB0}'],
  ['\u{1FB9}', '\u{1FB1}'],
  ['\u{1FBA}', '\u{1F70}'],
  ['\u{1FBB}', '\u{1F71}'],
  ['\u{1FBC}', '\u{03B1}\u{03B9}'],
  ['\u{1FBE}', '\u{03B9}'],
  ['\u{1FC2}', '\u{1F74}\u{03B9}'],
  ['\u{1FC3}', '\u{03B7}\u{03B9}'],
  ['\u{1FC4}', '\u{03AE}\u{03B9}'],
  ['\u{1FC6}', '\u{03B7}\u{0342}'],
  ['\u{1FC7}', '\u{03B7}\u{0342}\u{03B9}'],
  ['\u{1FC8}', '\u{1F72}'],
  ['\u{1FC9}', '\u{1F73}'],
  ['\u{1FCA}', '\u{1F74}'],
  ['\u{1FCB}', '\u{1F75}'],
  ['\u{1FCC}', '\u{03B7}\u{03B9}'],
  ['\u{1FD2}', '\u{03B9}\u{0308}\u{0300}'],
  ['\u{1FD3}', '\u{03B9}\u{0308}\u{0301}'],
  ['\u{1FD6}', '\u{03B9}\u{0342}'],
  ['\u{1FD7}', '\u{03B9}\u{0308}\u{0342}'],
  ['\u{1FD8}', '\u{1FD0}'],
  ['\u{1FD9}', '\u{1FD1}'],
  ['\u{1FDA}', '\u{1F76}'],
  ['\u{1FDB}', '\u{1F77}'],
  ['\u{1FE2}', '\u{03C5}\u{0308}\u{0300}'],
  ['\u{1FE3}', '\u{03C5}\u{0308}\u{0301}'],
  ['\u{1FE4}', '\u{03C1}\u{0313}'],
  ['\u{1FE6}', '\u{03C5}\u{0342}'],
  ['\u{1FE7}', '\u{03C5}\u{0308}\u{0342}'],
  ['\u{1FE8}', '\u{1FE0}'],
  ['\u{1FE9}', '\u{1FE1}'],
  ['\u{1FEA}', '\u{1F7A}'],
  ['\u{1FEB}', '\u{1F7B}'],
  ['\u{1FEC}', '\u{1FE5}'],
  ['\u{1FF2}', '\u{1F7C}\u{03B9}'],
  ['\u{1FF3}', '\u{03C9}\u{03B9}'],
  ['\u{1FF4}', '\u{03CE}\u{03B9}'],
  ['\u{1FF6}', '\u{03C9}\u{0342}'],
  ['\u{1FF7}', '\u{03C9}\u{0342}\u{03B9}'],
  ['\u{1FF8}', '\u{1F78}'],
  ['\u{1FF9}', '\u{1F79}'],
  ['\u{1FFA}', '\u{1F7C}'],
  ['\u{1FFB}', '\u{1F7D}'],
  ['\u{1FFC}', '\u{03C9}\u{03B9}'],
  ['\u{2126}', '\u{03C9}'],
  ['\u{212A}', '\u{006B}'],
  ['\u{212B}', '\u{00E5}'],
  ['\u{2132}', '\u{214E}'],
  ['\u{2160}', '\u{2170}'],
  ['\u{2161}', '\u{2171}'],
  ['\u{2162}', '\u{2172}'],
  ['\u{2163}', '\u{2173}'],
  ['\u{2164}', '\u{2174}'],
  ['\u{2165}', '\u{2175}'],
  ['\u{2166}', '\u{2176}'],
  ['\u{2167}', '\u{2177}'],
  ['\u{2168}', '\u{2178}'],
  ['\u{2169}', '\u{2179}'],
  ['\u{216A}', '\u{217A}'],
  ['\u{216B}', '\u{217B}'],
  ['\u{216C}', '\u{217C}'],
  ['\u{216D}', '\u{217D}'],
  ['\u{216E}', '\u{217E}'],
  ['\u{216F}', '\u{217F}'],
  ['\u{2183}', '\u{2184}'],
  ['\u{24B6}', '\u{24D0}'],
  ['\u{24B7}', '\u{24D1}'],
  ['\u{24B8}', '\u{24D2}'],
  ['\u{24B9}', '\u{24D3}'],
  ['\u{24BA}', '\u{24D4}'],
  ['\u{24BB}', '\u{24D5}'],
  ['\u{24BC}', '\u{24D6}'],
  ['\u{24BD}', '\u{24D7}'],
  ['\u{24BE}', '\u{24D8}'],
  ['\u{24BF}', '\u{24D9}'],
  ['\u{24C0}', '\u{24DA}'],
  ['\u{24C1}', '\u{24DB}'],
  ['\u{24C2}', '\u{24DC}'],
  ['\u{24C3}', '\u{24DD}'],
  ['\u{24C4}', '\u{24DE}'],
  ['\u{24C5}', '\u{24DF}'],
  ['\u{24C6}', '\u{24E0}'],
  ['\u{24C7}', '\u{24E1}'],
  ['\u{24C8}', '\u{24E2}'],
  ['\u{24C9}', '\u{24E3}'],
  ['\u{24CA}', '\u{24E4}'],
  ['\u{24CB}', '\u{24E5}'],
  ['\u{24CC}', '\u{24E6}'],
  ['\u{24CD}', '\u{24E7}'],
  ['\u{24CE}', '\u{24E8}'],
  ['\u{24CF}', '\u{24E9}'],
  ['\u{2C00}', '\u{2C30}'],
  ['\u{2C01}', '\u{2C31}'],
  ['\u{2C02}', '\u{2C32}'],
  ['\u{2C03}', '\u{2C33}'],
  ['\u{2C04}', '\u{2C34}'],
  ['\u{2C05}', '\u{2C35}'],
  ['\u{2C06}', '\u{2C36}'],
  ['\u{2C07}', '\u{2C37}'],
  ['\u{2C08}', '\u{2C38}'],
  ['\u{2C09}', '\u{2C39}'],
  ['\u{2C0A}', '\u{2C3A}'],
  ['\u{2C0B}', '\u{2C3B}'],
  ['\u{2C0C}', '\u{2C3C}'],
  ['\u{2C0D}', '\u{2C3D}'],
  ['\u{2C0E}', '\u{2C3E}'],
  ['\u{2C0F}', '\u{2C3F}'],
  ['\u{2C10}', '\u{2C40}'],
  ['\u{2C11}', '\u{2C41}'],
  ['\u{2C12}', '\u{2C42}'],
  ['\u{2C13}', '\u{2C43}'],
  ['\u{2C14}', '\u{2C44}'],
  ['\u{2C15}', '\u{2C45}'],
  ['\u{2C16}', '\u{2C46}'],
  ['\u{2C17}', '\u{2C47}'],
  ['\u{2C18}', '\u{2C48}'],
  ['\u{2C19}', '\u{2C49}'],
  ['\u{2C1A}', '\u{2C4A}'],
  ['\u{2C1B}', '\u{2C4B}'],
  ['\u{2C1C}', '\u{2C4C}'],
  ['\u{2C1D}', '\u{2C4D}'],
  ['\u{2C1E}', '\u{2C4E}'],
  ['\u{2C1F}', '\u{2C4F}'],
  ['\u{2C20}', '\u{2C50}'],
  ['\u{2C21}', '\u{2C51}'],
  ['\u{2C22}', '\u{2C52}'],
  ['\u{2C23}', '\u{2C53}'],
  ['\u{2C24}', '\u{2C54}'],
  ['\u{2C25}', '\u{2C55}'],
  ['\u{2C26}', '\u{2C56}'],
  ['\u{2C27}', '\u{2C57}'],
  ['\u{2C28}', '\u{2C58}'],
  ['\u{2C29}', '\u{2C59}'],
  ['\u{2C2A}', '\u{2C5A}'],
  ['\u{2C2B}', '\u{2C5B}'],
  ['\u{2C2C}', '\u{2C5C}'],
  ['\u{2C2D}', '\u{2C5D}'],
  ['\u{2C2E}', '\u{2C5E}'],
  ['\u{2C60}', '\u{2C61}'],
  ['\u{2C62}', '\u{026B}'],
  ['\u{2C63}', '\u{1D7D}'],
  ['\u{2C64}', '\u{027D}'],
  ['\u{2C67}', '\u{2C68}'],
  ['\u{2C69}', '\u{2C6A}'],
  ['\u{2C6B}', '\u{2C6C}'],
  ['\u{2C6D}', '\u{0251}'],
  ['\u{2C6E}', '\u{0271}'],
  ['\u{2C6F}', '\u{0250}'],
  ['\u{2C70}', '\u{0252}'],
  ['\u{2C72}', '\u{2C73}'],
  ['\u{2C75}', '\u{2C76}'],
  ['\u{2C7E}', '\u{023F}'],
  ['\u{2C7F}', '\u{0240}'],
  ['\u{2C80}', '\u{2C81}'],
  ['\u{2C82}', '\u{2C83}'],
  ['\u{2C84}', '\u{2C85}'],
  ['\u{2C86}', '\u{2C87}'],
  ['\u{2C88}', '\u{2C89}'],
  ['\u{2C8A}', '\u{2C8B}'],
  ['\u{2C8C}', '\u{2C8D}'],
  ['\u{2C8E}', '\u{2C8F}'],
  ['\u{2C90}', '\u{2C91}'],
  ['\u{2C92}', '\u{2C93}'],
  ['\u{2C94}', '\u{2C95}'],
  ['\u{2C96}', '\u{2C97}'],
  ['\u{2C98}', '\u{2C99}'],
  ['\u{2C9A}', '\u{2C9B}'],
  ['\u{2C9C}', '\u{2C9D}'],
  ['\u{2C9E}', '\u{2C9F}'],
  ['\u{2CA0}', '\u{2CA1}'],
  ['\u{2CA2}', '\u{2CA3}'],
  ['\u{2CA4}', '\u{2CA5}'],
  ['\u{2CA6}', '\u{2CA7}'],
  ['\u{2CA8}', '\u{2CA9}'],
  ['\u{2CAA}', '\u{2CAB}'],
  ['\u{2CAC}', '\u{2CAD}'],
  ['\u{2CAE}', '\u{2CAF}'],
  ['\u{2CB0}', '\u{2CB1}'],
  ['\u{2CB2}', '\u{2CB3}'],
  ['\u{2CB4}', '\u{2CB5}'],
  ['\u{2CB6}', '\u{2CB7}'],
  ['\u{2CB8}', '\u{2CB9}'],
  ['\u{2CBA}', '\u{2CBB}'],
  ['\u{2CBC}', '\u{2CBD}'],
  ['\u{2CBE}', '\u{2CBF}'],
  ['\u{2CC0}', '\u{2CC1}'],
  ['\u{2CC2}', '\u{2CC3}'],
  ['\u{2CC4}', '\u{2CC5}'],
  ['\u{2CC6}', '\u{2CC7}'],
  ['\u{2CC8}', '\u{2CC9}'],
  ['\u{2CCA}', '\u{2CCB}'],
  ['\u{2CCC}', '\u{2CCD}'],
  ['\u{2CCE}', '\u{2CCF}'],
  ['\u{2CD0}', '\u{2CD1}'],
  ['\u{2CD2}', '\u{2CD3}'],
  ['\u{2CD4}', '\u{2CD5}'],
  ['\u{2CD6}', '\u{2CD7}'],
  ['\u{2CD8}', '\u{2CD9}'],
  ['\u{2CDA}', '\u{2CDB}'],
  ['\u{2CDC}', '\u{2CDD}'],
  ['\u{2CDE}', '\u{2CDF}'],
  ['\u{2CE0}', '\u{2CE1}'],
  ['\u{2CE2}', '\u{2CE3}'],
  ['\u{2CEB}', '\u{2CEC}'],
  ['\u{2CED}', '\u{2CEE}'],
  ['\u{2CF2}', '\u{2CF3}'],
  ['\u{A640}', '\u{A641}'],
  ['\u{A642}', '\u{A643}'],
  ['\u{A644}', '\u{A645}'],
  ['\u{A646}', '\u{A647}'],
  ['\u{A648}', '\u{A649}'],
  ['\u{A64A}', '\u{A64B}'],
  ['\u{A64C}', '\u{A64D}'],
  ['\u{A64E}', '\u{A64F}'],
  ['\u{A650}', '\u{A651}'],
  ['\u{A652}', '\u{A653}'],
  ['\u{A654}', '\u{A655}'],
  ['\u{A656}', '\u{A657}'],
  ['\u{A658}', '\u{A659}'],
  ['\u{A65A}', '\u{A65B}'],
  ['\u{A65C}', '\u{A65D}'],
  ['\u{A65E}', '\u{A65F}'],
  ['\u{A660}', '\u{A661}'],
  ['\u{A662}', '\u{A663}'],
  ['\u{A664}', '\u{A665}'],
  ['\u{A666}', '\u{A667}'],
  ['\u{A668}', '\u{A669}'],
  ['\u{A66A}', '\u{A66B}'],
  ['\u{A66C}', '\u{A66D}'],
  ['\u{A680}', '\u{A681}'],
  ['\u{A682}', '\u{A683}'],
  ['\u{A684}', '\u{A685}'],
  ['\u{A686}', '\u{A687}'],
  ['\u{A688}', '\u{A689}'],
  ['\u{A68A}', '\u{A68B}'],
  ['\u{A68C}', '\u{A68D}'],
  ['\u{A68E}', '\u{A68F}'],
  ['\u{A690}', '\u{A691}'],
  ['\u{A692}', '\u{A693}'],
  ['\u{A694}', '\u{A695}'],
  ['\u{A696}', '\u{A697}'],
  ['\u{A698}', '\u{A699}'],
  ['\u{A69A}', '\u{A69B}'],
  ['\u{A722}', '\u{A723}'],
  ['\u{A724}', '\u{A725}'],
  ['\u{A726}', '\u{A727}'],
  ['\u{A728}', '\u{A729}'],
  ['\u{A72A}', '\u{A72B}'],
  ['\u{A72C}', '\u{A72D}'],
  ['\u{A72E}', '\u{A72F}'],
  ['\u{A732}', '\u{A733}'],
  ['\u{A734}', '\u{A735}'],
  ['\u{A736}', '\u{A737}'],
  ['\u{A738}', '\u{A739}'],
  ['\u{A73A}', '\u{A73B}'],
  ['\u{A73C}', '\u{A73D}'],
  ['\u{A73E}', '\u{A73F}'],
  ['\u{A740}', '\u{A741}'],
  ['\u{A742}', '\u{A743}'],
  ['\u{A744}', '\u{A745}'],
  ['\u{A746}', '\u{A747}'],
  ['\u{A748}', '\u{A749}'],
  ['\u{A74A}', '\u{A74B}'],
  ['\u{A74C}', '\u{A74D}'],
  ['\u{A74E}', '\u{A74F}'],
  ['\u{A750}', '\u{A751}'],
  ['\u{A752}', '\u{A753}'],
  ['\u{A754}', '\u{A755}'],
  ['\u{A756}', '\u{A757}'],
  ['\u{A758}', '\u{A759}'],
  ['\u{A75A}', '\u{A75B}'],
  ['\u{A75C}', '\u{A75D}'],
  ['\u{A75E}', '\u{A75F}'],
  ['\u{A760}', '\u{A761}'],
  ['\u{A762}', '\u{A763}'],
  ['\u{A764}', '\u{A765}'],
  ['\u{A766}', '\u{A767}'],
  ['\u{A768}', '\u{A769}'],
  ['\u{A76A}', '\u{A76B}'],
  ['\u{A76C}', '\u{A76D}'],
  ['\u{A76E}', '\u{A76F}'],
  ['\u{A779}', '\u{A77A}'],
  ['\u{A77B}', '\u{A77C}'],
  ['\u{A77D}', '\u{1D79}'],
  ['\u{A77E}', '\u{A77F}'],
  ['\u{A780}', '\u{A781}'],
  ['\u{A782}', '\u{A783}'],
  ['\u{A784}', '\u{A785}'],
  ['\u{A786}', '\u{A787}'],
  ['\u{A78B}', '\u{A78C}'],
  ['\u{A78D}', '\u{0265}'],
  ['\u{A790}', '\u{A791}'],
  ['\u{A792}', '\u{A793}'],
  ['\u{A796}', '\u{A797}'],
  ['\u{A798}', '\u{A799}'],
  ['\u{A79A}', '\u{A79B}'],
  ['\u{A79C}', '\u{A79D}'],
  ['\u{A79E}', '\u{A79F}'],
  ['\u{A7A0}', '\u{A7A1}'],
  ['\u{A7A2}', '\u{A7A3}'],
  ['\u{A7A4}', '\u{A7A5}'],
  ['\u{A7A6}', '\u{A7A7}'],
  ['\u{A7A8}', '\u{A7A9}'],
  ['\u{A7AA}', '\u{0266}'],
  ['\u{A7AB}', '\u{025C}'],
  ['\u{A7AC}', '\u{0261}'],
  ['\u{A7AD}', '\u{026C}'],
  ['\u{A7AE}', '\u{026A}'],
  ['\u{A7B0}', '\u{029E}'],
  ['\u{A7B1}', '\u{0287}'],
  ['\u{A7B2}', '\u{029D}'],
  ['\u{A7B3}', '\u{AB53}'],
  ['\u{A7B4}', '\u{A7B5}'],
  ['\u{A7B6}', '\u{A7B7}'],
  ['\u{A7B8}', '\u{A7B9}'],
  ['\u{A7BA}', '\u{A7BB}'],
  ['\u{A7BC}', '\u{A7BD}'],
  ['\u{A7BE}', '\u{A7BF}'],
  ['\u{A7C2}', '\u{A7C3}'],
  ['\u{A7C4}', '\u{A794}'],
  ['\u{A7C5}', '\u{0282}'],
  ['\u{A7C6}', '\u{1D8E}'],
  ['\u{AB70}', '\u{13A0}'],
  ['\u{AB71}', '\u{13A1}'],
  ['\u{AB72}', '\u{13A2}'],
  ['\u{AB73}', '\u{13A3}'],
  ['\u{AB74}', '\u{13A4}'],
  ['\u{AB75}', '\u{13A5}'],
  ['\u{AB76}', '\u{13A6}'],
  ['\u{AB77}', '\u{13A7}'],
  ['\u{AB78}', '\u{13A8}'],
  ['\u{AB79}', '\u{13A9}'],
  ['\u{AB7A}', '\u{13AA}'],
  ['\u{AB7B}', '\u{13AB}'],
  ['\u{AB7C}', '\u{13AC}'],
  ['\u{AB7D}', '\u{13AD}'],
  ['\u{AB7E}', '\u{13AE}'],
  ['\u{AB7F}', '\u{13AF}'],
  ['\u{AB80}', '\u{13B0}'],
  ['\u{AB81}', '\u{13B1}'],
  ['\u{AB82}', '\u{13B2}'],
  ['\u{AB83}', '\u{13B3}'],
  ['\u{AB84}', '\u{13B4}'],
  ['\u{AB85}', '\u{13B5}'],
  ['\u{AB86}', '\u{13B6}'],
  ['\u{AB87}', '\u{13B7}'],
  ['\u{AB88}', '\u{13B8}'],
  ['\u{AB89}', '\u{13B9}'],
  ['\u{AB8A}', '\u{13BA}'],
  ['\u{AB8B}', '\u{13BB}'],
  ['\u{AB8C}', '\u{13BC}'],
  ['\u{AB8D}', '\u{13BD}'],
  ['\u{AB8E}', '\u{13BE}'],
  ['\u{AB8F}', '\u{13BF}'],
  ['\u{AB90}', '\u{13C0}'],
  ['\u{AB91}', '\u{13C1}'],
  ['\u{AB92}', '\u{13C2}'],
  ['\u{AB93}', '\u{13C3}'],
  ['\u{AB94}', '\u{13C4}'],
  ['\u{AB95}', '\u{13C5}'],
  ['\u{AB96}', '\u{13C6}'],
  ['\u{AB97}', '\u{13C7}'],
  ['\u{AB98}', '\u{13C8}'],
  ['\u{AB99}', '\u{13C9}'],
  ['\u{AB9A}', '\u{13CA}'],
  ['\u{AB9B}', '\u{13CB}'],
  ['\u{AB9C}', '\u{13CC}'],
  ['\u{AB9D}', '\u{13CD}'],
  ['\u{AB9E}', '\u{13CE}'],
  ['\u{AB9F}', '\u{13CF}'],
  ['\u{ABA0}', '\u{13D0}'],
  ['\u{ABA1}', '\u{13D1}'],
  ['\u{ABA2}', '\u{13D2}'],
  ['\u{ABA3}', '\u{13D3}'],
  ['\u{ABA4}', '\u{13D4}'],
  ['\u{ABA5}', '\u{13D5}'],
  ['\u{ABA6}', '\u{13D6}'],
  ['\u{ABA7}', '\u{13D7}'],
  ['\u{ABA8}', '\u{13D8}'],
  ['\u{ABA9}', '\u{13D9}'],
  ['\u{ABAA}', '\u{13DA}'],
  ['\u{ABAB}', '\u{13DB}'],
  ['\u{ABAC}', '\u{13DC}'],
  ['\u{ABAD}', '\u{13DD}'],
  ['\u{ABAE}', '\u{13DE}'],
  ['\u{ABAF}', '\u{13DF}'],
  ['\u{ABB0}', '\u{13E0}'],
  ['\u{ABB1}', '\u{13E1}'],
  ['\u{ABB2}', '\u{13E2}'],
  ['\u{ABB3}', '\u{13E3}'],
  ['\u{ABB4}', '\u{13E4}'],
  ['\u{ABB5}', '\u{13E5}'],
  ['\u{ABB6}', '\u{13E6}'],
  ['\u{ABB7}', '\u{13E7}'],
  ['\u{ABB8}', '\u{13E8}'],
  ['\u{ABB9}', '\u{13E9}'],
  ['\u{ABBA}', '\u{13EA}'],
  ['\u{ABBB}', '\u{13EB}'],
  ['\u{ABBC}', '\u{13EC}'],
  ['\u{ABBD}', '\u{13ED}'],
  ['\u{ABBE}', '\u{13EE}'],
  ['\u{ABBF}', '\u{13EF}'],
  ['\u{FB00}', '\u{0066}\u{0066}'],
  ['\u{FB01}', '\u{0066}\u{0069}'],
  ['\u{FB02}', '\u{0066}\u{006C}'],
  ['\u{FB03}', '\u{0066}\u{0066}\u{0069}'],
  ['\u{FB04}', '\u{0066}\u{0066}\u{006C}'],
  ['\u{FB05}', '\u{0073}\u{0074}'],
  ['\u{FB06}', '\u{0073}\u{0074}'],
  ['\u{FB13}', '\u{0574}\u{0576}'],
  ['\u{FB14}', '\u{0574}\u{0565}'],
  ['\u{FB15}', '\u{0574}\u{056B}'],
  ['\u{FB16}', '\u{057E}\u{0576}'],
  ['\u{FB17}', '\u{0574}\u{056D}'],
  ['\u{FF21}', '\u{FF41}'],
  ['\u{FF22}', '\u{FF42}'],
  ['\u{FF23}', '\u{FF43}'],
  ['\u{FF24}', '\u{FF44}'],
  ['\u{FF25}', '\u{FF45}'],
  ['\u{FF26}', '\u{FF46}'],
  ['\u{FF27}', '\u{FF47}'],
  ['\u{FF28}', '\u{FF48}'],
  ['\u{FF29}', '\u{FF49}'],
  ['\u{FF2A}', '\u{FF4A}'],
  ['\u{FF2B}', '\u{FF4B}'],
  ['\u{FF2C}', '\u{FF4C}'],
  ['\u{FF2D}', '\u{FF4D}'],
  ['\u{FF2E}', '\u{FF4E}'],
  ['\u{FF2F}', '\u{FF4F}'],
  ['\u{FF30}', '\u{FF50}'],
  ['\u{FF31}', '\u{FF51}'],
  ['\u{FF32}', '\u{FF52}'],
  ['\u{FF33}', '\u{FF53}'],
  ['\u{FF34}', '\u{FF54}'],
  ['\u{FF35}', '\u{FF55}'],
  ['\u{FF36}', '\u{FF56}'],
  ['\u{FF37}', '\u{FF57}'],
  ['\u{FF38}', '\u{FF58}'],
  ['\u{FF39}', '\u{FF59}'],
  ['\u{FF3A}', '\u{FF5A}'],
  ['\u{10400}', '\u{10428}'],
  ['\u{10401}', '\u{10429}'],
  ['\u{10402}', '\u{1042A}'],
  ['\u{10403}', '\u{1042B}'],
  ['\u{10404}', '\u{1042C}'],
  ['\u{10405}', '\u{1042D}'],
  ['\u{10406}', '\u{1042E}'],
  ['\u{10407}', '\u{1042F}'],
  ['\u{10408}', '\u{10430}'],
  ['\u{10409}', '\u{10431}'],
  ['\u{1040A}', '\u{10432}'],
  ['\u{1040B}', '\u{10433}'],
  ['\u{1040C}', '\u{10434}'],
  ['\u{1040D}', '\u{10435}'],
  ['\u{1040E}', '\u{10436}'],
  ['\u{1040F}', '\u{10437}'],
  ['\u{10410}', '\u{10438}'],
  ['\u{10411}', '\u{10439}'],
  ['\u{10412}', '\u{1043A}'],
  ['\u{10413}', '\u{1043B}'],
  ['\u{10414}', '\u{1043C}'],
  ['\u{10415}', '\u{1043D}'],
  ['\u{10416}', '\u{1043E}'],
  ['\u{10417}', '\u{1043F}'],
  ['\u{10418}', '\u{10440}'],
  ['\u{10419}', '\u{10441}'],
  ['\u{1041A}', '\u{10442}'],
  ['\u{1041B}', '\u{10443}'],
  ['\u{1041C}', '\u{10444}'],
  ['\u{1041D}', '\u{10445}'],
  ['\u{1041E}', '\u{10446}'],
  ['\u{1041F}', '\u{10447}'],
  ['\u{10420}', '\u{10448}'],
  ['\u{10421}', '\u{10449}'],
  ['\u{10422}', '\u{1044A}'],
  ['\u{10423}', '\u{1044B}'],
  ['\u{10424}', '\u{1044C}'],
  ['\u{10425}', '\u{1044D}'],
  ['\u{10426}', '\u{1044E}'],
  ['\u{10427}', '\u{1044F}'],
  ['\u{104B0}', '\u{104D8}'],
  ['\u{104B1}', '\u{104D9}'],
  ['\u{104B2}', '\u{104DA}'],
  ['\u{104B3}', '\u{104DB}'],
  ['\u{104B4}', '\u{104DC}'],
  ['\u{104B5}', '\u{104DD}'],
  ['\u{104B6}', '\u{104DE}'],
  ['\u{104B7}', '\u{104DF}'],
  ['\u{104B8}', '\u{104E0}'],
  ['\u{104B9}', '\u{104E1}'],
  ['\u{104BA}', '\u{104E2}'],
  ['\u{104BB}', '\u{104E3}'],
  ['\u{104BC}', '\u{104E4}'],
  ['\u{104BD}', '\u{104E5}'],
  ['\u{104BE}', '\u{104E6}'],
  ['\u{104BF}', '\u{104E7}'],
  ['\u{104C0}', '\u{104E8}'],
  ['\u{104C1}', '\u{104E9}'],
  ['\u{104C2}', '\u{104EA}'],
  ['\u{104C3}', '\u{104EB}'],
  ['\u{104C4}', '\u{104EC}'],
  ['\u{104C5}', '\u{104ED}'],
  ['\u{104C6}', '\u{104EE}'],
  ['\u{104C7}', '\u{104EF}'],
  ['\u{104C8}', '\u{104F0}'],
  ['\u{104C9}', '\u{104F1}'],
  ['\u{104CA}', '\u{104F2}'],
  ['\u{104CB}', '\u{104F3}'],
  ['\u{104CC}', '\u{104F4}'],
  ['\u{104CD}', '\u{104F5}'],
  ['\u{104CE}', '\u{104F6}'],
  ['\u{104CF}', '\u{104F7}'],
  ['\u{104D0}', '\u{104F8}'],
  ['\u{104D1}', '\u{104F9}'],
  ['\u{104D2}', '\u{104FA}'],
  ['\u{104D3}', '\u{104FB}'],
  ['\u{10C80}', '\u{10CC0}'],
  ['\u{10C81}', '\u{10CC1}'],
  ['\u{10C82}', '\u{10CC2}'],
  ['\u{10C83}', '\u{10CC3}'],
  ['\u{10C84}', '\u{10CC4}'],
  ['\u{10C85}', '\u{10CC5}'],
  ['\u{10C86}', '\u{10CC6}'],
  ['\u{10C87}', '\u{10CC7}'],
  ['\u{10C88}', '\u{10CC8}'],
  ['\u{10C89}', '\u{10CC9}'],
  ['\u{10C8A}', '\u{10CCA}'],
  ['\u{10C8B}', '\u{10CCB}'],
  ['\u{10C8C}', '\u{10CCC}'],
  ['\u{10C8D}', '\u{10CCD}'],
  ['\u{10C8E}', '\u{10CCE}'],
  ['\u{10C8F}', '\u{10CCF}'],
  ['\u{10C90}', '\u{10CD0}'],
  ['\u{10C91}', '\u{10CD1}'],
  ['\u{10C92}', '\u{10CD2}'],
  ['\u{10C93}', '\u{10CD3}'],
  ['\u{10C94}', '\u{10CD4}'],
  ['\u{10C95}', '\u{10CD5}'],
  ['\u{10C96}', '\u{10CD6}'],
  ['\u{10C97}', '\u{10CD7}'],
  ['\u{10C98}', '\u{10CD8}'],
  ['\u{10C99}', '\u{10CD9}'],
  ['\u{10C9A}', '\u{10CDA}'],
  ['\u{10C9B}', '\u{10CDB}'],
  ['\u{10C9C}', '\u{10CDC}'],
  ['\u{10C9D}', '\u{10CDD}'],
  ['\u{10C9E}', '\u{10CDE}'],
  ['\u{10C9F}', '\u{10CDF}'],
  ['\u{10CA0}', '\u{10CE0}'],
  ['\u{10CA1}', '\u{10CE1}'],
  ['\u{10CA2}', '\u{10CE2}'],
  ['\u{10CA3}', '\u{10CE3}'],
  ['\u{10CA4}', '\u{10CE4}'],
  ['\u{10CA5}', '\u{10CE5}'],
  ['\u{10CA6}', '\u{10CE6}'],
  ['\u{10CA7}', '\u{10CE7}'],
  ['\u{10CA8}', '\u{10CE8}'],
  ['\u{10CA9}', '\u{10CE9}'],
  ['\u{10CAA}', '\u{10CEA}'],
  ['\u{10CAB}', '\u{10CEB}'],
  ['\u{10CAC}', '\u{10CEC}'],
  ['\u{10CAD}', '\u{10CED}'],
  ['\u{10CAE}', '\u{10CEE}'],
  ['\u{10CAF}', '\u{10CEF}'],
  ['\u{10CB0}', '\u{10CF0}'],
  ['\u{10CB1}', '\u{10CF1}'],
  ['\u{10CB2}', '\u{10CF2}'],
  ['\u{118A0}', '\u{118C0}'],
  ['\u{118A1}', '\u{118C1}'],
  ['\u{118A2}', '\u{118C2}'],
  ['\u{118A3}', '\u{118C3}'],
  ['\u{118A4}', '\u{118C4}'],
  ['\u{118A5}', '\u{118C5}'],
  ['\u{118A6}', '\u{118C6}'],
  ['\u{118A7}', '\u{118C7}'],
  ['\u{118A8}', '\u{118C8}'],
  ['\u{118A9}', '\u{118C9}'],
  ['\u{118AA}', '\u{118CA}'],
  ['\u{118AB}', '\u{118CB}'],
  ['\u{118AC}', '\u{118CC}'],
  ['\u{118AD}', '\u{118CD}'],
  ['\u{118AE}', '\u{118CE}'],
  ['\u{118AF}', '\u{118CF}'],
  ['\u{118B0}', '\u{118D0}'],
  ['\u{118B1}', '\u{118D1}'],
  ['\u{118B2}', '\u{118D2}'],
  ['\u{118B3}', '\u{118D3}'],
  ['\u{118B4}', '\u{118D4}'],
  ['\u{118B5}', '\u{118D5}'],
  ['\u{118B6}', '\u{118D6}'],
  ['\u{118B7}', '\u{118D7}'],
  ['\u{118B8}', '\u{118D8}'],
  ['\u{118B9}', '\u{118D9}'],
  ['\u{118BA}', '\u{118DA}'],
  ['\u{118BB}', '\u{118DB}'],
  ['\u{118BC}', '\u{118DC}'],
  ['\u{118BD}', '\u{118DD}'],
  ['\u{118BE}', '\u{118DE}'],
  ['\u{118BF}', '\u{118DF}'],
  ['\u{16E40}', '\u{16E60}'],
  ['\u{16E41}', '\u{16E61}'],
  ['\u{16E42}', '\u{16E62}'],
  ['\u{16E43}', '\u{16E63}'],
  ['\u{16E44}', '\u{16E64}'],
  ['\u{16E45}', '\u{16E65}'],
  ['\u{16E46}', '\u{16E66}'],
  ['\u{16E47}', '\u{16E67}'],
  ['\u{16E48}', '\u{16E68}'],
  ['\u{16E49}', '\u{16E69}'],
  ['\u{16E4A}', '\u{16E6A}'],
  ['\u{16E4B}', '\u{16E6B}'],
  ['\u{16E4C}', '\u{16E6C}'],
  ['\u{16E4D}', '\u{16E6D}'],
  ['\u{16E4E}', '\u{16E6E}'],
  ['\u{16E4F}', '\u{16E6F}'],
  ['\u{16E50}', '\u{16E70}'],
  ['\u{16E51}', '\u{16E71}'],
  ['\u{16E52}', '\u{16E72}'],
  ['\u{16E53}', '\u{16E73}'],
  ['\u{16E54}', '\u{16E74}'],
  ['\u{16E55}', '\u{16E75}'],
  ['\u{16E56}', '\u{16E76}'],
  ['\u{16E57}', '\u{16E77}'],
  ['\u{16E58}', '\u{16E78}'],
  ['\u{16E59}', '\u{16E79}'],
  ['\u{16E5A}', '\u{16E7A}'],
  ['\u{16E5B}', '\u{16E7B}'],
  ['\u{16E5C}', '\u{16E7C}'],
  ['\u{16E5D}', '\u{16E7D}'],
  ['\u{16E5E}', '\u{16E7E}'],
  ['\u{16E5F}', '\u{16E7F}'],
  ['\u{1E900}', '\u{1E922}'],
  ['\u{1E901}', '\u{1E923}'],
  ['\u{1E902}', '\u{1E924}'],
  ['\u{1E903}', '\u{1E925}'],
  ['\u{1E904}', '\u{1E926}'],
  ['\u{1E905}', '\u{1E927}'],
  ['\u{1E906}', '\u{1E928}'],
  ['\u{1E907}', '\u{1E929}'],
  ['\u{1E908}', '\u{1E92A}'],
  ['\u{1E909}', '\u{1E92B}'],
  ['\u{1E90A}', '\u{1E92C}'],
  ['\u{1E90B}', '\u{1E92D}'],
  ['\u{1E90C}', '\u{1E92E}'],
  ['\u{1E90D}', '\u{1E92F}'],
  ['\u{1E90E}', '\u{1E930}'],
  ['\u{1E90F}', '\u{1E931}'],
  ['\u{1E910}', '\u{1E932}'],
  ['\u{1E911}', '\u{1E933}'],
  ['\u{1E912}', '\u{1E934}'],
  ['\u{1E913}', '\u{1E935}'],
  ['\u{1E914}', '\u{1E936}'],
  ['\u{1E915}', '\u{1E937}'],
  ['\u{1E916}', '\u{1E938}'],
  ['\u{1E917}', '\u{1E939}'],
  ['\u{1E918}', '\u{1E93A}'],
  ['\u{1E919}', '\u{1E93B}'],
  ['\u{1E91A}', '\u{1E93C}'],
  ['\u{1E91B}', '\u{1E93D}'],
  ['\u{1E91C}', '\u{1E93E}'],
  ['\u{1E91D}', '\u{1E93F}'],
  ['\u{1E91E}', '\u{1E940}'],
  ['\u{1E91F}', '\u{1E941}'],
  ['\u{1E920}', '\u{1E942}'],
  ['\u{1E921}', '\u{1E943}']
]);

const re$1 = RegExp('[' +
  '\u{0345}\u{0041}\u{0042}\u{0043}\u{0044}\u{0045}\u{0046}\u{0047}' +
  '\u{0048}\u{0049}\u{004A}\u{004B}\u{004C}\u{004D}\u{004E}\u{004F}' +
  '\u{0050}\u{0051}\u{0052}\u{0053}\u{0054}\u{0055}\u{0056}\u{0057}' +
  '\u{0058}\u{0059}\u{005A}\u{00B5}\u{00C0}\u{00C1}\u{00C2}\u{00C3}' +
  '\u{00C4}\u{00C5}\u{00C6}\u{00C7}\u{00C8}\u{00C9}\u{00CA}\u{00CB}' +
  '\u{00CC}\u{00CD}\u{00CE}\u{00CF}\u{00D0}\u{00D1}\u{00D2}\u{00D3}' +
  '\u{00D4}\u{00D5}\u{00D6}\u{00D8}\u{00D9}\u{00DA}\u{00DB}\u{00DC}' +
  '\u{00DD}\u{00DE}\u{00DF}\u{0100}\u{0102}\u{0104}\u{0106}\u{0108}' +
  '\u{010A}\u{010C}\u{010E}\u{0110}\u{0112}\u{0114}\u{0116}\u{0118}' +
  '\u{011A}\u{011C}\u{011E}\u{0120}\u{0122}\u{0124}\u{0126}\u{0128}' +
  '\u{012A}\u{012C}\u{012E}\u{0130}\u{0132}\u{0134}\u{0136}\u{0139}' +
  '\u{013B}\u{013D}\u{013F}\u{0141}\u{0143}\u{0145}\u{0147}\u{0149}' +
  '\u{014A}\u{014C}\u{014E}\u{0150}\u{0152}\u{0154}\u{0156}\u{0158}' +
  '\u{015A}\u{015C}\u{015E}\u{0160}\u{0162}\u{0164}\u{0166}\u{0168}' +
  '\u{016A}\u{016C}\u{016E}\u{0170}\u{0172}\u{0174}\u{0176}\u{0178}' +
  '\u{0179}\u{017B}\u{017D}\u{017F}\u{0181}\u{0182}\u{0184}\u{0186}' +
  '\u{0187}\u{0189}\u{018A}\u{018B}\u{018E}\u{018F}\u{0190}\u{0191}' +
  '\u{0193}\u{0194}\u{0196}\u{0197}\u{0198}\u{019C}\u{019D}\u{019F}' +
  '\u{01A0}\u{01A2}\u{01A4}\u{01A6}\u{01A7}\u{01A9}\u{01AC}\u{01AE}' +
  '\u{01AF}\u{01B1}\u{01B2}\u{01B3}\u{01B5}\u{01B7}\u{01B8}\u{01BC}' +
  '\u{01C4}\u{01C5}\u{01C7}\u{01C8}\u{01CA}\u{01CB}\u{01CD}\u{01CF}' +
  '\u{01D1}\u{01D3}\u{01D5}\u{01D7}\u{01D9}\u{01DB}\u{01DE}\u{01E0}' +
  '\u{01E2}\u{01E4}\u{01E6}\u{01E8}\u{01EA}\u{01EC}\u{01EE}\u{01F0}' +
  '\u{01F1}\u{01F2}\u{01F4}\u{01F6}\u{01F7}\u{01F8}\u{01FA}\u{01FC}' +
  '\u{01FE}\u{0200}\u{0202}\u{0204}\u{0206}\u{0208}\u{020A}\u{020C}' +
  '\u{020E}\u{0210}\u{0212}\u{0214}\u{0216}\u{0218}\u{021A}\u{021C}' +
  '\u{021E}\u{0220}\u{0222}\u{0224}\u{0226}\u{0228}\u{022A}\u{022C}' +
  '\u{022E}\u{0230}\u{0232}\u{023A}\u{023B}\u{023D}\u{023E}\u{0241}' +
  '\u{0243}\u{0244}\u{0245}\u{0246}\u{0248}\u{024A}\u{024C}\u{024E}' +
  '\u{0370}\u{0372}\u{0376}\u{037F}\u{0386}\u{0388}\u{0389}' +
  '\u{038A}\u{038C}\u{038E}\u{038F}\u{0390}\u{0391}\u{0392}\u{0393}' +
  '\u{0394}\u{0395}\u{0396}\u{0397}\u{0398}\u{0399}\u{039A}\u{039B}' +
  '\u{039C}\u{039D}\u{039E}\u{039F}\u{03A0}\u{03A1}\u{03A3}\u{03A4}' +
  '\u{03A5}\u{03A6}\u{03A7}\u{03A8}\u{03A9}\u{03AA}\u{03AB}\u{03B0}' +
  '\u{03C2}\u{03CF}\u{03D0}\u{03D1}\u{03D5}\u{03D6}\u{03D8}\u{03DA}' +
  '\u{03DC}\u{03DE}\u{03E0}\u{03E2}\u{03E4}\u{03E6}\u{03E8}\u{03EA}' +
  '\u{03EC}\u{03EE}\u{03F0}\u{03F1}\u{03F4}\u{03F5}\u{03F7}\u{03F9}' +
  '\u{03FA}\u{03FD}\u{03FE}\u{03FF}\u{0400}\u{0401}\u{0402}\u{0403}' +
  '\u{0404}\u{0405}\u{0406}\u{0407}\u{0408}\u{0409}\u{040A}\u{040B}' +
  '\u{040C}\u{040D}\u{040E}\u{040F}\u{0410}\u{0411}\u{0412}\u{0413}' +
  '\u{0414}\u{0415}\u{0416}\u{0417}\u{0418}\u{0419}\u{041A}\u{041B}' +
  '\u{041C}\u{041D}\u{041E}\u{041F}\u{0420}\u{0421}\u{0422}\u{0423}' +
  '\u{0424}\u{0425}\u{0426}\u{0427}\u{0428}\u{0429}\u{042A}\u{042B}' +
  '\u{042C}\u{042D}\u{042E}\u{042F}\u{0460}\u{0462}\u{0464}\u{0466}' +
  '\u{0468}\u{046A}\u{046C}\u{046E}\u{0470}\u{0472}\u{0474}\u{0476}' +
  '\u{0478}\u{047A}\u{047C}\u{047E}\u{0480}\u{048A}\u{048C}\u{048E}' +
  '\u{0490}\u{0492}\u{0494}\u{0496}\u{0498}\u{049A}\u{049C}\u{049E}' +
  '\u{04A0}\u{04A2}\u{04A4}\u{04A6}\u{04A8}\u{04AA}\u{04AC}\u{04AE}' +
  '\u{04B0}\u{04B2}\u{04B4}\u{04B6}\u{04B8}\u{04BA}\u{04BC}\u{04BE}' +
  '\u{04C0}\u{04C1}\u{04C3}\u{04C5}\u{04C7}\u{04C9}\u{04CB}\u{04CD}' +
  '\u{04D0}\u{04D2}\u{04D4}\u{04D6}\u{04D8}\u{04DA}\u{04DC}\u{04DE}' +
  '\u{04E0}\u{04E2}\u{04E4}\u{04E6}\u{04E8}\u{04EA}\u{04EC}\u{04EE}' +
  '\u{04F0}\u{04F2}\u{04F4}\u{04F6}\u{04F8}\u{04FA}\u{04FC}\u{04FE}' +
  '\u{0500}\u{0502}\u{0504}\u{0506}\u{0508}\u{050A}\u{050C}\u{050E}' +
  '\u{0510}\u{0512}\u{0514}\u{0516}\u{0518}\u{051A}\u{051C}\u{051E}' +
  '\u{0520}\u{0522}\u{0524}\u{0526}\u{0528}\u{052A}\u{052C}\u{052E}' +
  '\u{0531}\u{0532}\u{0533}\u{0534}\u{0535}\u{0536}\u{0537}\u{0538}' +
  '\u{0539}\u{053A}\u{053B}\u{053C}\u{053D}\u{053E}\u{053F}\u{0540}' +
  '\u{0541}\u{0542}\u{0543}\u{0544}\u{0545}\u{0546}\u{0547}\u{0548}' +
  '\u{0549}\u{054A}\u{054B}\u{054C}\u{054D}\u{054E}\u{054F}\u{0550}' +
  '\u{0551}\u{0552}\u{0553}\u{0554}\u{0555}\u{0556}\u{0587}\u{10A0}' +
  '\u{10A1}\u{10A2}\u{10A3}\u{10A4}\u{10A5}\u{10A6}\u{10A7}\u{10A8}' +
  '\u{10A9}\u{10AA}\u{10AB}\u{10AC}\u{10AD}\u{10AE}\u{10AF}\u{10B0}' +
  '\u{10B1}\u{10B2}\u{10B3}\u{10B4}\u{10B5}\u{10B6}\u{10B7}\u{10B8}' +
  '\u{10B9}\u{10BA}\u{10BB}\u{10BC}\u{10BD}\u{10BE}\u{10BF}\u{10C0}' +
  '\u{10C1}\u{10C2}\u{10C3}\u{10C4}\u{10C5}\u{10C7}\u{10CD}\u{13F8}' +
  '\u{13F9}\u{13FA}\u{13FB}\u{13FC}\u{13FD}\u{1C80}\u{1C81}\u{1C82}' +
  '\u{1C83}\u{1C84}\u{1C85}\u{1C86}\u{1C87}\u{1C88}\u{1C90}\u{1C91}' +
  '\u{1C92}\u{1C93}\u{1C94}\u{1C95}\u{1C96}\u{1C97}\u{1C98}\u{1C99}' +
  '\u{1C9A}\u{1C9B}\u{1C9C}\u{1C9D}\u{1C9E}\u{1C9F}\u{1CA0}\u{1CA1}' +
  '\u{1CA2}\u{1CA3}\u{1CA4}\u{1CA5}\u{1CA6}\u{1CA7}\u{1CA8}\u{1CA9}' +
  '\u{1CAA}\u{1CAB}\u{1CAC}\u{1CAD}\u{1CAE}\u{1CAF}\u{1CB0}\u{1CB1}' +
  '\u{1CB2}\u{1CB3}\u{1CB4}\u{1CB5}\u{1CB6}\u{1CB7}\u{1CB8}\u{1CB9}' +
  '\u{1CBA}\u{1CBD}\u{1CBE}\u{1CBF}\u{1E00}\u{1E02}\u{1E04}\u{1E06}' +
  '\u{1E08}\u{1E0A}\u{1E0C}\u{1E0E}\u{1E10}\u{1E12}\u{1E14}\u{1E16}' +
  '\u{1E18}\u{1E1A}\u{1E1C}\u{1E1E}\u{1E20}\u{1E22}\u{1E24}\u{1E26}' +
  '\u{1E28}\u{1E2A}\u{1E2C}\u{1E2E}\u{1E30}\u{1E32}\u{1E34}\u{1E36}' +
  '\u{1E38}\u{1E3A}\u{1E3C}\u{1E3E}\u{1E40}\u{1E42}\u{1E44}\u{1E46}' +
  '\u{1E48}\u{1E4A}\u{1E4C}\u{1E4E}\u{1E50}\u{1E52}\u{1E54}\u{1E56}' +
  '\u{1E58}\u{1E5A}\u{1E5C}\u{1E5E}\u{1E60}\u{1E62}\u{1E64}\u{1E66}' +
  '\u{1E68}\u{1E6A}\u{1E6C}\u{1E6E}\u{1E70}\u{1E72}\u{1E74}\u{1E76}' +
  '\u{1E78}\u{1E7A}\u{1E7C}\u{1E7E}\u{1E80}\u{1E82}\u{1E84}\u{1E86}' +
  '\u{1E88}\u{1E8A}\u{1E8C}\u{1E8E}\u{1E90}\u{1E92}\u{1E94}\u{1E96}' +
  '\u{1E97}\u{1E98}\u{1E99}\u{1E9A}\u{1E9B}\u{1E9E}\u{1EA0}\u{1EA2}' +
  '\u{1EA4}\u{1EA6}\u{1EA8}\u{1EAA}\u{1EAC}\u{1EAE}\u{1EB0}\u{1EB2}' +
  '\u{1EB4}\u{1EB6}\u{1EB8}\u{1EBA}\u{1EBC}\u{1EBE}\u{1EC0}\u{1EC2}' +
  '\u{1EC4}\u{1EC6}\u{1EC8}\u{1ECA}\u{1ECC}\u{1ECE}\u{1ED0}\u{1ED2}' +
  '\u{1ED4}\u{1ED6}\u{1ED8}\u{1EDA}\u{1EDC}\u{1EDE}\u{1EE0}\u{1EE2}' +
  '\u{1EE4}\u{1EE6}\u{1EE8}\u{1EEA}\u{1EEC}\u{1EEE}\u{1EF0}\u{1EF2}' +
  '\u{1EF4}\u{1EF6}\u{1EF8}\u{1EFA}\u{1EFC}\u{1EFE}\u{1F08}\u{1F09}' +
  '\u{1F0A}\u{1F0B}\u{1F0C}\u{1F0D}\u{1F0E}\u{1F0F}\u{1F18}\u{1F19}' +
  '\u{1F1A}\u{1F1B}\u{1F1C}\u{1F1D}\u{1F28}\u{1F29}\u{1F2A}\u{1F2B}' +
  '\u{1F2C}\u{1F2D}\u{1F2E}\u{1F2F}\u{1F38}\u{1F39}\u{1F3A}\u{1F3B}' +
  '\u{1F3C}\u{1F3D}\u{1F3E}\u{1F3F}\u{1F48}\u{1F49}\u{1F4A}\u{1F4B}' +
  '\u{1F4C}\u{1F4D}\u{1F50}\u{1F52}\u{1F54}\u{1F56}\u{1F59}\u{1F5B}' +
  '\u{1F5D}\u{1F5F}\u{1F68}\u{1F69}\u{1F6A}\u{1F6B}\u{1F6C}\u{1F6D}' +
  '\u{1F6E}\u{1F6F}\u{1F80}\u{1F81}\u{1F82}\u{1F83}\u{1F84}\u{1F85}' +
  '\u{1F86}\u{1F87}\u{1F88}\u{1F89}\u{1F8A}\u{1F8B}\u{1F8C}\u{1F8D}' +
  '\u{1F8E}\u{1F8F}\u{1F90}\u{1F91}\u{1F92}\u{1F93}\u{1F94}\u{1F95}' +
  '\u{1F96}\u{1F97}\u{1F98}\u{1F99}\u{1F9A}\u{1F9B}\u{1F9C}\u{1F9D}' +
  '\u{1F9E}\u{1F9F}\u{1FA0}\u{1FA1}\u{1FA2}\u{1FA3}\u{1FA4}\u{1FA5}' +
  '\u{1FA6}\u{1FA7}\u{1FA8}\u{1FA9}\u{1FAA}\u{1FAB}\u{1FAC}\u{1FAD}' +
  '\u{1FAE}\u{1FAF}\u{1FB2}\u{1FB3}\u{1FB4}\u{1FB6}\u{1FB7}\u{1FB8}' +
  '\u{1FB9}\u{1FBA}\u{1FBB}\u{1FBC}\u{1FBE}\u{1FC2}\u{1FC3}\u{1FC4}' +
  '\u{1FC6}\u{1FC7}\u{1FC8}\u{1FC9}\u{1FCA}\u{1FCB}\u{1FCC}\u{1FD2}' +
  '\u{1FD3}\u{1FD6}\u{1FD7}\u{1FD8}\u{1FD9}\u{1FDA}\u{1FDB}\u{1FE2}' +
  '\u{1FE3}\u{1FE4}\u{1FE6}\u{1FE7}\u{1FE8}\u{1FE9}\u{1FEA}\u{1FEB}' +
  '\u{1FEC}\u{1FF2}\u{1FF3}\u{1FF4}\u{1FF6}\u{1FF7}\u{1FF8}\u{1FF9}' +
  '\u{1FFA}\u{1FFB}\u{1FFC}\u{2126}\u{212A}\u{212B}\u{2132}\u{2160}' +
  '\u{2161}\u{2162}\u{2163}\u{2164}\u{2165}\u{2166}\u{2167}\u{2168}' +
  '\u{2169}\u{216A}\u{216B}\u{216C}\u{216D}\u{216E}\u{216F}\u{2183}' +
  '\u{24B6}\u{24B7}\u{24B8}\u{24B9}\u{24BA}\u{24BB}\u{24BC}\u{24BD}' +
  '\u{24BE}\u{24BF}\u{24C0}\u{24C1}\u{24C2}\u{24C3}\u{24C4}\u{24C5}' +
  '\u{24C6}\u{24C7}\u{24C8}\u{24C9}\u{24CA}\u{24CB}\u{24CC}\u{24CD}' +
  '\u{24CE}\u{24CF}\u{2C00}\u{2C01}\u{2C02}\u{2C03}\u{2C04}\u{2C05}' +
  '\u{2C06}\u{2C07}\u{2C08}\u{2C09}\u{2C0A}\u{2C0B}\u{2C0C}\u{2C0D}' +
  '\u{2C0E}\u{2C0F}\u{2C10}\u{2C11}\u{2C12}\u{2C13}\u{2C14}\u{2C15}' +
  '\u{2C16}\u{2C17}\u{2C18}\u{2C19}\u{2C1A}\u{2C1B}\u{2C1C}\u{2C1D}' +
  '\u{2C1E}\u{2C1F}\u{2C20}\u{2C21}\u{2C22}\u{2C23}\u{2C24}\u{2C25}' +
  '\u{2C26}\u{2C27}\u{2C28}\u{2C29}\u{2C2A}\u{2C2B}\u{2C2C}\u{2C2D}' +
  '\u{2C2E}\u{2C60}\u{2C62}\u{2C63}\u{2C64}\u{2C67}\u{2C69}\u{2C6B}' +
  '\u{2C6D}\u{2C6E}\u{2C6F}\u{2C70}\u{2C72}\u{2C75}\u{2C7E}\u{2C7F}' +
  '\u{2C80}\u{2C82}\u{2C84}\u{2C86}\u{2C88}\u{2C8A}\u{2C8C}\u{2C8E}' +
  '\u{2C90}\u{2C92}\u{2C94}\u{2C96}\u{2C98}\u{2C9A}\u{2C9C}\u{2C9E}' +
  '\u{2CA0}\u{2CA2}\u{2CA4}\u{2CA6}\u{2CA8}\u{2CAA}\u{2CAC}\u{2CAE}' +
  '\u{2CB0}\u{2CB2}\u{2CB4}\u{2CB6}\u{2CB8}\u{2CBA}\u{2CBC}\u{2CBE}' +
  '\u{2CC0}\u{2CC2}\u{2CC4}\u{2CC6}\u{2CC8}\u{2CCA}\u{2CCC}\u{2CCE}' +
  '\u{2CD0}\u{2CD2}\u{2CD4}\u{2CD6}\u{2CD8}\u{2CDA}\u{2CDC}\u{2CDE}' +
  '\u{2CE0}\u{2CE2}\u{2CEB}\u{2CED}\u{2CF2}\u{A640}\u{A642}\u{A644}' +
  '\u{A646}\u{A648}\u{A64A}\u{A64C}\u{A64E}\u{A650}\u{A652}\u{A654}' +
  '\u{A656}\u{A658}\u{A65A}\u{A65C}\u{A65E}\u{A660}\u{A662}\u{A664}' +
  '\u{A666}\u{A668}\u{A66A}\u{A66C}\u{A680}\u{A682}\u{A684}\u{A686}' +
  '\u{A688}\u{A68A}\u{A68C}\u{A68E}\u{A690}\u{A692}\u{A694}\u{A696}' +
  '\u{A698}\u{A69A}\u{A722}\u{A724}\u{A726}\u{A728}\u{A72A}\u{A72C}' +
  '\u{A72E}\u{A732}\u{A734}\u{A736}\u{A738}\u{A73A}\u{A73C}\u{A73E}' +
  '\u{A740}\u{A742}\u{A744}\u{A746}\u{A748}\u{A74A}\u{A74C}\u{A74E}' +
  '\u{A750}\u{A752}\u{A754}\u{A756}\u{A758}\u{A75A}\u{A75C}\u{A75E}' +
  '\u{A760}\u{A762}\u{A764}\u{A766}\u{A768}\u{A76A}\u{A76C}\u{A76E}' +
  '\u{A779}\u{A77B}\u{A77D}\u{A77E}\u{A780}\u{A782}\u{A784}\u{A786}' +
  '\u{A78B}\u{A78D}\u{A790}\u{A792}\u{A796}\u{A798}\u{A79A}\u{A79C}' +
  '\u{A79E}\u{A7A0}\u{A7A2}\u{A7A4}\u{A7A6}\u{A7A8}\u{A7AA}\u{A7AB}' +
  '\u{A7AC}\u{A7AD}\u{A7AE}\u{A7B0}\u{A7B1}\u{A7B2}\u{A7B3}\u{A7B4}' +
  '\u{A7B6}\u{A7B8}\u{A7BA}\u{A7BC}\u{A7BE}\u{A7C2}\u{A7C4}\u{A7C5}' +
  '\u{A7C6}\u{AB70}\u{AB71}\u{AB72}\u{AB73}\u{AB74}\u{AB75}\u{AB76}' +
  '\u{AB77}\u{AB78}\u{AB79}\u{AB7A}\u{AB7B}\u{AB7C}\u{AB7D}\u{AB7E}' +
  '\u{AB7F}\u{AB80}\u{AB81}\u{AB82}\u{AB83}\u{AB84}\u{AB85}\u{AB86}' +
  '\u{AB87}\u{AB88}\u{AB89}\u{AB8A}\u{AB8B}\u{AB8C}\u{AB8D}\u{AB8E}' +
  '\u{AB8F}\u{AB90}\u{AB91}\u{AB92}\u{AB93}\u{AB94}\u{AB95}\u{AB96}' +
  '\u{AB97}\u{AB98}\u{AB99}\u{AB9A}\u{AB9B}\u{AB9C}\u{AB9D}\u{AB9E}' +
  '\u{AB9F}\u{ABA0}\u{ABA1}\u{ABA2}\u{ABA3}\u{ABA4}\u{ABA5}\u{ABA6}' +
  '\u{ABA7}\u{ABA8}\u{ABA9}\u{ABAA}\u{ABAB}\u{ABAC}\u{ABAD}\u{ABAE}' +
  '\u{ABAF}\u{ABB0}\u{ABB1}\u{ABB2}\u{ABB3}\u{ABB4}\u{ABB5}\u{ABB6}' +
  '\u{ABB7}\u{ABB8}\u{ABB9}\u{ABBA}\u{ABBB}\u{ABBC}\u{ABBD}\u{ABBE}' +
  '\u{ABBF}\u{FB00}\u{FB01}\u{FB02}\u{FB03}\u{FB04}\u{FB05}\u{FB06}' +
  '\u{FB13}\u{FB14}\u{FB15}\u{FB16}\u{FB17}\u{FF21}\u{FF22}\u{FF23}' +
  '\u{FF24}\u{FF25}\u{FF26}\u{FF27}\u{FF28}\u{FF29}\u{FF2A}\u{FF2B}' +
  '\u{FF2C}\u{FF2D}\u{FF2E}\u{FF2F}\u{FF30}\u{FF31}\u{FF32}\u{FF33}' +
  '\u{FF34}\u{FF35}\u{FF36}\u{FF37}\u{FF38}\u{FF39}\u{FF3A}\u{10400}' +
  '\u{10401}\u{10402}\u{10403}\u{10404}\u{10405}\u{10406}\u{10407}\u{10408}' +
  '\u{10409}\u{1040A}\u{1040B}\u{1040C}\u{1040D}\u{1040E}\u{1040F}\u{10410}' +
  '\u{10411}\u{10412}\u{10413}\u{10414}\u{10415}\u{10416}\u{10417}\u{10418}' +
  '\u{10419}\u{1041A}\u{1041B}\u{1041C}\u{1041D}\u{1041E}\u{1041F}\u{10420}' +
  '\u{10421}\u{10422}\u{10423}\u{10424}\u{10425}\u{10426}\u{10427}\u{104B0}' +
  '\u{104B1}\u{104B2}\u{104B3}\u{104B4}\u{104B5}\u{104B6}\u{104B7}\u{104B8}' +
  '\u{104B9}\u{104BA}\u{104BB}\u{104BC}\u{104BD}\u{104BE}\u{104BF}\u{104C0}' +
  '\u{104C1}\u{104C2}\u{104C3}\u{104C4}\u{104C5}\u{104C6}\u{104C7}\u{104C8}' +
  '\u{104C9}\u{104CA}\u{104CB}\u{104CC}\u{104CD}\u{104CE}\u{104CF}\u{104D0}' +
  '\u{104D1}\u{104D2}\u{104D3}\u{10C80}\u{10C81}\u{10C82}\u{10C83}\u{10C84}' +
  '\u{10C85}\u{10C86}\u{10C87}\u{10C88}\u{10C89}\u{10C8A}\u{10C8B}\u{10C8C}' +
  '\u{10C8D}\u{10C8E}\u{10C8F}\u{10C90}\u{10C91}\u{10C92}\u{10C93}\u{10C94}' +
  '\u{10C95}\u{10C96}\u{10C97}\u{10C98}\u{10C99}\u{10C9A}\u{10C9B}\u{10C9C}' +
  '\u{10C9D}\u{10C9E}\u{10C9F}\u{10CA0}\u{10CA1}\u{10CA2}\u{10CA3}\u{10CA4}' +
  '\u{10CA5}\u{10CA6}\u{10CA7}\u{10CA8}\u{10CA9}\u{10CAA}\u{10CAB}\u{10CAC}' +
  '\u{10CAD}\u{10CAE}\u{10CAF}\u{10CB0}\u{10CB1}\u{10CB2}\u{118A0}\u{118A1}' +
  '\u{118A2}\u{118A3}\u{118A4}\u{118A5}\u{118A6}\u{118A7}\u{118A8}\u{118A9}' +
  '\u{118AA}\u{118AB}\u{118AC}\u{118AD}\u{118AE}\u{118AF}\u{118B0}\u{118B1}' +
  '\u{118B2}\u{118B3}\u{118B4}\u{118B5}\u{118B6}\u{118B7}\u{118B8}\u{118B9}' +
  '\u{118BA}\u{118BB}\u{118BC}\u{118BD}\u{118BE}\u{118BF}\u{16E40}\u{16E41}' +
  '\u{16E42}\u{16E43}\u{16E44}\u{16E45}\u{16E46}\u{16E47}\u{16E48}\u{16E49}' +
  '\u{16E4A}\u{16E4B}\u{16E4C}\u{16E4D}\u{16E4E}\u{16E4F}\u{16E50}\u{16E51}' +
  '\u{16E52}\u{16E53}\u{16E54}\u{16E55}\u{16E56}\u{16E57}\u{16E58}\u{16E59}' +
  '\u{16E5A}\u{16E5B}\u{16E5C}\u{16E5D}\u{16E5E}\u{16E5F}\u{1E900}\u{1E901}' +
  '\u{1E902}\u{1E903}\u{1E904}\u{1E905}\u{1E906}\u{1E907}\u{1E908}\u{1E909}' +
  '\u{1E90A}\u{1E90B}\u{1E90C}\u{1E90D}\u{1E90E}\u{1E90F}\u{1E910}\u{1E911}' +
  '\u{1E912}\u{1E913}\u{1E914}\u{1E915}\u{1E916}\u{1E917}\u{1E918}\u{1E919}' +
  '\u{1E91A}\u{1E91B}\u{1E91C}\u{1E91D}\u{1E91E}\u{1E91F}\u{1E920}\u{1E921}' +
  ']', 'ug');

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/unicode-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * This is an implementation of the default case folding which complies
 * with the Unicode&reg; Standard (12.0.0, section 3.13, R4).
 *
 * @param {String} value
 * a string to be case-folded.
 *
 * @return {String}
 * the result of the default case folding,
 * or `value` if `value` is not a {@link String}.
 *
 * @example
 * import { toCaseFold } from '@kkitahara/unicode-tools'
 *
 * '\u{00c5}' === '\u{00e5}' // false
 * toCaseFold('\u{00c5}') === '\u{00e5}' // true
 *
 * '\u{0041}\u{030a}' === '\u{0061}\u{030a}' // false
 * toCaseFold('\u{0041}\u{030a}') === '\u{0061}\u{030a}' // true
 *
 * // return the input value if it is not a string
 * toCaseFold(null) // null
 * toCaseFold(false) // false
 *
 * @version
 * 1.0.8
 *
 * @since
 * 1.0.0
 */
function toCaseFold (value) {
  if (typeof value === 'string') {
    return value.replace(re$1, match => {
      return map.get(match)
    })
  } else {
    return value
  }
}

/**
 * @desc
 * This is an implementation of the mapping
 * `NFD(toCaseFold(NFD(str)))` (here, we call it canonical case folding)
 * used for the canonical caseless matching which complies with
 * the Unicode&reg; Standard (12.0.0, section 3.13, D145).
 * For the normalisation `NFD(str)`, built-in
 * `String.prototype.normalize('NFD')` is used.
 *
 * @param {String} value
 * a string to be canonical case-folded.
 *
 * @return {String}
 * the result of the canonical case folding of `value`,
 * or `value` if `value` is not a {@link String}.
 *
 * @example
 * import { toCanonicalCaseFold } from '@kkitahara/unicode-tools'
 *
 * '\u{00c5}' === '\u{00e5}' // false
 * toCanonicalCaseFold('\u{00c5}') === '\u{00e5}' // false
 * toCanonicalCaseFold('\u{00c5}') === '\u{0061}\u{030a}' // true
 *
 * '\u{0041}\u{030a}' === '\u{0061}\u{030a}' // false
 * toCanonicalCaseFold('\u{0041}\u{030a}') === '\u{0061}\u{030a}' // true
 *
 * // return the input value if it is not a string
 * toCanonicalCaseFold(null) // null
 * toCanonicalCaseFold(false) // false
 *
 * @version
 * 1.0.8
 *
 * @since
 * 1.0.0
 */
function toCanonicalCaseFold (value) {
  if (typeof value === 'string') {
    return toCaseFold(value.normalize('NFD')).normalize('NFD')
  } else {
    return value
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const nullItem = { value: null, source: 'missing', alert: '' };
const storedItem = value => ({
  value,
  source: 'stored',
  alert: ''
});
const evaluatedItem = value => ({
  value,
  source: 'evaluated',
  alert: ''
});
const defaultItem = value => ({
  value,
  source: 'default',
  alert: ''
});
const loopItem = value => ({
  value,
  source: 'internal', // only for internal use
  alert: ''
});
const emptySetCategory = { value: new Map(), source: 'default', alert: '' };
const emptyLoopCategory = { value: [], source: 'default', alert: '' };
const defCache = new MultiKeyMap();
const validatedCache = new MultiKeyMap();
const wrappedStoredCatCache = new WeakMap();
const evaluatedCache = new MultiKeyMap();
const loopCache = new MultiKeyWeakMap();

// limitation:
// * Loop category items as dependencies (ad hoc):
//     [catId, INAPPLICABLE]: whole category
//     [catId, objId]: item in the current packet
// * Loop category items cannot be dependencies of an item of a different
//   category. Use categories instead of items as dependencies.
// * currentPacket does not need to be in data.
const selectDefinition = (
  dict,
  data,
  catId,
  objId = false,
  currentPacket = false
) => {
  const attr = dict.get([catId, objId]) || new MultiKeyMap();
  const defMethod = attr.get(['method', 'Definition']);
  if (defMethod) {
    const deps = (defMethod.dependencies || []).map(
      ([cId, oId]) => cId === catId && oId !== false
        ? selectDataItem(dict, data, cId, oId, currentPacket)
        : selectDataItem(dict, data, cId, oId, false)
    );
    const cacheKey = [catId, objId];
    let cache = defCache.get(cacheKey);
    if (!cache) {
      cache = new MultiKeyWeakMap();
      defCache.set(cacheKey, cache);
    }
    const key = currentPacket
      ? [currentPacket, ...deps]
      : [...deps];
    if (cache.has(key)) {
      return cache.get(key)
    }
    const def = defMethod.function(deps, attr, dict, data, currentPacket);
    cache.set(key, def);
    return def
  } else {
    return attr
  }
};

const checkSingleValue = (value, def) => {
  const contents = def.get(['type', 'contents']);
  switch (contents) {
    case 'code': {
      if (value === null) {
        return ''
      } else if (value === false) {
        return ''
      }
      // ad hoc, incomplete test
      if (typeof value !== 'string') {
        return 'Throw: value must be a CIF2 string.'
      }
      break
    }
    case 'integer' : {
      if (value === null || value === false || Number.isNaN(value)) {
        return ''
      }
      if (typeof value !== 'number' || !Number.isInteger(value)) {
        return 'Throw: value must be an integer.'
      }
      break
    }
    case 'real' : {
      if (value === null || value === false || Number.isNaN(value)) {
        return ''
      }
      if (typeof value !== 'number') {
        return 'Throw: value must be a number.'
      }
      break
    }
    case 'colour': {
      if (value === null) {
        return ''
      } else if (value === false) {
        return ''
      }
      if (!/^#[0-9a-fA-F]{6}$/.test(value)) {
        return 'Throw: invalid colour value.'
      }
      break
    }
    case 'polytope': {
      // no check here
      break
    }
    default: {
      return 'Debug info: unsupported contents.'
    }
  }
  /* valid only for single items ??? ... */
  switch (contents) {
    case 'integer':
    case 'real': {
      let from = -Infinity;
      let to = Infinity;
      const range = def.get(['enumeration', 'range']);
      if (range) {
        if (typeof range[0] === 'number') {
          from = Math.max(from, range[0]);
        }
        if (typeof range[1] === 'number') {
          to = Math.min(to, range[1]);
        }
      }
      if (value < from || value > to) {
        return 'Throw: out of enumeration range.'
      }
      break
    }
  }
  const set = def.get(['enumeration_set', 'state']);
  if (set) {
    switch (contents) {
      case 'code': {
        const folded = toCanonicalCaseFold(value);
        if (!set.some(state => state === folded)) {
          return 'Throw: value is not listed in enumeration set.'
        }
        break
      }
      default: {
        if (!set.some(state => state === value)) {
          return 'Throw: value is not listed in enumeration set.'
        }
        break
      }
    }
  }
  /* ... valid only for single items ??? */
  return ''
};

const checkMatrixValue = (value, def) => {
  const dimension = def.get(['type', 'dimension']);
  if (!dimension) {
    if (value === false) {
      return ''
    } else {
      return 'Throw: value is not inapplicable while dimension is not well-defined.'
    }
  } else {
    if (
      !Array.isArray(value) ||
      value.length !== dimension.reduce((len, dimi) => len * dimi, 1)
    ) {
      return 'Throw: value is not a matrix of valid dimension.'
    }
    let msg;
    for (const elem of value) {
      msg = checkSingleValue(elem, def);
      if (msg) {
        return msg
      }
    }
    return ''
  }
};

const checkListValue = (value, def) => {
  const dimension = def.get(['type', 'dimension']);
  if (!dimension) {
    if (value === false) {
      return ''
    } else {
      return 'Throw: value is not inapplicable while dimension is not well-defined.'
    }
  } else {
    if (
      !Array.isArray(value) ||
      (dimension.length === 1 && value.length !== dimension[0])
    ) {
      return 'Throw: value is not a list of valid dimension.'
    }
    let msg;
    for (const elem of value) {
      msg = checkSingleValue(elem, def);
      if (msg) {
        return msg
      }
    }
    return ''
  }
};

const basicValidation = (target, def) => {
  const catClass = def.get(['definition', 'class']);
  if (catClass === 'set' || catClass === 'loop') {
    return ''
  }
  // assume 'datum'
  const container = def.get(['type', 'container']);
  switch (container) {
    case 'single': {
      return checkSingleValue(target.value, def)
    }
    case 'matrix': {
      return checkMatrixValue(target.value, def)
    }
    case 'list': {
      return checkListValue(target.value, def)
    }
    default: {
      return 'Debug info: unsupported container.'
    }
  }
};

const selectValidatedDataItem = (
  target,
  dict,
  data,
  catId,
  objId = false,
  currentPacket = false
) => {
  const def = selectDefinition(dict, data, catId, objId, currentPacket);
  const valMethod = def.get(['method', 'Validation']);
  const deps = [];
  if (valMethod) {
    deps.push(
      ...(valMethod.dependencies || []).map(
        ([cId, oId]) => cId === catId && oId !== false
          ? selectDataItem(dict, data, cId, oId, currentPacket)
          : selectDataItem(dict, data, cId, oId, false)
      )
    );
  }
  const cacheKey = [catId, objId];
  let cache = validatedCache.get(cacheKey);
  if (!cache) {
    cache = new MultiKeyWeakMap();
    validatedCache.set(cacheKey, cache);
  }
  const key = currentPacket
    ? [target, def, currentPacket, ...deps]
    : [target, def, ...deps];
  if (cache.has(key)) {
    return cache.get(key)
  }
  const alert = basicValidation(target, def) ||
    (
      valMethod
        ? valMethod.function(target, def, deps, dict, data, currentPacket)
        : ''
    );
  let validated = target;
  if (alert !== target.alert) {
    validated = { ...target, alert };
  }
  cache.set(key, validated);
  return validated
};

const selectWrappedStoredCategory = (
  data,
  catId
) => {
  const stored = data.get(catId);
  if (!stored) {
    return nullItem
  }
  if (wrappedStoredCatCache.has(stored)) {
    return wrappedStoredCatCache.get(stored)
  }
  const wrapped = storedItem(stored);
  wrappedStoredCatCache.set(stored, wrapped);
  return wrapped
};

const selectStoredDataItem = (
  dict,
  data,
  catId,
  objId = false,
  currentPacket = false
) => {
  const catDef = selectDefinition(dict, data, catId);
  let stored;
  if (objId === false) {
    // select category
    stored = selectWrappedStoredCategory(data, catId);
  } else {
    // select item
    const catClass = catDef.get(['definition', 'class']);
    if (catClass === 'set') {
      // from set category
      const cat = data.get(catId);
      if (cat) {
        stored = cat.get(objId);
      }
    } else if (catClass === 'loop') {
      // from loop category (currentPacket)
      stored = currentPacket.get(objId);
    } else {
      throw Error(`Debug info: unsupported category class (${catClass}).`)
    }
  }
  stored = stored || nullItem;
  const validated =
    selectValidatedDataItem(stored, dict, data, catId, objId, currentPacket);
  if (/^Throw: /.test(validated.alert)) {
    // ignore stored item if the type of alert is 'Throw'
    return nullItem
  } else {
    return validated
  }
};

const basicEvaluation = (deps, def) => {
  if (
    deps.some(x =>
      /^Throw: /.test(x.alert) || x.value === false || x.value === null
    )
  ) {
    return evaluatedItem(false)
  }
  const catClass = def.get(['definition', 'class']);
  if (catClass === 'set' || catClass === 'loop') {
    return nullItem
  }
  // assume 'datum'
  const container = def.get(['type', 'container']);
  switch (container) {
    case 'matrix': {
      const dimension = def.get(['type', 'dimension']);
      if (!dimension) {
        return evaluatedItem(false)
      }
    }
  }
  return nullItem
};

const selectEvaluatedDataItem = (
  dict,
  data,
  catId,
  objId = false,
  currentPacket = false
) => {
  const def = selectDefinition(dict, data, catId, objId, currentPacket);
  const evalMethod = def.get(['method', 'Evaluation']);
  let deps = [];
  if (evalMethod) {
    deps = evalMethod.dependencies.map(
      ([cId, oId]) => cId === catId && oId !== false
        ? selectDataItem(dict, data, cId, oId, currentPacket)
        : selectDataItem(dict, data, cId, oId, false)
    );
  }
  const cacheKey = [catId, objId];
  let cache = evaluatedCache.get(cacheKey);
  if (!cache) {
    cache = new MultiKeyWeakMap();
    evaluatedCache.set(cacheKey, cache);
  }
  const key = currentPacket
    ? [def, currentPacket, ...deps]
    : [def, ...deps];
  if (cache.has(key)) {
    return cache.get(key)
  }
  let evaluated = basicEvaluation(deps, def);
  if (evaluated.value === null && evalMethod) {
    evaluated = evalMethod.function(deps, def, dict, data, currentPacket);
  }
  cache.set(key, evaluated);
  return evaluated
};

const selectDefaultDataItem = (
  dict,
  data,
  catId,
  objId = false,
  currentPacket = false
) => {
  const def = selectDefinition(dict, data, catId, objId, currentPacket);
  if (objId === false) {
    // select category
    const catClass = def.get(['definition', 'class']);
    if (catClass === 'set') {
      return emptySetCategory
    } else if (catClass === 'loop') {
      return emptyLoopCategory
    } else {
      throw Error(`Debug info: unsupported category class (${catClass}).`)
    }
  } else {
    // select item
    return def.get(['enumeration', 'default']) || nullItem
  }
};

const selectLoopDataItem = items => {
  if (loopCache.has(items)) {
    return loopCache.get(items)
  }
  const wrapped = loopItem(items);
  loopCache.set(items, wrapped);
  return wrapped
};

const selectDataItem = (
  dict,
  data,
  catId,
  objId = false,
  currentPacket = false
) => {
  const catDef = selectDefinition(dict, data, catId);
  const catClass = catDef.get(['definition', 'class']);
  if (catClass === 'loop' && objId !== false && currentPacket === false) {
    const catData = selectDataItem(dict, data, catId).value;
    if (catData !== null) {
      return selectLoopDataItem(
        catData.map(packet => selectDataItem(dict, data, catId, objId, packet))
      )
    } else {
      return nullItem
    }
  }
  const stored = selectStoredDataItem(dict, data, catId, objId, currentPacket);
  if (stored.value !== null) {
    return stored
  }
  const evaluated =
    selectEvaluatedDataItem(dict, data, catId, objId, currentPacket);
  if (evaluated.value !== null) {
    return evaluated
  }
  const defaultItem =
    selectDefaultDataItem(dict, data, catId, objId, currentPacket);
  return defaultItem
};

/* @license-end */

var BigInteger = createCommonjsModule(function (module) {
var bigInt = (function (undefined$1) {

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";

    var supportsNativeBigInt = typeof BigInt === "function";

    function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function NativeBigInt(value) {
        this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    NativeBigInt.prototype.add = function (v) {
        return new NativeBigInt(this.value + parseValue(v).value);
    };
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    NativeBigInt.prototype.subtract = function (v) {
        return new NativeBigInt(this.value - parseValue(v).value);
    };
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };
    NativeBigInt.prototype.negate = function () {
        return new NativeBigInt(-this.value);
    };

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function () {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };


    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
        if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    NativeBigInt.prototype.multiply = function (v) {
        return new NativeBigInt(this.value * parseValue(v).value);
    };
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

    function square(a) {
        //console.assert(2 * BASE * BASE < MAX_INT);
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for (var j = i; j < l; j++) {
                a_j = a[j];
                product = 2 * (a_i * a_j) + r[i + j] + carry;
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    NativeBigInt.prototype.square = function (v) {
        return new NativeBigInt(this.value * this.value);
    };

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
        }
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;


    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
        return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
        return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    NativeBigInt.prototype.pow = function (v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
            if ((b & _1) === _1) {
                y = y.times(x);
                --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
        }
        return y;
    };

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
        }
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };
    NativeBigInt.prototype.compareAbs = function (v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
    };

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    NativeBigInt.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
    };
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function () {
        return (this.value & BigInt(1)) === BigInt(0);
    };

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function () {
        return (this.value & BigInt(1)) === BigInt(1);
    };

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function () {
        return this.abs().value === BigInt(1);
    };

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function () {
        return this.value === BigInt(0);
    };

    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    function millerRabinTest(n, a) {
        var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d, i, x;
        while (b.isEven()) b = b.divide(2), r++;
        next: for (i = 0; i < a.length; i++) {
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
                x = x.square().mod(n);
                if (x.isUnit()) return false;
                if (x.equals(nPrev)) continue next;
            }
            return false;
        }
        return true;
    }

    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
    BigInteger.prototype.isPrime = function (strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt(i + 2));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var t = iterations === undefined$1 ? 5 : iterations;
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function () {
        return new NativeBigInt(this.value + BigInt(1));
    };

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function () {
        return new NativeBigInt(this.value - BigInt(1));
    };

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
    }

    BigInteger.prototype.shiftLeft = function (v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I :
                typeof v === "bigint" ? v | BigInt(LOBMASK_I) :
                    v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
    }

    BigInteger.prototype.bitLength = function () {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    };
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i = 0; i < digits.length; i++) {
            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < digits[i]) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
    }

    var parseBase = function (text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i = 0; i < alphabet.length; i++) {
            alphabetValues[alphabet[i]] = i;
        }
        for (i = 0; i < length; i++) {
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
                if (alphabetValues[c] >= absBase) {
                    if (c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
                }
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
            return alphabet[digit];
        }
        return "<" + digit + ">";
    }

    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return { value: [0], isNegative: false };
            if (n.isNegative())
                return {
                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))
                        .map(Array.prototype.valueOf, [1, 0])
                    ),
                    isNegative: false
                };

            var arr = Array.apply(null, Array(n.toJSNumber() - 1))
                .map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
                value: [].concat.apply([], arr),
                isNegative: false
            };
        }

        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.isUnit()) {
            if (n.isZero()) return { value: [0], isNegative: false };

            return {
                value: Array.apply(null, Array(n.toJSNumber()))
                    .map(Number.prototype.valueOf, 1),
                isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
    }

    function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            return stringify(x, alphabet);
        }).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    NativeBigInt.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix !== 10) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix != 10) return toBaseString(this, radix, alphabet);
        return String(this.value);
    };

    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); };

    BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
        return parseInt(this.toString(), 10);
    };

    function parseStringValue(v) {
        if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x))
                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
                exp -= text.length - decimalPlace - 1;
                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += (new Array(exp + 1)).join("0");
            v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max = v.length, l = LOG_BASE, min = max - l;
        while (max > 0) {
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
        }
        trim(r);
        return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        if (typeof v === "bigint") {
            return new NativeBigInt(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if ( module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}
});

var BigRational = createCommonjsModule(function (module) {
 var bigRat = (function (bigInt) {

    function BigRational(num, denom) {
        // Alias properties kept for backwards compatability
        if (denom.isZero()) throw "Denominator cannot be 0.";
        this.numerator = this.num = num;
        this.denominator = this.denom = denom;
    }

    var gcd = bigInt.gcd,
        lcm = bigInt.lcm;

    function reduce(n, d) {
        var divisor = gcd(n, d),
            num = n.over(divisor),
            denom = d.over(divisor);
        if (denom.isNegative()) {
            return new BigRational(num.negate(), denom.negate());
        }
        return new BigRational(num, denom);
    }

    BigRational.prototype.add = function (n, d) {
        var v = interpret(n, d),
            multiple = lcm(this.denom, v.denom),
            a = multiple.divide(this.denom),
            b = multiple.divide(v.denom);

        a = this.num.times(a);
        b = v.num.times(b);
        return reduce(a.add(b), multiple);
    };
    BigRational.prototype.plus = BigRational.prototype.add;

    BigRational.prototype.subtract = function (n, d) {
        var v = interpret(n, d);
        return this.add(v.negate());
    };
    BigRational.prototype.minus = BigRational.prototype.subtract;

    BigRational.prototype.multiply = function (n, d) {
        var v = interpret(n, d);
        return reduce(this.num.times(v.num), this.denom.times(v.denom));
    };
    BigRational.prototype.times = BigRational.prototype.multiply;

    BigRational.prototype.divide = function (n, d) {
        var v = interpret(n, d);
        return reduce(this.num.times(v.denom), this.denom.times(v.num));
    };
    BigRational.prototype.over = BigRational.prototype.divide;

    BigRational.prototype.reciprocate = function () {
        return new BigRational(this.denom, this.num);
    };
    BigRational.prototype.mod = function (n, d) {
        var v = interpret(n, d);
        return this.minus(v.times(this.over(v).floor()));
    };
    BigRational.prototype.pow = function (n) {
        var v = bigInt(n);
        var num = this.num.pow(v),
            denom = this.denom.pow(v);
        return reduce(num, denom);
    };

    BigRational.prototype.floor = function (toBigInt) {
        var divmod = this.num.divmod(this.denom),
            floor;
        if (divmod.remainder.isZero() || !divmod.quotient.isNegative()) {
            floor = divmod.quotient;
        }
        else floor = divmod.quotient.prev();
        if (toBigInt) return floor;
        return new BigRational(floor, bigInt[1]);
    };
    BigRational.prototype.ceil = function (toBigInt) {
        var divmod = this.num.divmod(this.denom),
            ceil;
        if (divmod.remainder.isZero() || divmod.quotient.isNegative()) {
            ceil = divmod.quotient;
        }
        else ceil = divmod.quotient.next();
        if (toBigInt) return ceil;
        return new BigRational(ceil, bigInt[1]);
    };
    BigRational.prototype.round = function (toBigInt) {
        return this.add(1, 2).floor(toBigInt);
    };

    BigRational.prototype.compareAbs = function (n, d) {
        var v = interpret(n, d);
        if (this.denom.equals(v.denom)) {
            return this.num.compareAbs(v.num);
        }
        return this.num.times(v.denom).compareAbs(v.num.times(this.denom));
    };
    BigRational.prototype.compare = function (n, d) {
        var v = interpret(n, d);
        if (this.denom.equals(v.denom)) {
            return this.num.compare(v.num);
        }
        var comparison = this.denom.isNegative() === v.denom.isNegative() ? 1 : -1;
        return comparison * this.num.times(v.denom).compare(v.num.times(this.denom));
    };
    BigRational.prototype.compareTo = BigRational.prototype.compare;

    BigRational.prototype.equals = function (n, d) {
        return this.compare(n, d) === 0;
    };
    BigRational.prototype.eq = BigRational.prototype.equals;

    BigRational.prototype.notEquals = function (n, d) {
        return this.compare(n, d) !== 0;
    };
    BigRational.prototype.neq = BigRational.prototype.notEquals;

    BigRational.prototype.lesser = function (n, d) {
        return this.compare(n, d) < 0;
    };
    BigRational.prototype.lt = BigRational.prototype.lesser;

    BigRational.prototype.lesserOrEquals = function (n, d) {
        return this.compare(n, d) <= 0;
    };
    BigRational.prototype.leq = BigRational.prototype.lesserOrEquals;

    BigRational.prototype.greater = function (n, d) {
        return this.compare(n, d) > 0;
    };
    BigRational.prototype.gt = BigRational.prototype.greater;

    BigRational.prototype.greaterOrEquals = function (n, d) {
        return this.compare(n, d) >= 0;
    };
    BigRational.prototype.geq = BigRational.prototype.greaterOrEquals;

    BigRational.prototype.abs = function () {
        if (this.isPositive()) return this;
        return this.negate();
    };
    BigRational.prototype.negate = function () {
        if (this.denom.isNegative()) {
            return new BigRational(this.num, this.denom.negate());
        }
        return new BigRational(this.num.negate(), this.denom);
    };
    BigRational.prototype.isNegative = function () {
        return this.num.isNegative() !== this.denom.isNegative() && !this.num.isZero();
    };
    BigRational.prototype.isPositive = function () {
        return this.num.isNegative() === this.denom.isNegative() && !this.num.isZero();
    };
    BigRational.prototype.isZero = function () {
        return this.num.isZero();
    };

    BigRational.prototype.toDecimal = function (digits) {
        digits = typeof digits === "number" ? digits : 10;
        var n = this.num.divmod(this.denom);
        var intPart = n.quotient.abs().toString();
        var remainder = parse(n.remainder.abs(), this.denom);
        var shiftedRemainder = remainder.times(bigInt("1e" + digits));
        var decPart = shiftedRemainder.num.over(shiftedRemainder.denom).toString();
        if (decPart.length < digits) {
            decPart = new Array(digits - decPart.length + 1).join("0") + decPart;
        }
        if (shiftedRemainder.num.mod(shiftedRemainder.denom).isZero()) {
            while (decPart.slice(-1) === "0") {
                decPart = decPart.slice(0, -1);
            }
        }
        if (digits < 1) decPart = "";
        if (this.isNegative()) {
            intPart = "-" + intPart;
        }
        if (decPart === "") {
            return intPart;
        }
        return intPart + "." + decPart;
    };

    BigRational.prototype.toString = function () {
        return String(this.num) + "/" + String(this.denom);
    };

    BigRational.prototype.valueOf = function () {
        if (!isFinite(+this.num) || !isFinite(+this.denom)) {
            return +this.toDecimal(64);
        }
        return this.num / this.denom;
    };

    function interpret(n, d) {
        return parse(n, d);
    }
    function parseDecimal(n) {
        var parts = n.split(/e/i);
        if (parts.length > 2) {
            throw new Error("Invalid input: too many 'e' tokens");
        }
        if (parts.length > 1) {
            var isPositive = true;
            if (parts[1][0] === "-") {
                parts[1] = parts[1].slice(1);
                isPositive = false;
            }
            if (parts[1][0] === "+") {
                parts[1] = parts[1].slice(1);
            }
            var significand = parseDecimal(parts[0]);
            var exponent = new BigRational(bigInt(10).pow(parts[1]), bigInt[1]);
            if (isPositive) {
                return significand.times(exponent);
            } else {
                return significand.over(exponent);
            }
        }
        parts = n.trim().split(".");
        if (parts.length > 2) {
            throw new Error("Invalid input: too many '.' tokens");
        }
        if (parts.length > 1) {
            var isNegative = parts[0][0] === '-';
            if (isNegative) parts[0] = parts[0].slice(1);
            var intPart = new BigRational(bigInt(parts[0]), bigInt[1]);
            var length = parts[1].length;
            while (parts[1][0] === "0") {
                parts[1] = parts[1].slice(1);
            }
            var exp = "1" + Array(length + 1).join("0");
            var decPart = reduce(bigInt(parts[1]), bigInt(exp));
            intPart = intPart.add(decPart);
            if (isNegative) intPart = intPart.negate();
            return intPart;
        }
        return new BigRational(bigInt(n), bigInt[1]);
    }
    function parse(a, b) {
        if (!a) {
            return new BigRational(bigInt(0), bigInt[1]);
        }
        if (b) {
            return reduce(bigInt(a), bigInt(b));
        }
        if (bigInt.isInstance(a)) {
            return new BigRational(a, bigInt[1]);
        }
        if (a instanceof BigRational) return a;

        var num;
        var denom;

        var text = String(a);
        var texts = text.split("/");
        if (texts.length > 2) {
            throw new Error("Invalid input: too many '/' tokens");
        }
        if (texts.length > 1) {
            var parts = texts[0].split("_");
            if (parts.length > 2) {
                throw new Error("Invalid input: too many '_' tokens");
            }
            if (parts.length > 1) {
                var isPositive = parts[0][0] !== "-";
                num = bigInt(parts[0]).times(texts[1]);
                if (isPositive) {
                    num = num.add(parts[1]);
                } else {
                    num = num.subtract(parts[1]);
                }
                denom = bigInt(texts[1]);
                return reduce(num, denom);
            }
            return reduce(bigInt(texts[0]), bigInt(texts[1]));
        }
        return parseDecimal(text);
    }

    parse.zero = parse(0);
    parse.one = parse(1);
    parse.minusOne = parse(-1);

    return parse;
})(typeof bigInt !== "undefined" ? bigInt : BigInteger);
{
    if (module.hasOwnProperty("exports")) {
        module.exports = bigRat;
    }
}
});

/**
 * @source: https://www.npmjs.com/package/@kkitahara/real-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @typedef {number|Polynomial} RealAlgebraicElement
 *
 * @desc
 * A RealAlgebraicElement denotes a {@link number}
 * or a {@link Polynomial} as follows.
 * * A {@link number} for the numerical algebra (see {@link RealAlgebra}).
 * * A {@link Polynomial} for the exact algebra (see {@link ExactRealAlgebra}).
 */

/**
 * @desc
 * The RealAlgebra class is a reference (numerical) implementation of
 * general classes for real algebra.
 * It uses built-in {@link number}s as {@link RealAlgebraicElement}s.
 *
 * @version 1.0.0
 * @since 1.0.0
 *
 * @example
 * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
 * let ralg = new RealAlgebra()
 * let a, b, c
 *
 * // generate a new number
 * a = ralg.num(1, 2, 5)
 * a.toString() // '(1 / 2)sqrt(5)'
 *
 * a = ralg.num(1, 2)
 * a.toString() // '1 / 2'
 *
 * a = ralg.num(3)
 * a.toString() // '3'
 *
 * // generate a new number (short form, since v1.2.0)
 * a = ralg.$(1, 2, 5)
 * a.toString() // '(1 / 2)sqrt(5)'
 *
 * a = ralg.$(1, 2)
 * a.toString() // '1 / 2'
 *
 * a = ralg.$(3)
 * a.toString() // '3'
 *
 * // copy (create a new object)
 * a = ralg.num(1, 2, 5)
 * b = ralg.copy(a)
 * b.toString() // '(1 / 2)sqrt(5)'
 *
 * // equality
 * a = ralg.num(1, 2, 5)
 * b = ralg.num(3, 2, 5)
 * ralg.eq(a, b) // false
 *
 * b = ralg.num(1, 2, 5)
 * ralg.eq(a, b) // true
 *
 * // inequality
 * a = ralg.num(1, 2, 5)
 * b = ralg.num(3, 2, 5)
 * ralg.ne(a, b) // true
 *
 * b = ralg.num(1, 2, 5)
 * ralg.ne(a, b) // false
 *
 * // isZero
 * ralg.isZero(ralg.num(0)) // true
 * ralg.isZero(ralg.num(1, 2, 5)) // false
 * ralg.isZero(ralg.num(-1, 2, 5)) // false
 *
 * // isPositive
 * ralg.isPositive(ralg.num(0)) // false
 * ralg.isPositive(ralg.num(1, 2, 5)) // true
 * ralg.isPositive(ralg.num(-1, 2, 5)) // false
 *
 * // isNegative
 * ralg.isNegative(ralg.num(0)) // false
 * ralg.isNegative(ralg.num(1, 2, 5)) // false
 * ralg.isNegative(ralg.num(-1, 2, 5)) // true
 *
 * // isInteger (since v1.1.0)
 * ralg.isInteger(ralg.num(0)) // true
 * ralg.isInteger(ralg.num(6, 3)) // true
 * ralg.isInteger(ralg.num(1, 2)) // false
 * ralg.isInteger(ralg.num(2, 1, 3)) // false
 *
 * // addition
 * a = ralg.num(1, 2, 5)
 * b = ralg.num(1, 2, 1)
 * // new object is generated
 * c = ralg.add(a, b)
 * c.toString() // '1 / 2 + (1 / 2)sqrt(5)'
 *
 * // in-place addition
 * a = ralg.num(1, 2, 5)
 * b = ralg.num(1, 2, 1)
 * // new object is not generated
 * a = ralg.iadd(a, b)
 * a.toString() // '1 / 2 + (1 / 2)sqrt(5)'
 *
 * // subtraction
 * a = ralg.num(1, 2, 5)
 * b = ralg.num(1, 2, 1)
 * // new object is generated
 * c = ralg.sub(a, b)
 * c.toString() // '-1 / 2 + (1 / 2)sqrt(5)'
 *
 * // in-place subtraction
 * a = ralg.num(1, 2, 5)
 * b = ralg.num(1, 2, 1)
 * // new object is not generated
 * a = ralg.isub(a, b)
 * a.toString() // '-1 / 2 + (1 / 2)sqrt(5)'
 *
 * // multiplication
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(1, 2, 5))
 * b = ralg.iadd(ralg.num(-1, 2), ralg.num(1, 2, 5))
 * // new object is generated
 * c = ralg.mul(a, b)
 * c.toString() // '1'
 *
 * // in-place multiplication
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(1, 2, 5))
 * b = ralg.iadd(ralg.num(-1, 2), ralg.num(1, 2, 5))
 * // new object is not generated
 * a = ralg.imul(a, b)
 * a.toString() // '1'
 *
 * // division
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(1, 2, 5))
 * b = ralg.iadd(ralg.num(-1, 2), ralg.num(1, 2, 5))
 * // new object is generated
 * c = ralg.div(a, b)
 * c.toString() // '3 / 2 + (1 / 2)sqrt(5)'
 *
 * // in-place division
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(1, 2, 5))
 * b = ralg.iadd(ralg.num(-1, 2), ralg.num(1, 2, 5))
 * // new object is not generated
 * a = ralg.idiv(a, b)
 * a.toString() // '3 / 2 + (1 / 2)sqrt(5)'
 *
 * // multiplication by -1
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(1, 2, 5))
 * // new object is generated
 * b = ralg.neg(a)
 * b.toString() // '-1 / 2 - (1 / 2)sqrt(5)'
 *
 * // in-place multiplication by -1
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(1, 2, 5))
 * // new object is not generated
 * a = ralg.ineg(a)
 * a.toString() // '-1 / 2 - (1 / 2)sqrt(5)'
 *
 * // absolute value
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(-1, 2, 5))
 * // new object is generated
 * b = ralg.abs(a)
 * b.toString() // '-1 / 2 + (1 / 2)sqrt(5)'
 *
 * // in-place evaluation of the absolute value
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(-1, 2, 5))
 * // new object is not generated
 * a = ralg.iabs(a)
 * a.toString() // '-1 / 2 + (1 / 2)sqrt(5)'
 *
 * // JSON (stringify and parse)
 * a = ralg.iadd(ralg.num(1, 2), ralg.num(1, 2, 5))
 * let str = JSON.stringify(a)
 * b = JSON.parse(str, ralg.reviver)
 * ralg.eq(a, b) // true
 *
 * @example
 * import { RealAlgebra } from '@kkitahara/real-algebra'
 * let ralg = new RealAlgebra()
 *
 * let a = ralg.num(1, 2)
 * let b = ralg.num(1, 3)
 * ralg.eq(a, b) // false
 * ralg.isZero(ralg.num(1, 999999)) // false
 *
 * @example
 * import { RealAlgebra } from '@kkitahara/real-algebra'
 * let eps = 0.5
 * let ralg = new RealAlgebra(eps)
 *
 * let a = ralg.num(1, 2)
 * let b = ralg.num(1, 3)
 * ralg.eq(a, b) // true
 * ralg.isZero(ralg.num(1, 2)) // true
 * ralg.isZero(ralg.num(2, 3)) // false
 */
class RealAlgebra {
  /**
   * @desc
   * The constructor function of the {@link RealAlgebra} class.
   * The parameter `eps` is only for numerical algebra.
   *
   * @param {number} [eps = 0]
   * a non-negative {@link number}.
   *
   * @throws {Error}
   * if `eps` is not a {@link number}.
   *
   * @throws {Error}
   * if `eps` is negative.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   *
   * // parameter must be a number
   * new RealAlgebra(null) // Error
   *
   * // parameter must not be a negative number
   * new RealAlgebra(-0.1) // Error
   */
  constructor (eps = 0) {
    if (typeof eps !== 'number') {
      throw Error('type of `eps` must be `number`.')
    }
    if (eps < 0) {
      throw Error('`eps` must not be negative.')
    }
    /**
     * @desc
     * If the difference between two {@link number}s are
     * smaller than or equal to {@link RealAlgebra#eps},
     * then the two {@link number}s are considered to be equal.
     * It is only for numerical algebra.
     *
     * @type {number}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.eps = eps;
  }

  /**
   * @desc
   * The RealAlgebra#ralg method returns `this`.
   *
   * @type {RealAlgebra}
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   *
   * let ralg = new RealAlgebra()
   *
   * ralg.ralg === ralg // true
   */
  get ralg () {
    return this
  }

  /**
   * @desc
   * The RealAlgebra#num method returns
   * a {@link RealAlgebraicElement} representing
   * (*p* / *q*)sqrt(*b*),
   * where *p* is an integer, *q* is a non-zero integer,
   * and *b* is a positive, square-free integer.
   *
   * CAUTION: this method does not check if `b` is square-free.
   *
   * @param {number} [p = 0]
   * an integer.
   *
   * @param {number} [q = 1]
   * a non-zero integer (can be negative).
   *
   * @param {number} [b = 1]
   * a positive, square-free integer.
   *
   * @return {RealAlgebraicElement}
   * a {@link RealAlgebraicElement} representing `(p / q)sqrt(b)`.
   *
   * @throws {Error}
   * if `q` is zero.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra, Monomial as M, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.num(2, 3, 2) === 2 / 3 * Math.sqrt(2) // true
   * ralg.num(2, 3) === 2 / 3 // true
   * ralg.num(2) === 2 // true
   * ralg.num() === 0 // true
   * ralg.num(2, 0) // Error
   * ralg.num(2, 3, -2) // Error
   *
   * let a = eralg.num(2, 3, 2)
   * a instanceof P // true
   * a.equals(new P(new M(2, 3, 2))) // true
   * eralg.num(2, 3).equals(new P(new M(2, 3))) // true
   * eralg.num(2).equals(new P(new M(2))) // true
   * eralg.num().equals(new P(new M(0))) // true
   * eralg.num(2, 0) // Error
   * eralg.num(2, 3, -2) // Error
   */
  num (p = 0, q = 1, b = 1) {
    if (q === 0) {
      throw Error('`q` must be non-zero.')
    } else if (b < 0) {
      throw Error('`b` must not be negative.')
    }
    return p / q * Math.sqrt(b)
  }

  /**
   * @desc
   * The RealAlgebra#$ method is an alias for the RealAlgebra#num.
   *
   * @param {number} [p = 0]
   * an integer.
   *
   * @param {number} [q = 1]
   * a non-zero integer (can be negative).
   *
   * @param {number} [b = 1]
   * a positive, square-free integer.
   *
   * @return {RealAlgebraicElement}
   * a {@link RealAlgebraicElement} representing `(p / q)sqrt(b)`.
   *
   * @version 1.2.0
   * @since 1.2.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra, Monomial as M, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let r = new RealAlgebra()
   * let er = new ExactRealAlgebra()
   *
   * r.$(2, 3, 2) === 2 / 3 * Math.sqrt(2) // true
   * r.$(2, 3) === 2 / 3 // true
   * r.$(2) === 2 // true
   * r.$() === 0 // true
   * r.$(2, 0) // Error
   * r.$(2, 3, -2) // Error
   *
   * let a = er.$(2, 3, 2)
   * a instanceof P // true
   * a.equals(new P(new M(2, 3, 2))) // true
   * er.$(2, 3).equals(new P(new M(2, 3))) // true
   * er.$(2).equals(new P(new M(2))) // true
   * er.$().equals(new P(new M(0))) // true
   * er.$(2, 0) // Error
   * er.$(2, 3, -2) // Error
   */
  $ (p = 0, q = 1, b = 1) {
    return this.num(p, q, b)
  }

  /**
   * @desc
   * The RealAlgebra#cast method just returns
   * `a` if `a` is a valid {@link RealAlgebraicElement}
   * and otherwise casts `a` to a valid {@link RealAlgebraicElement}.
   *
   * @param {object} [a = 0]
   * an object.
   *
   * @return {RealAlgebraicElement}
   * `a` or a new {@link RealAlgebraicElement}.
   *
   * @version 1.2.1
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.cast() // 0
   * ralg.cast(1) // 1
   * ralg.cast(true) // 1
   * ralg.cast(false) // 0
   *
   * let a = eralg.num(1)
   * let b = a
   * b === eralg.cast(a) // true
   * eralg.cast(1) instanceof P // true
   * b === eralg.cast(1) // false
   * eralg.eq(b, eralg.cast(1)) // true
   * eralg.eq(eralg.cast(), 0) // true
   */
  cast (a = 0) {
    return a + 0
  }

  /**
   * @desc
   * The RealAlgebra#copy method returns a copy of `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a copy of `a`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let eralg = new ExactRealAlgebra()
   *
   * // copy does not work for numerical algebra
   * let a = ralg.num(1, 2)
   * ralg.copy(a) === a // true
   *
   * let b = eralg.num(1, 2)
   * let c = eralg.copy(b)
   * b === c // false
   * b.equals(c) // true
   */
  copy (a) {
    return a + 0
  }

  /**
   * @desc
   * The RealAlgebra#eq method checks if `a` is equal to `b`.
   * In the case of numerical algebra,
   * `a` is considered to be equal to `b` if the difference is smaller than
   * or equal to {@link RealAlgebra#eps}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `a` is equal to `b` and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let ralg2 = new RealAlgebra(0.5)
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.eq(ralg.num(1, 2), ralg.num(1, 2)) // true
   * ralg.eq(ralg.num(1, 2), ralg.num(2, 3)) // false
   *
   * // Equality can be controlled
   * ralg2.eq(ralg2.num(1, 2), ralg2.num(1, 2)) // true
   * ralg2.eq(ralg2.num(1, 2), ralg2.num(2, 3)) // true
   *
   * eralg.eq(eralg.num(1, 2), eralg.num(1, 2)) // true
   * eralg.eq(eralg.num(1, 2), eralg.num(2, 3)) // false
   */
  eq (a, b) {
    return Math.abs(a - b) <= this.eps
  }

  /**
   * @desc
   * The RealAlgebra#ne method checks if `a` is not equal to `b`.
   *
   * `ralg.ne(a, b)` is an alias for `!ralg.eq(a, b)`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `a` is not equal to `b` and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let ralg2 = new RealAlgebra(0.5)
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.ne(ralg.num(1, 2), ralg.num(1, 2)) // false
   * ralg.ne(ralg.num(1, 2), ralg.num(2, 3)) // true
   *
   * // Equality can be controlled
   * ralg2.ne(ralg2.num(1, 2), ralg2.num(1, 2)) // false
   * ralg2.ne(ralg2.num(1, 2), ralg2.num(2, 3)) // false
   *
   * eralg.ne(eralg.num(1, 2), eralg.num(1, 2)) // false
   * eralg.ne(eralg.num(1, 2), eralg.num(2, 3)) // true
   */
  ne (a, b) {
    return !this.eq(a, b)
  }

  /**
   * @desc
   * The RealAlgebra#isZero method checks if `a` is zero.
   * In the case of numerical algebra,
   * `a` is considered to be equal to zero if the absolute value of
   * `a` is smaller than or equal to {@link RealAlgebra#eps}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `a` is zero and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let ralg2 = new RealAlgebra(0.5)
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.isZero(ralg.num(-0, 2)) // true
   * ralg.isZero(ralg.num(0, 2)) // true
   * ralg.isZero(ralg.num(1, 2)) // false
   * ralg.isZero(ralg.num(-1, 2)) // false
   *
   * // Equality can be controlled
   * ralg2.isZero(ralg2.num(-0, 2)) // true
   * ralg2.isZero(ralg2.num(0, 2)) // true
   * ralg2.isZero(ralg2.num(1, 2)) // true
   * ralg2.isZero(ralg2.num(-1, 2)) // true
   *
   * eralg.isZero(eralg.num(0, 2)) // true
   * eralg.isZero(eralg.num(-0, 2)) // true
   * eralg.isZero(eralg.num(1, 2)) // false
   * eralg.isZero(eralg.num(-1, 2)) // false
   */
  isZero (a) {
    return Math.abs(a) <= this.eps
  }

  /**
   * @desc
   * The {@link RealAlgebra#isPositive} method checks
   * if `a` is positive (non-zero).
   * In the case of numerical algebra,
   * `a` is considered to be positive (non-zero) if
   * `a` is greater than {@link RealAlgebra#eps}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `a` is positive (non-zero) and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let ralg2 = new RealAlgebra(0.5)
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.isPositive(ralg.num(-0, 2)) // false
   * ralg.isPositive(ralg.num(0, 2)) // false
   * ralg.isPositive(ralg.num(1, 2)) // true
   * ralg.isPositive(ralg.num(-1, 2)) // false
   *
   * // Equality can be controlled
   * ralg2.isPositive(ralg2.num(-0, 2)) // false
   * ralg2.isPositive(ralg2.num(0, 2)) // false
   * ralg2.isPositive(ralg2.num(1, 2)) // false
   * ralg2.isPositive(ralg2.num(-1, 2)) // false
   *
   * eralg.isPositive(eralg.num(0, 2)) // false
   * eralg.isPositive(eralg.num(-0, 2)) // false
   * eralg.isPositive(eralg.num(1, 2)) // true
   * eralg.isPositive(eralg.num(-1, 2)) // false
   */
  isPositive (a) {
    return a > this.eps
  }

  /**
   * @desc
   * The RealAlgebra#isNegative method checks
   * if `a` is negative (non-zero).
   *
   * `ralg.isNegative(a)` is an alias for
   * `!(ralg.isZero(a) || ralg.isPositive(a))`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `a` is negative (non-zero) and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let ralg2 = new RealAlgebra(0.5)
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.isNegative(ralg.num(-0, 2)) // false
   * ralg.isNegative(ralg.num(0, 2)) // false
   * ralg.isNegative(ralg.num(1, 2)) // false
   * ralg.isNegative(ralg.num(-1, 2)) // true
   *
   * // Equality can be controlled
   * ralg2.isNegative(ralg2.num(-0, 2)) // false
   * ralg2.isNegative(ralg2.num(0, 2)) // false
   * ralg2.isNegative(ralg2.num(1, 2)) // false
   * ralg2.isNegative(ralg2.num(-1, 2)) // false
   *
   * eralg.isNegative(eralg.num(0, 2)) // false
   * eralg.isNegative(eralg.num(-0, 2)) // false
   * eralg.isNegative(eralg.num(1, 2)) // false
   * eralg.isNegative(eralg.num(-1, 2)) // true
   */
  isNegative (a) {
    return !(this.isZero(a) || this.isPositive(a))
  }

  /**
   * @desc
   * The RealAlgebra#isInteger method checks
   * if `a` is an integer.
   * `a` is considered to be an integer if
   * the difference between `a` and its nearest integer is
   * smaller than or equal to {@link RealAlgebra#eps}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `a` is considered to be an integer and `false` otherwise.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let ralg2 = new RealAlgebra(0.5)
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.isInteger(ralg.num(6, 3)) // true
   * ralg.isInteger(ralg.num(6, 3, 2)) // false
   * ralg.isInteger(ralg.num(-0, 2)) // true
   * ralg.isInteger(ralg.num(0, 2)) // true
   * ralg.isInteger(ralg.num(1, 3)) // false
   * ralg.isInteger(ralg.num(-1, 3)) // false
   * ralg.isInteger(ralg.num(1, 3, 0)) // true
   *
   * // Equality can be controlled
   * ralg2.isInteger(ralg2.num(6, 3)) // true
   * ralg2.isInteger(ralg2.num(6, 3, 2)) // true
   * ralg2.isInteger(ralg2.num(-0, 2)) // true
   * ralg2.isInteger(ralg2.num(0, 2)) // true
   * ralg2.isInteger(ralg2.num(1, 3)) // true
   * ralg2.isInteger(ralg2.num(-1, 3)) // true
   * ralg2.isInteger(ralg2.num(1, 3, 0)) // true
   *
   * eralg.isInteger(eralg.num(6, 3)) // true
   * eralg.isInteger(eralg.num(6, 3, 2)) // false
   * eralg.isInteger(eralg.num(0, 2)) // true
   * eralg.isInteger(eralg.num(-0, 2)) // true
   * eralg.isInteger(eralg.num(1, 3)) // false
   * eralg.isInteger(eralg.num(-1, 3)) // false
   * eralg.isInteger(eralg.num(1, 3, 0)) // true
   */
  isInteger (a) {
    return this.isZero(Math.abs(a - Math.round(a)))
  }

  /**
   * @desc
   * The RealAlgebra#isFinite method checks if `a` is finite.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `a` is finite and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * import bigInt from 'big-integer'
   * let ralg = new RealAlgebra()
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.isFinite(ralg.num(1, 2)) // true
   * ralg.isFinite(ralg.num(1e999, 2)) // false
   *
   * eralg.isFinite(eralg.num(1, 2)) // true
   * eralg.isFinite(eralg.num(bigInt('1e999'), 2)) // true
   */
  isFinite (a) {
    return Number.isFinite(a + 0)
  }

  /**
   * @desc
   * The RealAlgebra#isExact method checks
   * if `this` is an implementation of exact algebra.
   *
   * @return {boolean}
   * `true` if `this` is an exact algebra and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.isExact() // false
   * eralg.isExact() // true
   */
  isExact () {
    return false
  }

  /**
   * @desc
   * The RealAlgebra#isReal method checks
   * if `this` is an implementation of real algebra.
   *
   * @return {boolean}
   * `true`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let eralg = new ExactRealAlgebra()
   *
   * ralg.isReal() // true
   * eralg.isReal() // true
   */
  isReal () {
    return true
  }

  /**
   * @desc
   * The RealAlgebra#add method returns the result of the addition `a` plus `b`.
   *
   * `ralg.add(a, b)` is an alias for `ralg.iadd(ralg.copy(a), b)`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the result of the addition `a` plus `b`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.add(a, b)
   * typeof c === 'number' // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(3, 4)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.add(a, b)
   * typeof c === 'number' // false
   * c instanceof P // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(3, 4)) // true
   */
  add (a, b) {
    return this.iadd(this.copy(a), b)
  }

  /**
   * @desc
   * The RealAlgebra#iadd method adds `b` to `a` *in place*.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.iadd(a, b)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or a new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.iadd(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(3, 4)) // false
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // GOOD-PRACTICE!
   * a = ralg.iadd(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(3, 4)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   * let c = a
   *
   * // GOOD-PRACTICE!
   * a = ralg.iadd(a, b)
   * a === c // true
   * typeof a === 'number' // false
   * a instanceof P // true
   * ralg.eq(a, ralg.num(3, 4)) // true
   * ralg.eq(c, ralg.num(3, 4)) // true
   */
  iadd (a, b) {
    a += b;
    return a
  }

  /**
   * @desc
   * The RealAlgebra#sub method returns the result of
   * the subtraction `a` minus `b`.
   *
   * `ralg.sub(a, b)` is an alias for `ralg.isub(ralg.copy(a), b)`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the result of the subtraction `a` minus `b`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.sub(a, b)
   * typeof c === 'number' // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(1, 4)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.sub(a, b)
   * typeof c === 'number' // false
   * c instanceof P // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(1, 4)) // true
   */
  sub (a, b) {
    return this.isub(this.copy(a), b)
  }

  /**
   * @desc
   * The RealAlgebra#isub method subtracts `b` from `a` *in place*.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.isub(a, b)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.isub(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 4)) // false
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // GOOD-PRACTICE!
   * a = ralg.isub(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 4)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   * let c = a
   *
   * // GOOD-PRACTICE!
   * a = ralg.isub(a, b)
   * a === c // true
   * typeof a === 'number' // false
   * a instanceof P // true
   * ralg.eq(a, ralg.num(1, 4)) // true
   * ralg.eq(c, ralg.num(1, 4)) // true
   */
  isub (a, b) {
    a -= b;
    return a
  }

  /**
   * @desc
   * The RealAlgebra#mul method returns the result of
   * the multiplication `a` times `b`.
   *
   * `ralg.mul(a, b)` is an alias for `ralg.imul(ralg.copy(a), b)`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the result of the multiplication `a` times `b`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.mul(a, b)
   * typeof c === 'number' // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(1, 8)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.mul(a, b)
   * typeof c === 'number' // false
   * c instanceof P // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(1, 8)) // true
   */
  mul (a, b) {
    return this.imul(this.copy(a), b)
  }

  /**
   * @desc
   * The RealAlgebra#imul method multiplies `a` by `b` *in place*.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.imul(a, b)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or a new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.imul(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 8)) // false
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // GOOD-PRACTICE!
   * a = ralg.imul(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 8)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   * let c = a
   *
   * // GOOD-PRACTICE!
   * a = ralg.imul(a, b)
   * a === c // true
   * typeof a === 'number' // false
   * a instanceof P // true
   * ralg.eq(a, ralg.num(1, 8)) // true
   * ralg.eq(c, ralg.num(1, 8)) // true
   */
  imul (a, b) {
    a *= b;
    return a
  }

  /**
   * @desc
   * The RealAlgebra#div method returns the result of the division `a` over `b`.
   *
   * `ralg.div(a, b)` is an alias for `ralg.idiv(ralg.copy(a), b)`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the result of the division `a` over `b`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.div(a, b)
   * typeof c === 'number' // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * let c = ralg.div(a, b)
   * typeof c === 'number' // false
   * c instanceof P // true
   * c !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(2)) // true
   */
  div (a, b) {
    return this.idiv(this.copy(a), b)
  }

  /**
   * @desc
   * The RealAlgebra#idiv method divides `a` by `b` *in place*.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.idiv(a, b)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or a new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.idiv(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(2)) // false
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   *
   * // GOOD-PRACTICE!
   * a = ralg.idiv(a, b)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(1, 4)
   * let c = a
   *
   * // GOOD-PRACTICE!
   * a = ralg.idiv(a, b)
   * a === c // true
   * typeof a === 'number' // false
   * a instanceof P // true
   * ralg.eq(a, ralg.num(2)) // true
   * ralg.eq(c, ralg.num(2)) // true
   */
  idiv (a, b) {
    a /= b;
    return a
  }

  /**
   * @desc
   * The RealAlgebra#neg method returns the result of
   * the multiplication `a` times `-1`.
   *
   * `ralg.neg(a)` is an alias for `ralg.ineg(ralg.copy(a))`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the result of the multiplication `a` times `-1`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * let b = ralg.neg(a)
   * typeof b === 'number' // true
   * b !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(-1, 2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * let b = ralg.neg(a)
   * typeof b === 'number' // false
   * b instanceof P // true
   * b !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(-1, 2)) // true
   */
  neg (a) {
    return this.ineg(this.copy(a))
  }

  /**
   * @desc
   * The RealAlgebra#ineg method multiplies `a` by `-1` *in place*.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.ineg(a)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or a new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.ineg(a)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(-1, 2)) // false
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * // GOOD-PRACTICE!
   * a = ralg.ineg(a)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(-1, 2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = a
   *
   * // GOOD-PRACTICE!
   * a = ralg.ineg(a)
   * a === b // true
   * typeof a === 'number' // false
   * a instanceof P // true
   * ralg.eq(a, ralg.num(-1, 2)) // true
   * ralg.eq(b, ralg.num(-1, 2)) // true
   */
  ineg (a) {
    a = -a;
    return a
  }

  /**
   * @desc
   * The RealAlgebra#cjg method returns the complex conjugate of `a`.
   *
   * `ralg.cjg(a)` is an alias for `ralg.icjg(ralg.copy(a))`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the complex conjugate of `a`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * let b = ralg.cjg(a)
   * typeof b === 'number' // true
   * b !== a // false
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(1, 2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * let b = ralg.cjg(a)
   * typeof b === 'number' // false
   * b instanceof P // true
   * b !== a // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(1, 2)) // true
   */
  cjg (a) {
    return this.icjg(this.copy(a))
  }

  /**
   * @desc
   * The RealAlgebra#icjg method
   * evaluates the complex conjugate of `a` and stores the result to `a`.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.icjg(a)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or a new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.icjg(a)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   *
   * // GOOD-PRACTICE!
   * a = ralg.icjg(a)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = a
   *
   * // GOOD-PRACTICE!
   * a = ralg.icjg(a)
   * a === b // true
   * typeof a === 'number' // false
   * a instanceof P // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(1, 2)) // true
   */
  icjg (a) {
    return a + 0
  }

  /**
   * @desc
   * The RealAlgebra#abs method returns the absolute value of `a`.
   *
   * `ralg.abs(a)` is an alias for `ralg.iabs(ralg.copy(a))`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the absolute value of `a`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(-1, 2)
   *
   * let c = ralg.abs(a)
   * let d = ralg.abs(b)
   * typeof c === 'number' // true
   * typeof d === 'number' // true
   * c !== a // false
   * d !== b // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(-1, 2)) // true
   * ralg.eq(d, ralg.num(1, 2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(-1, 2)
   *
   * let c = ralg.abs(a)
   * let d = ralg.abs(b)
   * typeof c === 'number' // false
   * typeof d === 'number' // false
   * c instanceof P // true
   * d instanceof P // true
   * c !== a // true
   * d !== b // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(c, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(-1, 2)) // true
   * ralg.eq(d, ralg.num(1, 2)) // true
   */
  abs (a) {
    return this.iabs(this.copy(a))
  }

  /**
   * @desc
   * The RealAlgebra#iabs method multiplies `a` by `-1` *in place*
   * if `a` is negative.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.iabs(a)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or a new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(-1, 2)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.iabs(a)
   * ralg.iabs(b)
   * typeof a === 'number' // true
   * typeof b === 'number' // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(1, 2)) // false
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(-1, 2)
   *
   * // GOOD-PRACTICE!
   * a = ralg.iabs(a)
   * b = ralg.iabs(b)
   * typeof a === 'number' // true
   * typeof b === 'number' // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(1, 2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2)
   * let b = ralg.num(-1, 2)
   * let c = a
   * let d = b
   *
   * // GOOD-PRACTICE!
   * a = ralg.iabs(a)
   * b = ralg.iabs(b)
   * a === c // true
   * b === d // true
   * typeof a === 'number' // false
   * typeof b === 'number' // false
   * a instanceof P // true
   * b instanceof P // true
   * ralg.eq(a, ralg.num(1, 2)) // true
   * ralg.eq(b, ralg.num(1, 2)) // true
   */
  iabs (a) {
    a = Math.abs(a);
    return a
  }

  /**
   * @desc
   * The RealAlgebra#abs2 method returns
   * the square of the absolute value of `a`.
   *
   * `ralg.abs2(a)` is an alias for `ralg.mul(a, a)`,
   * where `ralg` is an instance of {@link RealAlgebra}.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a new {@link RealAlgebraicElement}
   * representing the square of the absolute value of `a`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(-1, 2)
   *
   * let b = ralg.abs2(a)
   * typeof b === 'number' // true
   * b !== a // true
   * ralg.eq(a, ralg.num(-1, 2)) // true
   * ralg.eq(b, ralg.num(1, 4)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(-1, 2)
   *
   * let b = ralg.abs2(a)
   * typeof b === 'number' // false
   * b instanceof P // true
   * b !== a // true
   * ralg.eq(a, ralg.num(-1, 2)) // true
   * ralg.eq(b, ralg.num(1, 4)) // true
   */
  abs2 (a) {
    return this.mul(a, a)
  }

  /**
   * @desc
   * The RealAlgebra#iabs2 method multiplies `a` by `a` *in place*.
   *
   * Since the in-place operation does not work for built-in {@link number}s,
   * use this method like `a = ralg.iabs2(a)`,
   * where `ralg` is an instance of {@link RealAlgebra},
   * if the result should be stored in `a`.
   *
   * `ralg.iabs2(a)` is an alias for `ralg.imul(a, a)`.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * `a`, or a new {@link RealAlgebraicElement} if `a` is not a valid
   * {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(-1, 2)
   *
   * // In-place operation does not work for built-in numbers
   * // ANTI-PATTERN!
   * ralg.iabs2(a)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 4)) // false
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(-1, 2)
   *
   * // GOOD-PRACTICE!
   * a = ralg.iabs2(a)
   * typeof a === 'number' // true
   * ralg.eq(a, ralg.num(1, 4)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(-1, 2)
   * let b = a
   *
   * // GOOD-PRACTICE!
   * a = ralg.iabs2(a)
   * a === b // true
   * typeof a === 'number' // false
   * a instanceof P // true
   * ralg.eq(a, ralg.num(1, 4)) // true
   * ralg.eq(b, ralg.num(1, 4)) // true
   */
  iabs2 (a) {
    a = this.imul(a, a);
    return a
  }

  /**
   * @desc
   * The reviver function for the {@link RealAlgebraicElement}s.
   *
   * @param {object} key
   *
   * @param {object} value
   *
   * @return {RealAlgebraicElement|Object}
   * a {@link RealAlgebraicElement} or `value`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra, ExactRealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   * let eralg = new ExactRealAlgebra()
   *
   * let a = ralg.num(1, 2, 3)
   * let s = JSON.stringify(a)
   * let b = JSON.parse(s, ralg.reviver)
   *
   * typeof s // 'string'
   * ralg.eq(a, b) // true
   * a === b // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.num(1, 2, 3)
   * let s = JSON.stringify(a)
   * let b = JSON.parse(s, ralg.reviver)
   *
   * typeof s // 'string'
   * ralg.eq(a, b) // true
   * a === b // false
   */
  reviver (key, value) {
    return value
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/linear-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @typedef {RealAlgebraicElement|ComplexAlgebraicElement}
 * ScalarAlgebraicElement
 *
 * @desc
 * A ScalarAlgebraicElement denotes a {@link RealAlgebraElement}
 * (see @kkitahara/real-algebra) or a {@link ComplexAlgebraElement}
 * (see @kkitahara/complex-algebra).
 */

/**
 * @desc
 * The Matrix class is a class for matrices and vectors.
 *
 * The elements are considered to be stored in row-major order.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class Matrix extends Array {
  /**
   * @desc
   * The constructor function of the {@link Matrix} class.
   *
   * CAUTION: this constructor function does not check if `args`
   * are valid {@link ScalarAlgebraicElement}s.
   *
   * @param {...ScalarAlgebraicElement} args
   * instances of a {@link ScalarAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(3)
   * a instanceof M // true
   * a.length === 1 // true
   * a[0] === 3 // true
   * a.nRow === 0 // true
   * a.nCol === 0 // true
   *
   * let b = new M(1, 2, 3)
   * b instanceof M // true
   * b.length === 3 //true
   * b[0] === 1 // true
   * b[1] === 2 // true
   * b[2] === 3 // true
   * b.nRow === 0 // true
   * b.nCol === 0 // true
   */
  constructor (...args) {
    if (args.length === 1) {
      super();
      this.push(args[0]);
    } else {
      super(...args);
    }
    /**
     * @desc
     * Matrix#nRow stores the number of the rows.
     * If {@link Matrix#nRow} is 0,
     * the number o the rows is automatically determined.
     * by {@link Matrix#getNRow}.
     *
     * You can use {@link Matrix#setDim} to set this parameter.
     *
     * @type {number}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.nRow = 0; // 0 means auto
    /**
     * @desc
     * Matrix#nCol stores the number of the columns.
     * If {@link Matrix#nCol} is 0,
     * the number o the columns is automatically determined
     * by {@link Matrix#getNCol}.
     *
     * You can use {@link Matrix#setDim} to set this parameter.
     *
     * @type {number}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.nCol = 0; // 0 means auto
    /**
     * @desc
     * Matrix#permutation is used if `this` is LU-factorised.
     *
     * @type {Array}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.permutation = null;
  }

  /**
   * @desc
   * Thanks to this species, built-in {@link Array} methods,
   * such as the {@link Matrix}#slice method,
   * return an {@link Array} object.
   *
   * @type {function}
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4, 5)
   * let b = a.slice()
   *
   * a.length === 5 // true
   * b.length === 5 // true
   * a === b // false
   * a.constructor === M // true
   * b.constructor === M // false
   * b.constructor === Array // true
   */
  static get [Symbol.species] () {
    return Array
  }

  /**
   * @desc
   * The Matrix#setDim method sets
   * the values of {@link Matrix#nRow} and {@link Matrix#nCol}
   * and return `this`.
   *
   * Automatic dimension determination:
   * let `this` be an instance of {@link Matrix},
   * - if both `this.nRow` and `this.nCol` are `0` and `this.length` is not `1`,
   * the dimension of `this` is adaptive, changes depending on context.
   * - if `this.nRow` is not `0` and `this.nCol` is `0`,
   * `this.nCol` is considered to be equal to
   * `Math.round(this.length / this.nRow)`,
   * - and if `this.nCol` is not `0` and `this.nRow` is `0`,
   * `this.nRow` is considered to be equal to
   * `Math.round(this.length / this.nCol)`,
   * - if `this.nRow` and `this.nCol` are `0`, and `this.length` is `1`,
   * `this` is a 1 x 1 matrix.
   *
   * If `nRow * nCol` (after auto-determination) is
   * not equal to the length of the matrix when a method is called,
   * the method throws an Error.
   *
   * The default values are `0` for both {@link Matrix#nRow}
   * and {@link Matrix#nCol}.
   *
   * @param {number} [nRow = 0]
   * a non-negative integer.
   *
   * @param {number} [nCol = 0]
   * a non-negative integer.
   *
   * @return {Matrix}
   * `this`.
   *
   * @throws {Error}
   * if `nRow` or `nCol` is not a non-negative integer.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4).setDim(2, 2)
   * a.nRow === 2 // true
   * a.nCol === 2 // true
   *
   * a.setDim(1, 2)
   * a.nRow === 1 // true
   * a.nCol === 2 // true
   *
   * a.setDim(-2, 2) // Error
   * a.setDim(2, -2) // Error
   * a.setDim(null, 2) // Error
   * a.setDim(2, null) // Error
   * a.setDim(2.1, 2) // Error
   * a.setDim(2, 2.1) // Error
   */
  setDim (nRow = 0, nCol = 0) {
    if (typeof nRow !== 'number' || !Number.isInteger(nRow) || nRow < 0) {
      throw Error('nRow must be a non-negative integer.')
    }
    if (typeof nCol !== 'number' || !Number.isInteger(nCol) || nCol < 0) {
      throw Error('nCol must be a non-negative integer.')
    }
    this.nRow = nRow;
    this.nCol = nCol;
    return this
  }

  /**
   * @desc
   * The Matrix#isAdaptive method checks if `this` is adaptive.
   * `this` is considered to be adaptive if both `this.nRow`
   * and `this.nCol` are `0`.
   *
   * @return {boolean}
   * `true` if `this` is adaptive and `false` otherwise.
   *
   * @version 2.1.1
   * @since 2.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4)
   *
   * a.isAdaptive() // true
   *
   * a.setDim(1, 4)
   * a.isAdaptive() // false
   *
   * a.setDim(0, 0)
   * a.isAdaptive() // true
   *
   * a.setDim(0, 4)
   * a.isAdaptive() // false
   *
   * a.setDim()
   * a.isAdaptive() // true
   *
   * a = new M()
   * a.isAdaptive() // true
   */
  isAdaptive () {
    return this.nRow === 0 && this.nCol === 0
  }

  /**
   * @desc
   * The Matrix#getDim method returns the dimension
   * of `this` according to the rule of the automatic size determination.
   *
   * @param {Number} [nRow = 0]
   * used instead of `this.nRow` if `this` is adaptive.
   *
   * @param {Number} [nCol = 0]
   * used instead of `this.nCol` if `this` is adaptive.
   *
   * @return {Array}
   * an array containg the dimension of `this` like `[nRow, nCol]`.
   *
   * @throws {Error}
   * if `this` is considered to be a vector.
   *
   * @throws {Error}
   * if `nRow * nCol` is not equal to `this.length`.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4)
   *
   * a.setDim(1, 4)
   * let dim = a.getDim()
   * dim[0] // 1
   * dim[1] // 4
   *
   * a.setDim(2, 2)
   * dim = a.getDim()
   * dim[0] // 2
   * dim[1] // 2
   *
   * a.setDim(0, 2)
   * dim = a.getDim()
   * dim[0] // 2
   * dim[1] // 2
   *
   * a.setDim(0, 4)
   * dim = a.getDim()
   * dim[0] // 1
   * dim[1] // 4
   *
   * a.setDim(1, 3)
   * a.getDim() // Error
   *
   * a.setDim(0, 5)
   * a.getDim() // Error
   *
   * a.setDim(3, 0)
   * a.getDim() // Error
   *
   * a = new M()
   * dim = a.getDim()
   * dim[0] // 0
   * dim[1] // 0
   */
  getDim (nRow = 0, nCol = 0) {
    if (!this.isAdaptive()) {
      nRow = this.nRow;
      nCol = this.nCol;
    }
    if (nRow === 0) {
      if (nCol === 0) {
        if (this.length === 0) {
          return [0, 0]
        } else {
          throw Error('dimension of `this` is unknown.')
        }
      } else {
        if (this.length % nCol !== 0) {
          throw Error('nRow * nCol and length must be the same.')
        }
        return [this.length / nCol, nCol]
      }
    } else if (nCol === 0) {
      if (this.length % nRow !== 0) {
        throw Error('nRow * nCol and length must be the same.')
      }
      return [nRow, this.length / nRow]
    } else {
      if (nRow * nCol === this.length) {
        return [nRow, nCol]
      } else {
        throw Error('nRow * nCol and length must be the same.')
      }
    }
  }

  /**
   * @desc
   * The Matrix#hasSameDim method checks
   * if the dimension of `this` is the same as that of 'another'.
   *
   * @param {Matrix} another
   * a {@link Matrix}.
   *
   * @return {boolean}
   * `true` if the dimension of `this` is the same as that of `another`
   * and `false` otherwise.
   *
   * @throw {Error}
   * if `another` is not a {@link Matrix}.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let m1 = new M(1, 2, 3, 4)
   * let m2 = new M(1, 2, 3, 4).setDim(1, 4)
   * let m3 = new M(1, 2, 3)
   * m1.hasSameDim(m2) // true
   *
   * m2.setDim(4, 1)
   * m1.hasSameDim(m2) // true
   *
   * m2.setDim(2, 2)
   * m1.hasSameDim(m2) // true
   *
   * m1.setDim(2, 2)
   * m1.hasSameDim(m2) // true
   *
   * m1.setDim(1, 4)
   * m1.hasSameDim(m2) // false
   *
   * m1.hasSameDim(m3) // false
   *
   * m1.hasSameDim(null) // Error
   */
  hasSameDim (another) {
    if (!(another instanceof Matrix)) {
      throw Error('`another` is not a `Matrix`.')
    }
    if (this.length === another.length) {
      if (this.isAdaptive() || another.isAdaptive()) {
        return true
      } else {
        const dima = this.getDim();
        const dimb = another.getDim();
        return dima[0] === dimb[0] && dima[1] === dimb[1]
      }
    } else {
      return false
    }
  }

  /**
   * @desc
   * The Matrix#swapRow method swaps
   * *i*-th row and *j*-th row of `this` *in place*.
   *
   * @param {number} i
   * the index of a row to be swapped.
   *
   * @param {number} j
   * the index of the other row to be swapped.
   *
   * @return {Matrix}
   * `this`.
   *
   * @throw {Error}
   * if `i` or `j` is out of range.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let m1 = new M(1, 2, 3, 4).setDim(2, 2)
   * m1.swapRow(0, 1)
   *
   * m1[0] === 3 // true
   * m1[1] === 4 // true
   * m1[2] === 1 // true
   * m1[3] === 2 // true
   *
   * m1.swapRow(0, 0)
   * m1[0] === 3 // true
   * m1[1] === 4 // true
   * m1[2] === 1 // true
   * m1[3] === 2 // true
   *
   * m1.swapRow(0, -1) // Error
   * m1.swapRow(-1, 0) // Error
   */
  swapRow (i, j) {
    const dim = this.getDim();
    const nRow = dim[0];
    if (i < 0 || nRow <= i) {
      throw Error('must be 0 <= i <= nRow.')
    }
    if (j < 0 || nRow <= j) {
      throw Error('must be 0 <= j <= nRow.')
    }
    if (i === j) {
      return this
    } else {
      const nCol = dim[1];
      const ni = nCol * i;
      const nj = nCol * j;
      for (let k = nCol - 1; k >= 0; k -= 1) {
        const nik = ni + k;
        const njk = nj + k;
        const swap = this[nik];
        this[nik] = this[njk];
        this[njk] = swap;
      }
      return this
    }
  }

  /**
   * @desc
   * The Matrix#swapCol method swaps
   * *i*-th column and *j*-th column of `this` *in place*.
   *
   * @param {number} i
   * the index of a column to be swapped.
   *
   * @param {number} j
   * the index of the other column to be swapped.
   *
   * @return {Matrix}
   * `this`.
   *
   * @throw {Error}
   * if `i` or `j` is out of range.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let m1 = new M(1, 2, 3, 4).setDim(2, 2)
   * m1.swapCol(0, 1)
   *
   * m1[0] === 2 // true
   * m1[1] === 1 // true
   * m1[2] === 4 // true
   * m1[3] === 3 // true
   *
   * m1.swapCol(0, 0)
   * m1[0] === 2 // true
   * m1[1] === 1 // true
   * m1[2] === 4 // true
   * m1[3] === 3 // true
   *
   * m1.swapCol(0, -1) // Error
   * m1.swapCol(-1, 0) // Error
   */
  swapCol (i, j) {
    const dim = this.getDim();
    const nCol = dim[1];
    if (i < 0 || nCol <= i) {
      throw Error('must be 0 <= i <= nCol.')
    }
    if (j < 0 || nCol <= j) {
      throw Error('must be 0 <= j <= nCol.')
    }
    if (i === j) {
      return this
    } else {
      const nRow = dim[0];
      for (let k = nRow - 1; k >= 0; k -= 1) {
        const nk = nCol * k;
        const nki = nk + i;
        const nkj = nk + j;
        const swap = this[nki];
        this[nki] = this[nkj];
        this[nkj] = swap;
      }
      return this
    }
  }

  /**
   * @desc
   * The Matrix#isSquare method checks if `this` is a square matrix.
   *
   * @return {boolean}
   * `true` if `this` is a square matrix and `false` otherwise.
   *
   * @throws {Error}
   * if `this` is not considered to be a matrix.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4)
   * a.isSquare() // Error
   *
   * a.setDim(1, 4)
   * a.isSquare() // false
   *
   * a.setDim(2, 2)
   * a.isSquare() // true
   */
  isSquare () {
    const dim = this.getDim();
    return dim[0] === dim[1]
  }

  /**
   * @desc
   * The Matrix#isLUP method checks if
   * `this` is an LU-factorised matrix (with partial pivoting).
   * It checks if `this.permutation` is `null` or not.
   *
   * @return {boolean}
   * `true` if `this` is an LU-factorised matrix and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   */
  isLUP () {
    return this.permutation !== null
  }

  /**
   * @desc
   * The Matrix#toString method converts
   * `this` to a human-readable {@link string}.
   *
   * @param {number} [radix]
   * the base to use for representing numeric values.
   *
   * @return {string}
   * a human-readable {@link string} representation of `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4, 5, 6)
   * a.toString() // '(1, 2, 3, 4, 5, 6)'
   *
   * a.setDim(0, 2)
   * a.toString() // '(1, 2,\n 3, 4,\n 5, 6)'
   *
   * let b = new M(1, 5)
   * b.toString(2) // '(1, 101)'
   *
   * let c = new M()
   * c.toString() // '()'
   */
  toString (radix) {
    let s = '';
    const nCol = this.isAdaptive() ? this.length : this.getDim()[1];
    s += '(';
    if (this.length >= 1) {
      s += this[0].toString(radix);
    }
    for (let i = 1, n = this.length; i < n; i += 1) {
      if (i % nCol === 0) {
        s += ',\n ';
      } else {
        s += ', ';
      }
      s += this[i].toString(radix);
    }
    s += ')';
    return s
  }

  /**
   * @desc
   * The Matrix#toFixed method returns the fixed-point representation of `this`.
   *
   * @param {number} [digits]
   * the number of digits appear after the decimal point.
   *
   * @return {string}
   * the fixed-point representation of `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4, 5, 6)
   * a.toFixed(3) // '(1.000, 2.000, 3.000, 4.000, 5.000, 6.000)'
   *
   * a.setDim(0, 2)
   * a.toFixed(3) // '(1.000, 2.000,\n 3.000, 4.000,\n 5.000, 6.000)'
   *
   * let b = new M()
   * b.toFixed(3) // '()'
   */
  toFixed (digits) {
    let s = '';
    const nCol = this.isAdaptive() ? this.length : this.getDim()[1];
    s += '(';
    if (this.length >= 1) {
      s += this[0].toFixed(digits);
    }
    for (let i = 1, n = this.length; i < n; i += 1) {
      if (i % nCol === 0) {
        s += ',\n ';
      } else {
        s += ', ';
      }
      s += this[i].toFixed(digits);
    }
    s += ')';
    return s
  }

  /**
   * @desc
   * The Matrix#toJSON method converts
   * `this` to an object serialisable by `JSON.stringify`.
   *
   * @return {object}
   * a serialisable object for `this`.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4, 5, 6).setDim(0, 3)
   *
   * // toJSON method is called by JSON.stringify
   * let s = JSON.stringify(a)
   *
   * typeof s // 'string'
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4, 5, 6).setDim(0, 3)
   * a.permutation = [1, 2, 3, 4]
   *
   * // toJSON method is called by JSON.stringify
   * let s = JSON.stringify(a)
   *
   * typeof s // 'string'
   */
  toJSON () {
    const obj = {};
    obj.reviver = 'Matrix';
    obj.version = '2.0.0';
    obj.data = this.slice();
    obj.nRow = this.nRow;
    obj.nCol = this.nCol;
    if (this.isLUP()) {
      obj.permutation = this.permutation;
    }
    return obj
  }

  /**
   * @desc
   * The Matrix.reviver function converts
   * the data produced by {@link Matrix#toJSON}
   * to a {@link Matrix}.
   *
   * @param {object} key
   *
   * @param {object} value
   *
   * @return {Matrix}
   * a {@link Matrix} or `value`.
   *
   * @throws {Error}
   * if the given object is invalid.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4)
   * let s = JSON.stringify(a)
   *
   * // reviver method is called by JSON.parse
   * let b = JSON.parse(s, M.reviver)
   *
   * typeof s // 'string'
   * a === b // false
   * a.length === b.length // true
   * a.nRow === b.nRow // true
   * a.nCol === b.nRow // true
   * a[0] === b[0] // true
   * a[1] === b[1] // true
   * a[2] === b[2] // true
   * a[3] === b[3] // true
   *
   * let s2 = s.replace('2.0.0', '1.0.0')
   * b = JSON.parse(s2, M.reviver)
   * typeof s2 // 'string'
   * a === b // false
   * a.length === b.length // true
   * a.nRow === b.nRow // true
   * a.nCol === b.nRow // true
   * a[0] === b[0] // true
   * a[1] === b[1] // true
   * a[2] === b[2] // true
   * a[3] === b[3] // true
   *
   * let s3 = s.replace('2.0.0', '0.0.0')
   * JSON.parse(s3, M.reviver) // Error
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   *
   * let a = new M(1, 2, 3, 4)
   * a.permutation = [1, 2, 3, 4]
   * let s = JSON.stringify(a)
   *
   * // reviver method is called by JSON.parse
   * let b = JSON.parse(s, M.reviver)
   *
   * typeof s // 'string'
   * a === b // false
   * a.length === b.length // true
   * a.nRow === b.nRow // true
   * a.nCol === b.nRow // true
   * a[0] === b[0] // true
   * a[1] === b[1] // true
   * a[2] === b[2] // true
   * a[3] === b[3] // true
   * b.permutation[0] === 1 // true
   * b.permutation[1] === 2 // true
   * b.permutation[2] === 3 // true
   * b.permutation[3] === 4 // true
   */
  static reviver (key, value) {
    if (value !== null && typeof value === 'object' &&
        value.reviver === 'Matrix') {
      switch (value.version) {
        case '1.0.0':
        case '2.0.0':
          const data = value.data;
          const nRow = value.nRow;
          const nCol = value.nCol;
          const m = new Matrix(...data).setDim(nRow, nCol);
          if (value.permutation !== undefined) {
            m.permutation = value.permutation;
          }
          return m
        default:
          throw Error('invalid version.')
      }
    } else {
      return value
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/linear-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @typedef {RealAlgebra|ComplexAlgebra} ScalarAlgebra
 *
 * @desc
 * A ScalarAlgebra denotes a {@link RealAlgebra} (see @kkitahara/real-algebra)
 * or a {@link ComplexAlgebra} (see @kkitahara/complex-algebra).
 */

/**
 * @desc
 * The LinearAlgebra class is a class for linear algebra.
 *
 * @version 2.0.0
 * @since 1.0.0
 *
 * @example
 * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
 * // import { RealAlgebra } from '@kkitahara/real-algebra'
 * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
 * import { LinearAlgebra } from '@kkitahara/linear-algebra'
 * let r = new RealAlgebra()
 * let c = new ComplexAlgebra(r)
 * let l = new LinearAlgebra(c)
 * let m1, m2, m3
 *
 * // Generate a new matrix (since v2.0.0)
 * m1 = l.$(1, 0, 0, 1)
 * m1.toString() // '(1, 0, 0, 1)'
 *
 * m1 = l.$(r.$(1, 2, 5), c.$(0, 1), c.$(0, -1), 1)
 * m1.toString() // '((1 / 2)sqrt(5), i(1), i(-1), 1)'
 *
 * // Some Array methods can be used
 * m1 = l.$(r.$(1, 2, 5), c.$(0, 1), c.$(0, -1), 1)
 * m1.push(c.$(3))
 * m1.toString() // '((1 / 2)sqrt(5), i(1), i(-1), 1, 3)'
 *
 * // Set and get the dimension
 * m1 = l.$(1, 0, 0, 1)
 *
 * // 2 x 2 matix
 * m1.setDim(2, 2)
 * // number of rows
 * m1.getDim()[0] // 2
 * // number of columns
 * m1.getDim()[1] // 2
 * // elements are stored in row-major order
 * m1.toString() // '(1, 0,\n 0, 1)'
 *
 * // 1 x 4 matix
 * m1.setDim(1, 4)
 * m1.getDim()[0] // 1
 * m1.getDim()[1] // 4
 * m1.toString() // '(1, 0, 0, 1)'
 *
 * // 4 x 1 matix
 * m1.setDim(4, 1)
 * m1.getDim()[0] // 4
 * m1.getDim()[1] // 1
 * m1.toString() // '(1,\n 0,\n 0,\n 1)'
 *
 * // 3 x 1 matix (inconsistent dimension)
 * m1.setDim(3, 1)
 * // throws an Error when getDim is called
 * m1.getDim() // Error
 *
 * // 2 x 0 (0 means auto)
 * m1.setDim(2, 0)
 * m1.getDim()[0] // 2
 * m1.getDim()[1] // 2
 *
 * // 0 x 1 (0 means auto)
 * m1.setDim(0, 1)
 * m1.getDim()[0] // 4
 * m1.getDim()[1] // 1
 *
 * // 0 x 0 (this is an adaptive matrix, since v2.0.0)
 * m1.setDim(0, 0)
 * m1.isAdaptive() // true
 * m1.getDim() // Error
 *
 * // matrices are adaptive by default
 * m1 = l.$(1, 0, 0, 1)
 * m1.isAdaptive() // true
 *
 * // Copy (generate a new object)
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.copy(m1)
 * m2.toString() // '(1, 0,\n 0, 1)'
 * m2.getDim()[0] // 2
 * m2.getDim()[1] // 2
 *
 * // Equality
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m3 = l.$(1, 0, 0, -1).setDim(2, 2)
 * l.eq(m1, m2) // true
 * l.eq(m1, m3) // false
 *
 * // matrices of different dimension are considered to be not equal
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * l.eq(m1, m2) // false
 *
 * // here, `m1` is adaptive
 * m1 = l.$(1, 0, 0, 1)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * m3 = l.$(1, 0, 0, 1).setDim(4, 1)
 * l.eq(m1, m2) // true
 * l.eq(m1, m3) // true
 * l.eq(m2, m3) // false
 *
 * // Inequality
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m3 = l.$(1, 0, 0, -1).setDim(2, 2)
 * l.ne(m1, m2) // false
 * l.ne(m1, m3) // true
 *
 * // matrices of different dimension are considered to be not equal
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * l.ne(m1, m2) // true
 *
 * // here, `m1` is adaptive
 * m1 = l.$(1, 0, 0, 1)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * m3 = l.$(1, 0, 0, 1).setDim(4, 1)
 * l.ne(m1, m2) // false
 * l.ne(m1, m3) // false
 * l.ne(m2, m3) // true
 *
 * // isZero
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(0, 0, 0, 0).setDim(2, 2)
 * l.isZero(m1) // false
 * l.isZero(m2) // true
 *
 * // isInteger (since v1.1.0)
 * m1 = l.$(1, r.$(4, 2), -3, 4).setDim(2, 2)
 * m2 = l.$(1, r.$(1, 2), -3, 4).setDim(2, 2)
 * l.isInteger(m1) // true
 * l.isInteger(m2) // false
 *
 * // Element-wise addition
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.add(m1, m2)
 * m3.toString() // '(2, 5, 4, 7)'
 *
 * // In-place element-wise addition
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.iadd(m1, m2)
 * m1.toString() // '(2, 5, 4, 7)'
 *
 * // Element-wise subtraction
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.sub(m1, m2)
 * m3.toString() // '(0, -1, 2, 1)'
 *
 * // In-place element-wise subtraction
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.isub(m1, m2)
 * m1.toString() // '(0, -1, 2, 1)'
 *
 * // Element-wise multiplication
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.mul(m1, m2)
 * m3.toString() // '(1, 6, 3, 12)'
 *
 * // In-place element-wise multiplication
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.imul(m1, m2)
 * m1.toString() // '(1, 6, 3, 12)'
 *
 * // Element-wise division
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.div(m1, m2)
 * m3.toString() // '(1, 2 / 3, 3, 4 / 3)'
 *
 * // In-place element-wise division
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.idiv(m1, m2)
 * m1.toString() // '(1, 2 / 3, 3, 4 / 3)'
 *
 * // Scalar multiplication
 * m1 = l.$(1, 2, 3, 4)
 * // new object is generated
 * m2 = l.smul(m1, r.$(1, 2))
 * m2.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // In-place scalar multiplication
 * m1 = l.$(1, 2, 3, 4)
 * // new object is not generated
 * m1 = l.ismul(m1, r.$(1, 2))
 * m1.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // Scalar multiplication by -1
 * m1 = l.$(1, 2, 3, 4)
 * // new object is generated
 * m2 = l.neg(m1)
 * m2.toString() // '(-1, -2, -3, -4)'
 *
 * // In-place scalar multiplication by -1
 * m1 = l.$(1, 2, 3, 4)
 * // new object is not generated
 * m1 = l.ineg(m1)
 * m1.toString() // '(-1, -2, -3, -4)'
 *
 * // Scalar division (since v2.0.0)
 * m1 = l.$(1, 2, 3, 4)
 * // new object is generated
 * m2 = l.sdiv(m1, 2)
 * m2.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // In-place scalar division (since v2.0.0)
 * m1 = l.$(1, 2, 3, 4)
 * // new object is not generated
 * m1 = l.isdiv(m1, 2)
 * m1.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // Complex conjugate
 * m1 = l.$(1, c.$(0, 2), 3, c.$(0, 4))
 * // new object is generated
 * m2 = l.cjg(m1)
 * m2.toString() // '(1, i(-2), 3, i(-4))'
 *
 * // In-place evaluation of the complex conjugate
 * m1 = l.$(1, c.$(0, 2), 3, c.$(0, 4))
 * // new object is not generated
 * m1 = l.icjg(m1)
 * m1.toString() // '(1, i(-2), 3, i(-4))'
 *
 * // Transpose
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is generated
 * m2 = l.transpose(m1)
 * m2.toString() // '(1, 3,\n 2, 4)'
 *
 * // In-place evaluation of the transpose
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is not generated
 * m1 = l.itranspose(m1)
 * m1.toString() // '(1, 3,\n 2, 4)'
 *
 * // Conjugate transpose (Hermitian transpose)
 * m1 = l.$(1, c.$(0, 2), 3, c.$(0, 4)).setDim(2, 2)
 * // new object is generated
 * m2 = l.cjgTranspose(m1)
 * m2.toString() // '(1, 3,\n i(-2), i(-4))'
 *
 * // In-place evaluation of the conjugate transpose
 * m1 = l.$(1, c.$(0, 2), 3, c.$(0, 4)).setDim(2, 2)
 * // new object is not generated
 * m1 = l.icjgTranspose(m1)
 * m1.toString() // '(1, 3,\n i(-2), i(-4))'
 *
 * // Dot product
 * m1 = l.$(1, c.$(0, 2))
 * m2 = l.$(c.$(0, 3), 2)
 * l.dot(m1, m2).toString() // 'i(-1)'
 *
 * // Square of the absolute value (Frobenius norm)
 * m1 = l.$(1, c.$(0, 2))
 * let a = l.abs2(m1)
 * a.toString() // '5'
 * // return value is not a complex number (but a real number)
 * a.re // undefined
 * a.im // undefined
 *
 * // Matrix multiplication
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.$(1, 3, 1, 3).setDim(2, 2)
 * m3 = l.mmul(m1, m2)
 * m3.toString() // '(3, 9,\n 7, 21)'
 *
 * // LU-factorisation
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is generated
 * m2 = l.lup(m1)
 *
 * // In-place LU-factorisation
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is not generated
 * m1 = l.ilup(m1)
 *
 * // Solving a linear equation
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
 *
 * // m1 m3 = m2, new object is generated
 * m3 = l.solve(l.lup(m1), m2)
 * m3.toString() // '(1, 0,\n 0, 1)'
 *
 * // m3 m1 = m2, new object is generated
 * m3 = l.solve(m2, l.lup(m1))
 * m3.toString() // '(1, 0,\n 0, 1)'
 *
 * // Solving a linear equation in-place
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
 *
 * // m1 m3 = m2, new object is not generated
 * m2 = l.isolve(l.lup(m1), m2)
 * m2.toString() // '(1, 0,\n 0, 1)'
 *
 * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
 *
 * // m3 m1 = m2, new object is not generated
 * m2 = l.isolve(m2, l.lup(m1))
 * m2.toString() // '(1, 0,\n 0, 1)'
 *
 * // Determinant
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.lup(m1)
 * // det method supports only LU-factorised matrices
 * let det = l.det(m2)
 * det.toString() // '-2'
 *
 * // JSON (stringify and parse)
 * m1 = l.$(1, r.$(2, 3, 5), 3, c.$(0, r.$(4, 5, 3))).setDim(2, 2)
 * let str = JSON.stringify(m1)
 * m2 = JSON.parse(str, l.reviver)
 * l.eq(m1, m2) // true
 *
 * @example
 * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
 * // import { RealAlgebra } from '@kkitahara/real-algebra'
 * import { LinearAlgebra } from '@kkitahara/linear-algebra'
 * let r = new RealAlgebra()
 * let l = new LinearAlgebra(r)
 * let m1, m2, m3
 *
 * // Generate a new matrix (since v2.0.0)
 * m1 = l.$(1, 0, 0, 1)
 * m1.toString() // '(1, 0, 0, 1)'
 *
 * m1 = l.$(r.$(1, 2, 5), 1, -1, 1)
 * m1.toString() // '((1 / 2)sqrt(5), 1, -1, 1)'
 *
 * // Some Array methods can be used
 * m1 = l.$(r.$(1, 2, 5), 1, -1, 1)
 * m1.push(r.$(3))
 * m1.toString() // '((1 / 2)sqrt(5), 1, -1, 1, 3)'
 *
 * // Set and get the dimension
 * m1 = l.$(1, 0, 0, 1)
 *
 * // 2 x 2 matix
 * m1.setDim(2, 2)
 * // number of rows
 * m1.getDim()[0] // 2
 * // number of columns
 * m1.getDim()[1] // 2
 * // elements are stored in row-major order
 * m1.toString() // '(1, 0,\n 0, 1)'
 *
 * // 1 x 4 matix
 * m1.setDim(1, 4)
 * m1.getDim()[0] // 1
 * m1.getDim()[1] // 4
 * m1.toString() // '(1, 0, 0, 1)'
 *
 * // 4 x 1 matix
 * m1.setDim(4, 1)
 * m1.getDim()[0] // 4
 * m1.getDim()[1] // 1
 * m1.toString() // '(1,\n 0,\n 0,\n 1)'
 *
 * // 3 x 1 matix (inconsistent dimension)
 * m1.setDim(3, 1)
 * // throws an Error when getDim is called
 * m1.getDim() // Error
 *
 * // 2 x 0 (0 means auto)
 * m1.setDim(2, 0)
 * m1.getDim()[0] // 2
 * m1.getDim()[1] // 2
 *
 * // 0 x 1 (0 means auto)
 * m1.setDim(0, 1)
 * m1.getDim()[0] // 4
 * m1.getDim()[1] // 1
 *
 * // 0 x 0 (this is an adaptive matrix, since v2.0.0)
 * m1.setDim(0, 0)
 * m1.isAdaptive() // true
 * m1.getDim() // Error
 *
 * // matrices are adaptive by default
 * m1 = l.$(1, 0, 0, 1)
 * m1.isAdaptive() // true
 *
 * // Copy (generate a new object)
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.copy(m1)
 * m2.toString() // '(1, 0,\n 0, 1)'
 * m2.getDim()[0] // 2
 * m2.getDim()[1] // 2
 *
 * // Equality
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m3 = l.$(1, 0, 0, -1).setDim(2, 2)
 * l.eq(m1, m2) // true
 * l.eq(m1, m3) // false
 *
 * // matrices of different dimension are considered to be not equal
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * l.eq(m1, m2) // false
 *
 * // here, `m1` is adaptive
 * m1 = l.$(1, 0, 0, 1)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * m3 = l.$(1, 0, 0, 1).setDim(4, 1)
 * l.eq(m1, m2) // true
 * l.eq(m1, m3) // true
 * l.eq(m2, m3) // false
 *
 * // Inequality
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m3 = l.$(1, 0, 0, -1).setDim(2, 2)
 * l.ne(m1, m2) // false
 * l.ne(m1, m3) // true
 *
 * // matrices of different dimension are considered to be not equal
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * l.ne(m1, m2) // true
 *
 * // here, `m1` is adaptive
 * m1 = l.$(1, 0, 0, 1)
 * m2 = l.$(1, 0, 0, 1).setDim(1, 4)
 * m3 = l.$(1, 0, 0, 1).setDim(4, 1)
 * l.ne(m1, m2) // false
 * l.ne(m1, m3) // false
 * l.ne(m2, m3) // true
 *
 * // isZero
 * m1 = l.$(1, 0, 0, 1).setDim(2, 2)
 * m2 = l.$(0, 0, 0, 0).setDim(2, 2)
 * l.isZero(m1) // false
 * l.isZero(m2) // true
 *
 * // Element-wise addition
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.add(m1, m2)
 * m3.toString() // '(2, 5, 4, 7)'
 *
 * // In-place element-wise addition
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.iadd(m1, m2)
 * m1.toString() // '(2, 5, 4, 7)'
 *
 * // Element-wise subtraction
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.sub(m1, m2)
 * m3.toString() // '(0, -1, 2, 1)'
 *
 * // In-place element-wise subtraction
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.isub(m1, m2)
 * m1.toString() // '(0, -1, 2, 1)'
 *
 * // Element-wise multiplication
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.mul(m1, m2)
 * m3.toString() // '(1, 6, 3, 12)'
 *
 * // In-place element-wise multiplication
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.imul(m1, m2)
 * m1.toString() // '(1, 6, 3, 12)'
 *
 * // Element-wise division
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is generated
 * m3 = l.div(m1, m2)
 * m3.toString() // '(1, 2 / 3, 3, 4 / 3)'
 *
 * // In-place element-wise division
 * m1 = l.$(1, 2, 3, 4)
 * m2 = l.$(1, 3, 1, 3)
 * // new object is not generated
 * m1 = l.idiv(m1, m2)
 * m1.toString() // '(1, 2 / 3, 3, 4 / 3)'
 *
 * // Scalar multiplication
 * m1 = l.$(1, 2, 3, 4)
 * // new object is generated
 * m2 = l.smul(m1, r.$(1, 2))
 * m2.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // In-place scalar multiplication
 * m1 = l.$(1, 2, 3, 4)
 * // new object is not generated
 * m1 = l.ismul(m1, r.$(1, 2))
 * m1.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // Scalar multiplication by -1
 * m1 = l.$(1, 2, 3, 4)
 * // new object is generated
 * m2 = l.neg(m1)
 * m2.toString() // '(-1, -2, -3, -4)'
 *
 * // In-place scalar multiplication by -1
 * m1 = l.$(1, 2, 3, 4)
 * // new object is not generated
 * m1 = l.ineg(m1)
 * m1.toString() // '(-1, -2, -3, -4)'
 *
 * // Scalar division (since v2.0.0)
 * m1 = l.$(1, 2, 3, 4)
 * // new object is generated
 * m2 = l.sdiv(m1, 2)
 * m2.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // In-place scalar division (since v2.0.0)
 * m1 = l.$(1, 2, 3, 4)
 * // new object is not generated
 * m1 = l.isdiv(m1, 2)
 * m1.toString() // '(1 / 2, 1, 3 / 2, 2)'
 *
 * // Complex conjugate
 * m1 = l.$(1, 2, 3, 4)
 * // new object is generated
 * m2 = l.cjg(m1)
 * m2.toString() // '(1, 2, 3, 4)'
 *
 * // In-place evaluation of the complex conjugate
 * m1 = l.$(1, 2, 3, 4)
 * // new object is not generated
 * m1 = l.icjg(m1)
 * m1.toString() // '(1, 2, 3, 4)'
 *
 * // Transpose
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is generated
 * m2 = l.transpose(m1)
 * m2.toString() // '(1, 3,\n 2, 4)'
 *
 * // In-place evaluation of the transpose
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is not generated
 * m1 = l.itranspose(m1)
 * m1.toString() // '(1, 3,\n 2, 4)'
 *
 * // Conjugate transpose (Hermitian transpose)
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is generated
 * m2 = l.cjgTranspose(m1)
 * m2.toString() // '(1, 3,\n 2, 4)'
 *
 * // In-place evaluation of the conjugate transpose
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is not generated
 * m1 = l.icjgTranspose(m1)
 * m1.toString() // '(1, 3,\n 2, 4)'
 *
 * // Dot product
 * m1 = l.$(1, 2)
 * m2 = l.$(3, 2)
 * l.dot(m1, m2).toString() // '7'
 *
 * // Square of the absolute value (Frobenius norm)
 * m1 = l.$(1, 2)
 * let a = l.abs2(m1)
 * a.toString() // '5'
 *
 * // Matrix multiplication
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.$(1, 3, 1, 3).setDim(2, 2)
 * m3 = l.mmul(m1, m2)
 * m3.toString() // '(3, 9,\n 7, 21)'
 *
 * // LU-factorisation
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is generated
 * m2 = l.lup(m1)
 *
 * // In-place LU-factorisation
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * // new object is not generated
 * m1 = l.ilup(m1)
 *
 * // Solving a linear equation
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
 *
 * // m1 m3 = m2, new object is generated
 * m3 = l.solve(l.lup(m1), m2)
 * m3.toString() // '(1, 0,\n 0, 1)'
 *
 * // m3 m1 = m2, new object is generated
 * m3 = l.solve(m2, l.lup(m1))
 * m3.toString() // '(1, 0,\n 0, 1)'
 *
 * // Solving a linear equation in-place
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
 *
 * // m1 m3 = m2, new object is not generated
 * m2 = l.solve(l.lup(m1), m2)
 * m2.toString() // '(1, 0,\n 0, 1)'
 *
 * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
 *
 * // m3 m1 = m2, new object is not generated
 * m2 = l.solve(m2, l.lup(m1))
 * m2.toString() // '(1, 0,\n 0, 1)'
 *
 * // Determinant
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * m2 = l.lup(m1)
 * // det method supports only LU-factorised matrices
 * let det = l.det(m2)
 * det.toString() // '-2'
 *
 * // JSON (stringify and parse)
 * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
 * let str = JSON.stringify(m1)
 * m2 = JSON.parse(str, l.reviver)
 * l.eq(m1, m2) // true
 */
class LinearAlgebra {
  /**
   * @desc
   * The constructor function of the {@link LinearAlgebra} class.
   *
   * CAUTION: this method does not check if `salg` is a valid
   * implementation of {@link ScalarAlgebra} or not.
   *
   * @param {ScalarAlgebra} salg
   * an instance of a {@link ScalarAlgebra}.
   *
   * @version 2.0.2
   * @since 1.0.0
   */
  constructor (salg) {
    /**
     * @desc
     * The LinearAlgebra#salg is used to manipurate elements of {@link Matrix}.
     *
     * @type {ScalarAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.salg = salg;
  }

  /**
   * @desc
   * The LinearAlgebra#$ method returns a new instance of {@link Matrix}
   * which contains the given parameters copied by `salg.copy` method.
   *
   * @param {...ScalarAlgebraicElement} args
   * instances of a {@link ScalarAlgebraicElement}.
   *
   * @return {Matrix}
   * a new instance of {@link Matrix}.
   *
   * @version 2.0.0
   * @since 2.0.0
   *
   * @example
   */
  $ (...args) {
    const salg = this.salg;
    for (let i = args.length - 1; i >= 0; i -= 1) {
      args[i] = salg.copy(args[i]);
    }
    return new Matrix(...args)
  }

  /**
   * @desc
   * The LinearAlgebra#cast method returns
   * `m` with its elements casted by `salg.cast` method
   * if `m` is a {@link Matrix}.
   * If `m` is an {@link Array},
   * it returns a new {@link Matrix} containing
   * the elements of the `m` casted by `salg.cast` method;
   * in this case, if `m.nRow`, `m.nCol` or `m.permutation` are set,
   * these are set to the new {@link Matrix}.
   *
   * @param {object} m
   * an instance of {@link Array}.
   *
   * @return {Matrix}
   * `m` or a new {@link Matrix}.
   *
   * @throws {Error}
   * if `m` is not an instance of {@link Array}.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * import { ComplexAlgebra, ComplexAlgebraicElement as C }
   *   from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(c.$(1))
   * let m2 = m1
   *
   * m2 === l.cast(m1) // true
   * m1[0] instanceof C // true
   * m1[0].re instanceof P // true
   * r.eq(m1[0].re, 1) // true
   * m1[0].im instanceof P // true
   * r.eq(m1[0].im, 0) // true
   *
   * let m3 = l.cast([1, 2])
   * m3 instanceof M // true
   * m3[0] instanceof C // true
   * m3[0].re instanceof P // true
   * r.eq(m3[0].re, 1) // true
   * m3[0].im instanceof P // true
   * r.eq(m3[0].im, 0) // true
   * m3[1] instanceof C // true
   * m3[1].re instanceof P // true
   * r.eq(m3[1].re, 2) // true
   * m3[1].im instanceof P // true
   * r.eq(m3[1].im, 0) // true
   *
   * let a = r.$(1, 2, 5)
   * a instanceof Array // true
   * l.cast(a) // Error
   *
   * l.cast(2) // Error
   */
  cast (m) {
    const salg = this.salg;
    if (m instanceof Matrix) {
      const arr = [];
      for (let i = 0, n = m.length; i < n; i += 1) {
        arr.push(salg.cast(m[i]));
      }
      if (arr.some((arri, i) => arri !== m[i])) {
        const nRow = m.nRow;
        const nCol = m.nCol;
        const permutation = m.permutation;
        m = new Matrix(...arr).setDim(nRow, nCol);
        m.permutation = permutation;
      }
    } else if (m instanceof Array) {
      const nRow = m.nRow | 0;
      const nCol = m.nCol | 0;
      const permutation = m.permutation || null;
      m = new Matrix(...m).setDim(nRow, nCol);
      m.permutation = permutation;
      for (let i = m.length - 1; i >= 0; i -= 1) {
        m[i] = salg.cast(m[i]);
      }
    } else {
      throw Error('can cast only instances of `Array`.')
    }
    return m
  }

  /**
   * @desc
   * The LinearAlgebra#copy method returns a copy of `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a copy of `m`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, 2)
   * m1.setDim(2, 0)
   * let m2 = l.copy(m1)
   *
   * m1 instanceof M // true
   * m2 instanceof M // true
   * m1 !== m2 // true
   * m1[0] !== m2[0] // true
   * m1[1] !== m2[1] // true
   * m1.nRow // 2
   * m1.nCol // 0
   * m2.nRow // 2
   * m2.nCol // 0
   * c.eq(m1[0], m2[0]) // true
   * c.eq(m1[1], m2[1]) // true
   *
   * let m3 = l.$(1, 2, 3, 4).setDim(2, 2)
   * m3 = l.ilup(m3)
   * let m4 = l.copy(m3)
   * m4.isLUP() // true
   */
  copy (m) {
    m = this.cast(m);
    const salg = this.salg;
    const arr = [];
    for (let i = 0, n = m.length; i < n; i += 1) {
      arr.push(salg.copy(m[i]));
    }
    const m2 = new Matrix(...arr).setDim(m.nRow, m.nCol);
    if (m.permutation !== null) {
      m2.permutation = m.permutation.slice();
    }
    return m2
  }

  /**
   * @desc
   * The LinearAlgebra#eq method checks if `m1` is equal to `m2`.
   * Matrices of different dimension are considered to be not equal.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {boolean}
   * `true` if `m1` is equal to `m2` and `false` otherwise.
   *
   * @throws {Error}
   * if `m1` or `m2` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2, 3)
   * let m2 = l.$(1, 2, 3)
   * let m3 = l.$(3, 2, 1)
   * let m4 = l.$(1, 2)
   * let m5 = l.$(1, 2, 3, 4)
   *
   * l.eq(m1, m2) // true
   * l.eq(m1, m3) // false
   * l.eq(m1, m4) // false
   * l.eq(m1, m5) // false
   *
   * m1.setDim(1, 3)
   * m2.setDim(3, 1)
   * l.eq(m1, m2) // false
   *
   * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
   * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
   * l.eq(l.lup(m1), m2) // Error
   * l.eq(m1, l.lup(m2)) // Error
   */
  eq (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP() || m2.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by eq method.')
    }
    const salg = this.salg;
    if (m1.hasSameDim(m2)) {
      let flag = true;
      for (let i = m1.length - 1; flag && i >= 0; i -= 1) {
        flag = salg.eq(m1[i], m2[i]);
      }
      return flag
    } else {
      return false
    }
  }

  /**
   * @desc
   * The LinearAlgebra#ne method checks if `m1` is not equal to `m2`.
   *
   * `lalg.eq(m1, m2)` is an alias for `!lalg.eq(m1, m2)`,
   * where `lalg` is an instance of {@link LinearAlgebra}.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {boolean}
   * `true` if `m1` is not equal to `m2` and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2, 3)
   * let m2 = l.$(1, 2, 3)
   * let m3 = l.$(3, 2, 1)
   * let m4 = l.$(1, 2)
   * let m5 = l.$(1, 2, 3, 4)
   *
   * l.ne(m1, m2) // false
   * l.ne(m1, m3) // true
   * l.ne(m1, m4) // true
   * l.ne(m1, m5) // true
   */
  ne (m1, m2) {
    return !this.eq(m1, m2)
  }

  /**
   * @desc
   * The LinearAlgebra#isZero method checks if `m` is zero.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {boolean}
   * `true` if `m` is zero and `false` otherwise.
   *
   * @throws {Error}
   * if `m` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * l.isZero(l.$(0, 0, 0, 0)) // true
   * l.isZero(l.$()) // true
   * l.isZero(l.$(1, 2)) // false
   *
   * let m = l.ilup(l.$(0, 0, 0, 0).setDim(2, 2))
   * l.isZero(m) // Error
   */
  isZero (m) {
    m = this.cast(m);
    if (m.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by isZero method.')
    }
    const salg = this.salg;
    let flag = true;
    for (let i = m.length - 1; flag && i >= 0; i -= 1) {
      flag = salg.isZero(m[i]);
    }
    return flag
  }

  /**
   * @desc
   * The LinearAlgebra#isInteger method checks if all the elements of `m`
   * are integers.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {boolean}
   * `true` if all the elements of `m` are integers and `false` otherwise.
   *
   * @throws {Error}
   * if `m` is LU-factorised.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * l.isInteger([0, 0, 0, 0]) // true
   * l.isInteger([1, 3, -2, r.$(1, 2)]) // false
   *
   * let m = l.ilup(l.$(0, 0, 0, 0).setDim(2, 2))
   * l.isInteger(m) // Error
   */
  isInteger (m) {
    m = this.cast(m);
    if (m.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by isInteger ' +
          'method.')
    }
    const salg = this.salg;
    let flag = true;
    for (let i = m.length - 1; flag && i >= 0; i -= 1) {
      flag = salg.isInteger(m[i]);
    }
    return flag
  }

  /**
   * @desc
   * The LinearAlgebra#isFinite method checks if `m` is finite.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {boolean}
   * `true` if `m` is finite and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import bigInt from 'big-integer'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let a = r.$(bigInt('1e999'))
   *
   * l.isFinite(l.$(0)) // true
   * l.isFinite(l.$(0, a, 1)) // true
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import bigInt from 'big-integer'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let a = r.$(bigInt('1e999'))
   *
   * l.isFinite(l.$(0)) // true
   * l.isFinite(l.$(0, a, 1)) // false
   */
  isFinite (m) {
    m = this.cast(m);
    const salg = this.salg;
    let flag = true;
    for (let i = m.length - 1; flag && i >= 0; i -= 1) {
      flag = salg.isFinite(m[i]);
    }
    return flag
  }

  /**
   * @desc
   * The LinearAlgebra#isExact method checks
   * if `this` is an implementation of exact algebra.
   *
   * @return {boolean}
   * `true` if `this` is an exact algebra and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * l.isExact() // true
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * l.isExact() // false
   */
  isExact () {
    return this.salg.isExact()
  }

  /**
   * @desc
   * The LinearAlgebra#isReal method checks
   * if `this` is an implementation of real algebra.
   *
   * @return {boolean}
   * `true` if `this.salg` is an implementation of real algebra
   * and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * l.isReal() // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * l.isReal() // false
   *
   * new LinearAlgebra(r).isReal() // true
   */
  isReal () {
    return this.salg.isReal()
  }

  /**
   * @desc
   * The LinearAlgebra#add method returns the result of
   * the element-wise addition `m1` plus `m2`.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the result of the element-wise addition `m1` plus `m2`.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2)
   * let m2 = l.$(3, 4)
   * let m3 = l.add(m1, m2)
   *
   * m3 instanceof M // true
   * m1 !== m3 // true
   * l.eq(m1, l.$(1, 2)) // true
   * l.eq(m3, l.$(4, 6)) // true
   * l.add(m1, l.$(1, 2, 3)) // Error
   */
  add (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.hasSameDim(m2)) {
      return this.iadd(this.copy(m1), m2)
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#iadd method adds `m2` to `m1` *in place* element-wise.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m1`, or a new instance of {@link Matrix} if `m1` is not an instance of
   * {@link Matrix}.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @throws {Error}
   * if `m1` or `m2` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2)
   * let m2 = l.$(3, 4)
   * let m3 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.iadd(m1, m2)
   * m1 === m3 // true
   * m1 instanceof M // true
   * l.eq(m1, new M(4, 6)) // true
   *
   * m1 = new M(1, 2, 3, 4).setDim(2, 2)
   * m2 = new M(5, 7, 5, 3).setDim(2, 2)
   * l.iadd(l.lup(m1), m2) // Error
   * l.iadd(m1, l.lup(m2)) // Error
   * l.iadd(m1, l.$(1, 2, 3)) // Error
   */
  iadd (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP() || m2.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by isub method.')
    }
    if (m1.hasSameDim(m2)) {
      const salg = this.salg;
      for (let i = m1.length - 1; i >= 0; i -= 1) {
        m1[i] = salg.iadd(m1[i], m2[i]);
      }
      return m1
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#sub method returns the result of
   * the element-wise subtraction `m1` minus `m2`.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the result of the element-wise subtraction `m1` minus `m2`.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2)
   * let m2 = l.$(3, 4)
   * let m3 = l.sub(m1, m2)
   *
   * m3 instanceof M // true
   * m1 !== m3 // true
   * l.eq(m1, l.$(1, 2)) // true
   * l.eq(m3, l.$(-2, -2)) // true
   * l.sub(m1, l.$(1, 2, 3)) // Error
   */
  sub (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.hasSameDim(m2)) {
      return this.isub(this.copy(m1), m2)
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#isub method subtracts `m2` from `m1` *in place*
   * element-wise.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m1`, or a new instance of {@link Matrix} if `m1` is not an instance of
   * {@link Matrix}.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @throws {Error}
   * if `m1` or `m2` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2)
   * let m2 = l.$(3, 4)
   * let m3 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.isub(m1, m2)
   * m1 === m3 // true
   * m1 instanceof M // true
   * l.eq(m1, new M(-2, -2)) // true
   *
   * m1 = new M(1, 2, 3, 4).setDim(2, 2)
   * m2 = new M(5, 7, 5, 3).setDim(2, 2)
   * l.isub(l.lup(m1), m2) // Error
   * l.isub(m1, l.lup(m2)) // Error
   * l.isub(m1, l.$(1, 2, 3)) // Error
   */
  isub (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP() || m2.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by isub method.')
    }
    if (m1.hasSameDim(m2)) {
      const salg = this.salg;
      for (let i = m1.length - 1; i >= 0; i -= 1) {
        m1[i] = salg.isub(m1[i], m2[i]);
      }
      return m1
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#mul method returns the result of
   * the element-wise multiplication `m1` times `m2`.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the result of the element-wise multiplication `m1` times `m2`.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2)
   * let m2 = l.$(3, 4)
   * let m3 = l.mul(m1, m2)
   *
   * m3 instanceof M // true
   * m1 !== m3 // true
   * l.eq(m1, l.$(1, 2)) // true
   * l.eq(m3, l.$(3, 8)) // true
   * l.mul(m1, l.$(1, 2, 3)) // Error
   */
  mul (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.hasSameDim(m2)) {
      return this.imul(this.copy(m1), m2)
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#imul method multiplies `m1` by `m2` *in place*
   * element-wise.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m1`, or a new instance of {@link Matrix} if `m1` is not an instance of
   * {@link Matrix}.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @throws {Error}
   * if `m1` or `m2` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2)
   * let m2 = l.$(3, 4)
   * let m3 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.imul(m1, m2)
   * m1 === m3 // true
   * m1 instanceof M // true
   * l.eq(m1, l.$(3, 8)) // true
   *
   * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
   * m2 = l.$(5, 7, 5, 3).setDim(2, 2)
   * l.imul(l.lup(m1), m2) // Error
   * l.imul(m1, l.lup(m2)) // Error
   * l.imul(m1, l.$(1, 2, 3)) // Error
   */
  imul (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP() || m2.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by imul method.')
    }
    if (m1.hasSameDim(m2)) {
      const salg = this.salg;
      for (let i = m1.length - 1; i >= 0; i -= 1) {
        m1[i] = salg.imul(m1[i], m2[i]);
      }
      return m1
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#div method returns the result of
   * the element-wise division `m1` over `m2`.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the result of the element-wise division `m1` times `m2`.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(4, 6)
   * let m2 = l.$(2, 2)
   * let m3 = l.div(m1, m2)
   *
   * m3 instanceof M // true
   * m1 !== m3 // true
   * l.eq(m1, l.$(4, 6)) // true
   * l.eq(m3, l.$(2, 3)) // true
   * l.div(m1, l.$(1, 2, 3)) // Error
   */
  div (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.hasSameDim(m2)) {
      return this.idiv(this.copy(m1), m2)
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#idiv method divides `m1` by `m2` *in place*
   * element-wise.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m1`, or a new instance of {@link Matrix} if `m1` is not an instance of
   * {@link Matrix}.
   *
   * @throws {Error}
   * if the dimensions of `m1` and `m2` are not the same.
   *
   * @throws {Error}
   * if `m1` or `m2` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(4, 6)
   * let m2 = l.$(2, 2)
   * let m3 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.idiv(m1, m2)
   * m1 === m3 // true
   * m1 instanceof M // true
   * l.eq(m1, l.$(2, 3)) // true
   *
   * m1 = l.$(1, 2, 3, 4).setDim(2, 2)
   * m2 = l.$(5, 7, 5, 3).setDim(2, 2)
   * l.idiv(l.lup(m1), m2) // Error
   * l.idiv(m1, l.lup(m2)) // Error
   * l.idiv(m1, l.$(1, 2, 3)) // Error
   */
  idiv (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP() || m2.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by idiv method.')
    }
    if (m1.hasSameDim(m2)) {
      const salg = this.salg;
      for (let i = m1.length - 1; i >= 0; i -= 1) {
        m1[i] = salg.idiv(m1[i], m2[i]);
      }
      return m1
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#neg method returns the result of
   * the element-wise multiplication `m` times `-1`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the result of the element-wise multiplication `m` times `-1`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(4, 6)
   * let m2 = l.neg(m1)
   *
   * m2 instanceof M // true
   * m1 !== m2 // true
   * l.eq(m1, l.$(4, 6)) // true
   * l.eq(m2, l.$(-4, -6)) // true
   */
  neg (m) {
    return this.ineg(this.copy(m))
  }

  /**
   * @desc
   * The LinearAlgebra#ineg method multiplies `m` by `-1` *in place*
   * element-wise.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m`, or a new instance of {@link Matrix} if `m` is not an instance of
   * {@link Matrix}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(4, 6)
   * let m2 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.ineg(m1)
   * m1 === m2 // true
   * m1 instanceof M // true
   * l.eq(m1, l.$(-4, -6)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.ilup(m1)
   * m2 = l.ineg(m2)
   *
   * m2 instanceof M // true
   * m2.isLUP() // true
   * r.eq(m2[0], -5) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], -5) // true
   * r.eq(m2[3], -3) // true
   */
  ineg (m) {
    m = this.cast(m);
    const salg = this.salg;
    if (m.isLUP()) {
      const n = m.getDim()[0];
      for (let i = n - 1; i >= 0; i -= 1) {
        const ni = n * i;
        for (let j = i; j >= 0; j -= 1) {
          const nij = ni + j;
          m[nij] = salg.ineg(m[nij]);
        }
      }
    } else {
      for (let i = m.length - 1; i >= 0; i -= 1) {
        m[i] = salg.ineg(m[i]);
      }
    }
    return m
  }

  /**
   * @desc
   * The LinearAlgebra#cjg method returns the complex conjugate of `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the complex conjugate of `m`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(4, c.$(0, 6), 2)
   * let m2 = l.cjg(m1)
   *
   * m2 instanceof M // true
   * m1 !== m2 // true
   * l.eq(m1, l.$(4, c.$(0, 6), 2)) // true
   * l.eq(m2, l.$(4, c.$(0, -6), 2)) // true
   */
  cjg (m) {
    return this.icjg(this.copy(m))
  }

  /**
   * @desc
   * The LinearAlgebra#icjg method
   * evaluates the complex conjugate of `m` and stores the result to `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m`, or a new instance of {@link Matrix} if 'm' is not an instance of
   * {@link Matrix}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(4, c.$(0, 6), 2)
   * let m2 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.icjg(m1)
   * m1 === m2 // true
   * m1 instanceof M // true
   * l.eq(m1, l.$(4, c.$(0, -6), 2)) // true
   */
  icjg (m) {
    m = this.cast(m);
    const salg = this.salg;
    for (let i = m.length - 1; i >= 0; i -= 1) {
      m[i] = salg.icjg(m[i]);
    }
    return m
  }

  /**
   * @desc
   * The LinearAlgebra#transpose method returns the transpose of `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the transpose of `m`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(4, c.$(0, 6), 2, 3).setDim(2, 2)
   * let m2 = l.transpose(m1)
   *
   * m2 instanceof M // true
   * m1 !== m2 // true
   * l.eq(m1, l.$(4, c.$(0, 6), 2, 3).setDim(2, 2)) // true
   * l.eq(m2, l.$(4, 2, c.$(0, 6), 3).setDim(2, 2)) // true
   */
  transpose (m) {
    return this.itranspose(this.copy(m))
  }

  /**
   * @desc
   * The LinearAlgebra#itranspose method
   * calculates the transpose of `m` and stores the result to `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m`, or a new instance of {@link Matrix} if `m` is not an instance of
   * {@link Matrix}.
   *
   * @throws {Error}
   * if `m` is LU-factorised.
   *
   * @throws {Error}
   * if the dimension of `m` is adaptive.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(4, c.$(0, 6), 2, 3).setDim(2, 2)
   * let m2 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.itranspose(m1)
   * m1 === m2 // true
   * m1 instanceof M // true
   * l.eq(m1, l.$(4, 2, c.$(0, 6), 3).setDim(2, 2)) // true
   *
   * m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * l.itranspose(l.lup(m1)) // Error
   * l.itranspose(l.$(5, 4, 5, 7)) // Error
   */
  itranspose (m) {
    m = this.cast(m);
    if (m.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by itranspose ' +
          'method.')
    }
    if (m.isAdaptive()) {
      throw Error('adaptive matrix cannot be transposed.')
    } else {
      const dim = m.getDim();
      const nRow = dim[0];
      const nCol = dim[1];
      const swap = m.slice();
      let k = m.length - 1;
      for (let i = nRow - 1; i >= 0; i -= 1) {
        for (let j = nCol - 1; j >= 0; j -= 1, k -= 1) {
          const idx = i + j * nRow;
          m[idx] = swap[k];
        }
      }
      m.setDim(m.nCol, m.nRow);
      return m
    }
  }

  /**
   * @desc
   * The LinearAlgebra#cjgTranspose method returns
   * the conjugate transpose of `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the transpose of `m`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(4, c.$(0, 6), 2, 3).setDim(2, 2)
   * let m2 = l.cjgTranspose(m1)
   *
   * m2 instanceof M // true
   * m1 !== m2 // true
   * l.eq(m1, l.$(4, c.$(0, 6), 2, 3).setDim(2, 2)) // true
   * l.eq(m2, l.$(4, 2, c.$(0, -6), 3).setDim(2, 2)) // true
   */
  cjgTranspose (m) {
    return this.icjgTranspose(this.copy(m))
  }

  /**
   * @desc
   * The LinearAlgebra#icjgTranspose method
   * calculates the conjugate transpose of `m` and stores the result to `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m`, or a new instance of {@link Matrix} if `m` is not an instance of
   * {@link Matrix}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(4, c.$(0, 6), 2, 3).setDim(2, 2)
   * let m2 = m1
   *
   * // GOOD-PRACTICE!
   * m1 = l.icjgTranspose(m1)
   * m1 === m2 // true
   * m1 instanceof M // true
   * l.eq(m1, l.$(4, 2, c.$(0, -6), 3).setDim(2, 2)) // true
   */
  icjgTranspose (m) {
    return this.icjg(this.itranspose(m))
  }

  /**
   * @desc
   * The LinearAlgebra#abs method returns the absolute value
   * (Frobenius norm) of `m`.
   *
   * CAUTION: this method is not implemented for exact algebra.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {RealAlgebraicElement}
   * a {@link RealAlgebraicElement}
   * representing the absolute value (Frobenius norm) of `m`.
   *
   * @throws {Error}
   * if `this` is an implementation of exact algebra.
   *
   * @throws {Error}
   * if `m` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m = l.$(1, -1)
   *
   * l.abs(m) // Error
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m = new M(1, -1)
   *
   * let a = l.abs(m)
   * a instanceof M // false
   * typeof a === 'number' // true
   * l.eq(m, new M(1, -1)) // true
   * r.eq(a, Math.sqrt(2)) // true
   *
   * m = new M(5, 4, 5, 7).setDim(2, 2)
   * l.abs(l.lup(m)) // Error
   */
  abs (m) {
    m = this.cast(m);
    if (m.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by abs method.')
    }
    if (this.isExact()) {
      throw Error('`abs` is not implemented for exact algebra.')
    } else {
      return Math.sqrt(this.abs2(m))
    }
  }

  /**
   * @desc
   * The LinearAlgebra#abs2 method returns
   * the square of the absolute value (Frobenius norm) of `m`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {RealAlgebraicElement}
   * a {@link RealAlgebraicElement}
   * representing the square of the absolute value (Frobenius nomr) of `m`.
   *
   * @throws {Error}
   * if `m` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m = l.$(1, -1)
   *
   * let a = l.abs2(m)
   * a instanceof M // false
   * a instanceof P // true
   * l.eq(m, l.$(1, -1)) // true
   * r.eq(a, 2) // true
   *
   * m = l.$(5, 4, 5, 7).setDim(2, 2)
   * l.abs2(l.lup(m)) // Error
   */
  abs2 (m) {
    m = this.cast(m);
    if (m.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by abs2 method.')
    }
    const salg = this.salg;
    const ralg = salg.ralg;
    let sum = ralg.$(0);
    for (let i = m.length - 1; i >= 0; i -= 1) {
      sum = ralg.iadd(sum, salg.abs2(m[i]));
    }
    return sum
  }

  /**
   * @desc
   * The LinearAlgebra#dot method returns
   * the dot product of `m1` and `m2` (as vectors).
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {ScalarAlgebraicElement}
   * a {@link ScalarAlgebraicElement}
   * representing the dot product of `m1` and `m2` (as vectors).
   *
   * @throws {Error}
   * if `m1` and `m2` are not the same dimension.
   *
   * @throws {Error}
   * if `m1` or `m2` is LU-factorised.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra, ComplexAlgebraicElement as C }
   *   from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1))
   * let m2 = l.$(1, c.$(0, 1))
   * let m3 = l.$(1, c.$(0, -1))
   *
   * let z = l.dot(m1, m2)
   * z instanceof M // false
   * z instanceof C // true
   * l.eq(m1, l.$(1, c.$(0, 1))) // true
   * c.eq(z, 2) // true
   *
   * let w = l.dot(m1, m3)
   * w instanceof M // false
   * w instanceof C // true
   * c.eq(w, 0) // true
   *
   * m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * m2 = l.$(1, 2, 3, 4).setDim(2, 2)
   * l.dot(m1, l.lup(m2)) // Error
   * l.dot(l.lup(m1), m2) // Error
   * l.dot(l.$(1, 2), l.$(1)) // Error
   */
  dot (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP() || m2.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by dot method.')
    }
    if (m1.hasSameDim(m2)) {
      const salg = this.salg;
      let sum = salg.$(0);
      for (let i = m1.length - 1; i >= 0; i -= 1) {
        sum = salg.iadd(sum, salg.imul(salg.cjg(m1[i]), m2[i]));
      }
      return sum
    } else {
      throw Error('the dimesions of `m1` and `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#smul method returns
   * the product of `m` and a scalar `s`.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @param {ScalarAlgebraicElement} s
   * a {@link ScalarAlgebraicElement}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the product of `m` and a scalar `s`.
   *
   * @version 1.0.1
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1))
   * let m2 = l.smul(m1, c.$(0, 2))
   *
   * m2 instanceof M // true
   * m2 !== m1 // true
   * l.eq(m1, l.$(1, c.$(0, 1))) // true
   * l.eq(m2, l.$(c.$(0, 2), -2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.ilup(m1)
   * let m3 = l.smul(m2, 2)
   *
   * m3 instanceof M // true
   * m3.isLUP() // true
   * r.eq(m3[0], 10) // true
   * r.eq(m3[1], r.$(4, 5)) // true
   * r.eq(m3[2], 10) // true
   * r.eq(m3[3], 6) // true
   */
  smul (m, s) {
    return this.ismul(this.copy(m), s)
  }

  /**
   * @desc
   * The LinearAlgebra#ismul method multiplies `m` by
   * a scalar `s` *in place*.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @param {ScalarAlgebraicElement} s
   * a {@link ScalarAlgebraicElement}.
   *
   * @return {Matrix}
   * `m`, or a new instance of {@link Matrix} if `m` is not an instance of
   * {@link Matrix}.
   *
   * @version 1.0.1
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1))
   * let m2 = m1
   * m1 = l.ismul(m1, c.$(0, 2))
   *
   * m1 instanceof M // true
   * m1 === m2 // true
   * l.eq(m1, l.$(c.$(0, 2), -2)) // true
   * l.eq(m2, l.$(c.$(0, 2), -2)) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.ilup(m1)
   * m2 = l.ismul(m2, 2)
   *
   * m2 instanceof M // true
   * m2.isLUP() // true
   * r.eq(m2[0], 10) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], 10) // true
   * r.eq(m2[3], 6) // true
   */
  ismul (m, s) {
    m = this.cast(m);
    const salg = this.salg;
    s = salg.cast(s);
    if (m.isLUP()) {
      const n = m.getDim()[0];
      for (let i = n - 1; i >= 0; i -= 1) {
        const ni = n * i;
        for (let j = i; j >= 0; j -= 1) {
          const nij = ni + j;
          m[nij] = salg.imul(m[nij], s);
        }
      }
    } else {
      for (let i = m.length - 1; i >= 0; i -= 1) {
        m[i] = salg.imul(m[i], s);
      }
    }
    return m
  }

  /**
   * @desc
   * The LinearAlgebra#sdiv method returns the result of the division `m` over
   * `s`, where `s` is a scalar.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @param {ScalarAlgebraicElement} s
   * a {@link ScalarAlgebraicElement}.
   *
   * @return {Matrix}
   * a new {@link Matrix}
   * representing the division `m` over `s`.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1))
   * let m2 = l.sdiv(m1, c.$(0, 2))
   *
   * m2 instanceof M // true
   * m2 !== m1 // true
   * l.eq(m1, l.$(1, c.$(0, 1))) // true
   * l.eq(m2, l.$(c.$(0, r.$(-1, 2)), r.$(1, 2))) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.ilup(m1)
   * let m3 = l.sdiv(m2, r.$(1, 2))
   *
   * m3 instanceof M // true
   * m3.isLUP() // true
   * r.eq(m3[0], 10) // true
   * r.eq(m3[1], r.$(4, 5)) // true
   * r.eq(m3[2], 10) // true
   * r.eq(m3[3], 6) // true
   */
  sdiv (m, s) {
    return this.isdiv(this.copy(m), s)
  }

  /**
   * @desc
   * The LinearAlgebra#isdiv method divides `m` by a scalar `s` *in place*.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @param {ScalarAlgebraicElement} s
   * a {@link ScalarAlgebraicElement}.
   *
   * @return {Matrix}
   * `m`, or a new instance of {@link Matrix} if `m` is not an instance of
   * {@link Matrix}.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1))
   * let m2 = m1
   * m1 = l.isdiv(m1, c.$(0, 2))
   *
   * m1 instanceof M // true
   * m1 === m2 // true
   * l.eq(m1, l.$(c.$(0, r.$(-1, 2)), r.$(1, 2))) // true
   * l.eq(m2, l.$(c.$(0, r.$(-1, 2)), r.$(1, 2))) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.ilup(m1)
   * m2 = l.isdiv(m2, r.$(1, 2))
   *
   * m2 instanceof M // true
   * m2.isLUP() // true
   * r.eq(m2[0], 10) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], 10) // true
   */
  isdiv (m, s) {
    m = this.cast(m);
    const salg = this.salg;
    s = salg.cast(s);
    if (m.isLUP()) {
      const n = m.getDim()[0];
      for (let i = n - 1; i >= 0; i -= 1) {
        const ni = n * i;
        for (let j = i; j >= 0; j -= 1) {
          const nij = ni + j;
          m[nij] = salg.idiv(m[nij], s);
        }
      }
    } else {
      for (let i = m.length - 1; i >= 0; i -= 1) {
        m[i] = salg.idiv(m[i], s);
      }
    }
    return m
  }

  /**
   * @desc
   * The LinearAlgebra#mmul method returns the matrix product of `m1` and `m2`.
   *
   * If `m1` is adaptive, `m1.nCol` is assumed to be equal to `m2.nRow`.
   *
   * If `m2` is adaptive, `m2.nRow` is assumed to be equal to `m1.nCol`.
   *
   * If `m1` or `m2` is adaptive, the product is also adaptive,
   * otherwise `nRow` and `nCol` of the product are set at `m1.nRow` and
   * `m2.nCol`, respectively.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix} representing the matrix product of `m1` and `m2`.
   *
   * @throws {Error}
   * if `m1` or `m2` is LU-factorised.
   *
   * @throws {Error}
   * if the dimensions of both `m1` and `m2` are adaptive.
   *
   * @throws {Error}
   * if `nCol` of `m1` and `nRow` of `m2` are not the same.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1), 3, 4).setDim(2, 0)
   * let m2 = l.$(1, 2, 3, 4).setDim(2, 0)
   * let m3 = l.mmul(m1, m2)
   * let m4 = l.$(c.$(1, 3), c.$(2, 4), 15, 22)
   * m4.setDim(2, 0)
   *
   * m3 instanceof M // true
   * l.eq(m1, l.$(1, c.$(0, 1), 3, 4).setDim(0, 2)) // true
   * l.eq(m2, l.$(1, 2, 3, 4).setDim(2, 0)) // true
   * l.eq(m3, m4) // true
   * m3.nRow // 2
   * m3.nCol // 0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1), 3, 4).setDim(0, 2)
   * let m2 = l.$(1, 2, 3, 4).setDim(2, 0)
   * let m3 = l.mmul(m1, m2)
   * let m4 = l.$(c.$(1, 3), c.$(2, 4), 15, 22)
   *
   * m3 instanceof M // true
   * l.eq(m1, l.$(1, c.$(0, 1), 3, 4).setDim(0, 2)) // true
   * l.eq(m2, l.$(1, 2, 3, 4).setDim(2, 0)) // true
   * l.eq(m3, m4) // true
   * m3.nRow // 0
   * m3.nCol // 0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, c.$(0, 1))
   * let m2 = l.$(1, 2, 3, 4).setDim(2, 0)
   * let m3 = l.mmul(m1, m2)
   * let m4 = l.mmul(m2, m1)
   *
   * l.eq(m1, l.$(1, c.$(0, 1))) // true
   * l.eq(m2, l.$(1, 2, 3, 4).setDim(2, 0)) // true
   * m3 instanceof M // true
   * m4 instanceof M // true
   * m3.isAdaptive() // true
   * m4.isAdaptive() // true
   * l.eq(m3, l.$(c.$(1, 3), c.$(2, 4))) // true
   * l.eq(m4, l.$(c.$(1, 2), c.$(3, 4))) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * l.mmul(l.$(), l.$()).toString() // '()'
   * let m1 = l.$(1, 5, 3, 4).setDim(2, 0)
   * let m2 = l.$(1, 2, 3, 4).setDim(2, 0)
   * l.mmul(l.lup(m1), m2) // Error
   * l.mmul(m1, l.lup(m2)) // Error
   * l.mmul(l.$(1, 5).setDim(1, 2), l.$(1, 5).setDim(1, 2)) // Error
   * l.mmul(l.$(1, 5), l.$(1, 5)) // Error
   */
  mmul (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP() || m2.isLUP()) {
      throw Error('LU-factorised matrices are not suppoted by mmul method.')
    }
    let dim1;
    let dim2;
    let adaptive;
    if (m1.isAdaptive()) {
      if (m2.isAdaptive()) {
        if (m1.length === 0 && m2.length === 0) {
          return new Matrix()
        } else {
          throw Error('dimensions of `m1` and `m2` cannot be determined.')
        }
      } else {
        dim2 = m2.getDim();
        dim1 = m1.getDim(0, dim2[0]);
        adaptive = true;
      }
    } else if (m2.isAdaptive()) {
      dim1 = m1.getDim();
      dim2 = m2.getDim(dim1[1], 0);
      adaptive = true;
    } else {
      dim1 = m1.getDim();
      dim2 = m2.getDim();
      adaptive = false;
    }
    const nCol1 = dim1[1];
    const nRow2 = dim2[0];
    if (nCol1 === nRow2) {
      const salg = this.salg;
      const nRow1 = dim1[0];
      const nCol2 = dim2[1];
      const m3 = new Matrix();
      if (!adaptive) {
        m3.setDim(m1.nRow, m2.nCol);
      }
      for (let i = 0; i < nRow1; i += 1) {
        const ii = i * nCol1;
        for (let j = 0; j < nCol2; j += 1) {
          let sum = salg.$(0);
          for (let k = nCol1 - 1; k >= 0; k -= 1) {
            sum = salg.iadd(sum, salg.mul(m1[ii + k], m2[k * nCol2 + j]));
          }
          m3.push(sum);
        }
      }
      return m3
    } else {
      throw Error('`nCol` of `m1` and `nRow` of `m2` must be the same.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#lup method calculates
   * LU-factorisation of `m` of the form *Pm* = *LU*.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix} representing the LU-factorisation of `m`.
   *
   * @throws {Error}
   * if `m` cannot be interpreted as a square matrix.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.lup(m1)
   *
   * m1 !== m2 // true
   * m2 instanceof M // true
   * m1.permutation === null // true
   * m2.permutation !== null // true
   * m2.permutation.length === 0 // true
   * r.eq(m2[0], 5) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], 5) // true
   * r.eq(m2[3], 3) // true
   *
   * l.lup(l.$(5, 4, 5, 7)).getDim()[0] // 2
   * l.lup(l.$(5, 4, 5, 7).setDim(1, 4)) // Error
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(0, 3, 5, 4).setDim(2, 2)
   * let m2 = l.lup(m1)
   *
   * m1 !== m2 // true
   * m2 instanceof M // true
   * m1.permutation === null // true
   * m2.permutation !== null // true
   * m2.permutation.length === 2 // true
   * m2.permutation[0] === 0 // true
   * m2.permutation[1] === 1 // true
   * r.eq(m2[0], 5) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], 0) // true
   * r.eq(m2[3], 3) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2, 1, 2).setDim(2, 2)
   * let m2 = l.lup(m1)
   *
   * m1 !== m2 // true
   * m2 instanceof M // true
   * m2.permutation !== null // true
   * r.eq(m2[0], 0) // true
   * r.eq(m2[3], 0) // true
   *
   * let m3 = l.lup(m2)
   * m1 !== m3 // true
   * m2 !== m3 // true
   * m3 instanceof M // true
   * m3.permutation !== null // true
   * r.eq(m3[0], 0) // true
   * r.eq(m3[3], 0) // true
   *
   * l.lup(l.$(1, 2, 3)) // Error
   */
  lup (m) {
    m = this.cast(m);
    if (m.isLUP()) {
      return this.copy(m)
    } else if (m.isAdaptive()) {
      const dim = Math.round(Math.sqrt(m.length));
      if (dim * dim === m.length) {
        const m2 = this.copy(m).setDim(dim);
        return this.ilup(m2)
      } else {
        throw Error('m cannot be interpreted as a square matrix.')
      }
    } else if (m.isSquare()) {
      return this.ilup(this.copy(m))
    } else {
      throw Error('m must be a square matrix.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#ilup method calculates
   * LU-factorisation of `m` of the form *Pm* = *LU* *in-place*.
   * If `m` is a singular matrix,
   * `m[0]` and `m[n * n - 1]` is set at zero,
   * i.e. this method does not return a correct LU-factorised matrix,
   * but the determinant (as calculated by det method) is correct (= 0).
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m`, or a new instance of {@link Matrix} if `m` is not an instance of
   * {@link Matrix}.
   *
   * @throws {Error}
   * if `m` cannot be interpreted as a square matrix.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.ilup(m1)
   *
   * m1 === m2 // true
   * m2 instanceof M // true
   * m2.permutation !== null // true
   * m2.permutation.length === 0 // true
   * r.eq(m2[0], 5) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], 5) // true
   * r.eq(m2[3], 3) // true
   *
   * l.ilup(l.$(5, 4, 5, 7)).getDim()[0] // 2
   * l.ilup(l.$(5, 4, 5, 7).setDim(1, 4)) // Error
   * l.ilup(l.$(5, 4, 5)) // Error
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(0, 3, 5, 4).setDim(2, 2)
   * let m2 = l.ilup(m1)
   *
   * m1 === m2 // true
   * m2 instanceof M // true
   * m2.permutation !== null // true
   * m2.permutation.length === 2 // true
   * m2.permutation[0] === 0 // true
   * m2.permutation[1] === 1 // true
   * r.eq(m2[0], 5) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], 0) // true
   * r.eq(m2[3], 3) // true
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra(1e-5)
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(0, 3, 5, 4).setDim(2, 2)
   * let m2 = l.ilup(m1)
   * let m3 = l.ilup(m2)
   *
   * m2 === m3 // true
   *
   * m1 === m2 // true
   * m2 instanceof M // true
   * m2.permutation !== null // true
   * m2.permutation.length === 2 // true
   * m2.permutation[0] === 0 // true
   * m2.permutation[1] === 1 // true
   * r.eq(m2[0], 5) // true
   * r.eq(m2[1], r.$(4, 5)) // true
   * r.eq(m2[2], 0) // true
   * r.eq(m2[3], 3) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(0, 2, 3, 0, 2, 3, 0, 2, 3).setDim(3, 3)
   * let m2 = l.ilup(m1)
   *
   * m1 === m2 // true
   * m2 instanceof M // true
   * m2.permutation !== null // true
   * r.eq(m2[0], 0) // true
   * r.eq(m2[8], 0) // true
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra(1e-5)
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2, 1, 2).setDim(2, 2)
   * let m2 = l.ilup(m1)
   *
   * m1 === m2 // true
   * m2 instanceof M // true
   * m2.permutation !== null // true
   * r.eq(m2[0], 0) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 0, 0, 0, 1, 0, 0, 0, 1).setDim(3, 3)
   * let m2 = l.ilup(m1)
   *
   * m1 === m2 // true
   * m2 instanceof M // true
   * m2.permutation !== null // true
   * m2.permutation.length === 0 // true
   * r.eq(m2[0], 1) // true
   * r.eq(m2[1], 0) // true
   * r.eq(m2[2], 0) // true
   * r.eq(m2[3], 0) // true
   * r.eq(m2[4], 1) // true
   * r.eq(m2[5], 0) // true
   * r.eq(m2[6], 0) // true
   * r.eq(m2[7], 0) // true
   * r.eq(m2[8], 1) // true
   */
  ilup (m) {
    m = this.cast(m);
    if (m.isLUP()) {
      return m
    } else if (m.isAdaptive()) {
      const dim = Math.round(Math.sqrt(m.length));
      if (dim * dim === m.length) {
        m.setDim(dim);
      } else {
        throw Error('m cannot be interpreted as a square matrix.')
      }
    }
    if (m.isSquare()) {
      const salg = this.salg;
      const ralg = salg.ralg;
      const p = m.permutation = [];
      const n = m.getDim()[0];
      for (let i = 0; i < n; i += 1) {
        const ni = n * i;
        if (this.isExact()) {
          if (salg.isZero(m[ni + i])) {
            for (let k = i + 1; k < n; k += 1) {
              if (!salg.isZero(m[n * k + i])) {
                m.swapRow(i, k);
                p.push(i, k);
                break
              }
              if (k === n - 1) {
                // singular, returns a zero determinant matrix
                m[0] = salg.num(0);
                m[n * n - 1] = salg.num(0);
                return m
              }
            }
          }
        } else {
          let maxabs = salg.abs(m[ni + i]);
          let maxk = i;
          for (let k = i + 1; k < n; k += 1) {
            const abs = salg.abs(m[n * k + i]);
            if (ralg.isPositive(ralg.sub(abs, maxabs))) {
              maxabs = abs;
              maxk = k;
            }
          }
          if (salg.isZero(maxabs)) {
            // singular, returns a zero determinant matrix
            m[0] = salg.num(0);
            m[n * n - 1] = salg.num(0);
            return m
          }
          if (i !== maxk) {
            m.swapRow(i, maxk);
            p.push(i, maxk);
          }
        }
        for (let j = i + 1; j < n; j += 1) {
          const idx = ni + j;
          for (let k = i - 1; k >= 0; k -= 1) {
            m[idx] = salg.isub(m[idx], salg.mul(m[ni + k], m[n * k + j]));
          }
          m[idx] = salg.idiv(m[idx], m[ni + i]);
        }
        {
          const j = i + 1;
          for (let k = j; k < n; k += 1) {
            const nk = n * k;
            const idx = nk + j;
            for (let l = j - 1; l >= 0; l -= 1) {
              m[idx] = salg.isub(m[idx], salg.mul(m[nk + l], m[n * l + j]));
            }
          }
        }
      }
      if (salg.isZero(m[n * n - 1])) {
        // singular, returns a zero determinant matrix
        m[0] = salg.num(0);
      }
      return m
    } else {
      throw Error('m must be a square matrix.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#solve method calculates
   * either `m1^-1 m2` (if `m1` is LU-factorised)
   * or `m1 m2^-1` (if `m2` is LU-factorised).
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * a new {@link Matrix} representing the result.
   *
   * @throws {Error}
   * if both `m1` and `m2` are LU-factorised.
   *
   * @throws {Error}
   * if neither `m1` nor `m2` is LU-factorised.
   *
   * @throws {Error}
   * if `nCol` of `m1` and `nRow` of `m2` is not the same.
   *
   * @version 2.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.lup(m1)
   * let m3 = l.solve(m1, m2)
   *
   * m3 instanceof M // true
   * m3 !== m1 // true
   * m3 !== m2 // true
   * m3.permutation === null // true
   * r.eq(m3[0], 1) // true
   * r.eq(m3[1], 0) // true
   * r.eq(m3[2], 0) // true
   * r.eq(m3[3], 1) // true
   *
   * let m4 = l.$(5, 4, 5, 7)
   * let m5 = l.solve(m4, m2)
   * m5 instanceof M // true
   * m5 !== m4 // true
   * m5 !== m2 // true
   * m5.permutation === null // true
   * r.eq(m5[0], 1) // true
   * r.eq(m5[1], 0) // true
   * r.eq(m5[2], 0) // true
   * r.eq(m5[3], 1) // true
   *
   * let m6 = l.$(5, 4, 5, 7)
   * let m7 = l.solve(m2, m6)
   * m7 instanceof M // true
   * m7 !== m6 // true
   * m7 !== m2 // true
   * m7.permutation === null // true
   * r.eq(m7[0], 1) // true
   * r.eq(m7[1], 0) // true
   * r.eq(m7[2], 0) // true
   * r.eq(m7[3], 1) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.lup(m1)
   * let m3 = l.solve(m2, m1)
   *
   * m3 instanceof M // true
   * m3 !== m1 // true
   * m3 !== m2 // true
   * m3.permutation === null // true
   * r.eq(m3[0], 1) // true
   * r.eq(m3[1], 0) // true
   * r.eq(m3[2], 0) // true
   * r.eq(m3[3], 1) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.copy(m1)
   * l.solve(m1, m2) // Error
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.lup(m1)
   * m1 = l.ilup(m1)
   * l.solve(m1, m2) // Error
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2, 1, 2).setDim(2, 2)
   * let m2 = l.lup(m1)
   * l.solve(m2, m1) // Error
   * l.solve(m1, m2) // Error
   * l.solve(m2, l.$(1, 2, 1).setDim(1, 3)) // Error
   * l.solve(l.$(1, 2, 1).setDim(1, 3), m2) // Error
   */
  solve (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP()) {
      if (m2.isLUP()) {
        throw Error('both `m1` and `m1` are LU-factorised.')
      } else {
        const dim1 = m1.getDim();
        const dim2 = m2.isAdaptive() ? m2.getDim(dim1[1], 0) : m2.getDim();
        if (dim1[1] !== dim2[0]) {
          throw Error('`nCol` of `m1` and `nRow` of `m2` cannot be ' +
            'interpreted as the same.')
        } else {
          return this.isolve(m1, this.copy(m2))
        }
      }
    } else if (m2.isLUP()) {
      const dim2 = m2.getDim();
      const dim1 = m1.isAdaptive() ? m1.getDim(0, dim2[0]) : m1.getDim();
      if (dim2[0] !== dim1[1]) {
        throw Error('`nCol` of `m1` and `nRow` of `m2` cannot be ' +
          'interpreted as the same.')
      } else {
        return this.isolve(this.copy(m1), m2)
      }
    } else {
      throw Error('neither `m1` nor `m2` is LU-factorised.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#isolve method calculates
   * either `m1^-1 m2` (if `m1` is LU-factorised)
   * or `m1 m2^-1` (if `m2` is LU-factorised) *in place*.
   * The results are stored to `m1` if `m2` is LU-factorised
   * or otherwise to `m2`.
   *
   * @param {Matrix} m1
   * a {@link Matrix}.
   *
   * @param {Matrix} m2
   * a {@link Matrix}.
   *
   * @return {Matrix}
   * `m1` if `m2` is LU-factorised or otherwise 'm2'.
   * If `m1` or `m2` that is to be returned is not an instance of
   * {@link Matrix}, a new instance of {@link Matrix} is returned.
   *
   * @throws {Error}
   * if both `m1` and `m2` are LU-factorised.
   *
   * @throws {Error}
   * if neither `m1` nor `m2` is LU-factorised.
   *
   * @throws {Error}
   * if `nCol` of `m1` and `nRow` of `m2` is not the same.
   *
   * @throws {Error}
   * if the LU-factorised matrix is singular.
   *
   * @version 2.1.1
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.lup(m1)
   * let m3 = l.isolve(m1, m2)
   *
   * m3 instanceof M // true
   * m3 === m1 // true
   * m3 !== m2 // true
   * m3.permutation === null // true
   * r.eq(m3[0], 1) // true
   * r.eq(m3[1], 0) // true
   * r.eq(m3[2], 0) // true
   * r.eq(m3[3], 1) // true
   *
   * let m4 = l.$(5, 4, 5, 7)
   * let m5 = l.isolve(m4, m2)
   * m5 instanceof M // true
   * m5 === m4 // true
   * m5 !== m2 // true
   * m5.permutation === null // true
   * r.eq(m5[0], 1) // true
   * r.eq(m5[1], 0) // true
   * r.eq(m5[2], 0) // true
   * r.eq(m5[3], 1) // true
   *
   * let m6 = l.$(5, 4, 5, 7)
   * let m7 = l.isolve(m2, m6)
   * m7 instanceof M // true
   * m7 === m6 // true
   * m7 !== m2 // true
   * m7.permutation === null // true
   * r.eq(m7[0], 1) // true
   * r.eq(m7[1], 0) // true
   * r.eq(m7[2], 0) // true
   * r.eq(m7[3], 1) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(0, 4, 5, 7).setDim(2, 2)
   * let m2 = l.lup(m1)
   * let m3 = l.isolve(m1, m2)
   *
   * m3 instanceof M // true
   * m3 === m1 // true
   * m3 !== m2 // true
   * m3.permutation === null // true
   * r.eq(m3[0], 1) // true
   * r.eq(m3[1], 0) // true
   * r.eq(m3[2], 0) // true
   * r.eq(m3[3], 1) // true
   *
   * m1 = l.$(0, 4, 5, 7).setDim(2, 2)
   * m3 = l.isolve(m2, m1)
   *
   * m3 instanceof M // true
   * m3 === m1 // true
   * m3 !== m2 // true
   * m3.permutation === null // true
   * r.eq(m3[0], 1) // true
   * r.eq(m3[1], 0) // true
   * r.eq(m3[2], 0) // true
   * r.eq(m3[3], 1) // true
   *
   * l.isolve(l.$(0, 4, 5).setDim(1, 3), m2) // Error
   * l.isolve(m2, l.$(0, 4, 5).setDim(1, 3)) // Error
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.copy(m1)
   * l.isolve(m1, m2) // Error
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let m2 = l.lup(m1)
   * m1 = l.ilup(m1)
   * l.isolve(m1, m2) // Error
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m1 = l.$(1, 2, 1, 2).setDim(2, 2)
   * let m2 = l.lup(m1)
   * l.isolve(m2, m1) // Error
   * l.isolve(m1, m2) // Error
   */
  isolve (m1, m2) {
    m1 = this.cast(m1);
    m2 = this.cast(m2);
    if (m1.isLUP()) {
      if (m2.isLUP()) {
        throw Error('both `m1` and `m1` are LU-factorised.')
      }
      const dim1 = m1.getDim();
      const dim = m2.isAdaptive() ? m2.getDim(dim1[1], 0) : m2.getDim();
      const n = dim[0];
      if (dim1[1] !== n) {
        throw Error('`nCol` of `m1` and `nRow` of `m2` cannot be interpreted ' +
          'as the same.')
      } else {
        const p = m1.permutation;
        // ad hoc fix ...
        const flag = m2.isAdaptive();
        if (flag) {
          m2.setDim(dim1[1]);
        }
        for (let i = 0, np = p.length; i < np; i += 2) {
          m2.swapRow(p[i], p[i + 1]);
        }
        if (flag) {
          m2.setDim(0);
        }
        const salg = this.salg;
        const nCol = dim[1];
        for (let i = 0; i < n; i += 1) {
          const ni1 = n * i;
          const m1ii = m1[ni1 + i];
          if (salg.isZero(m1ii)) {
            throw Error('`m1` is singular.')
          }
          const ni2 = nCol * i;
          for (let j = 0; j < nCol; j += 1) {
            const nij = ni2 + j;
            for (let k = i - 1; k >= 0; k -= 1) {
              m2[nij] = salg.isub(m2[nij],
                salg.mul(m1[ni1 + k], m2[nCol * k + j]));
            }
            m2[nij] = salg.idiv(m2[nij], m1ii);
          }
        }
        for (let i = n - 1; i >= 0; i -= 1) {
          const ni1 = n * i;
          const ni2 = nCol * i;
          for (let j = 0; j < nCol; j += 1) {
            const nij = ni2 + j;
            for (let k = i + 1; k < n; k += 1) {
              m2[nij] = salg.isub(m2[nij],
                salg.mul(m1[ni1 + k], m2[nCol * k + j]));
            }
          }
        }
        return m2
      }
    } else if (m2.isLUP()) {
      const dim2 = m2.getDim();
      const dim = m1.isAdaptive() ? m1.getDim(0, dim2[0]) : m1.getDim();
      const n = dim[1];
      if (n !== dim2[0]) {
        throw Error('`nCol` of `m1` and `nRow` of `m2` cannot be interpreted ' +
          'as the same.')
      } else {
        const salg = this.salg;
        const nRow = dim[0];
        for (let i = 0; i < nRow; i += 1) {
          const ni = n * i;
          for (let j = 0; j < n; j += 1) {
            const nij = ni + j;
            for (let k = j - 1; k >= 0; k -= 1) {
              m1[nij] = salg.isub(m1[nij], salg.mul(m1[ni + k], m2[n * k + j]));
            }
          }
        }
        for (let i = 0; i < nRow; i += 1) {
          const ni = n * i;
          for (let j = n - 1; j >= 0; j -= 1) {
            const m2jj = m2[n * j + j];
            if (salg.isZero(m2jj)) {
              throw Error('`m2` is singular.')
            }
            const nij = ni + j;
            for (let k = j + 1; k < n; k += 1) {
              m1[nij] = salg.isub(m1[nij], salg.mul(m1[ni + k], m2[n * k + j]));
            }
            m1[nij] = salg.idiv(m1[nij], m2jj);
          }
        }
        const p = m2.permutation;
        // ad hoc fix ...
        const flag = m1.isAdaptive();
        if (flag) {
          m1.setDim(0, dim2[0]);
        }
        for (let i = p.length - 2; i >= 0; i -= 2) {
          m1.swapCol(p[i], p[i + 1]);
        }
        if (flag) {
          m1.setDim(0);
        }
        // ... ad hoc fix
        return m1
      }
    } else {
      throw Error('neither `m1` nor `m2` is LU-factorised.')
    }
  }

  /**
   * @desc
   * The LinearAlgebra#det method calculates
   * the determinant of `m`, where `m` must be LU-factorised.
   *
   * @param {Matrix} m
   * a {@link Matrix}.
   *
   * @return {ScalarAlgebraicElement}
   * a {@link ScalarAlgebraicElement} representing
   * the determinant of `m`.
   *
   * @throws {Error}
   * if `m` is not a LU-factorised {@link Matrix}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let m = l.$(5, 4, 5, 7).setDim(2, 2)
   *
   * l.det(m) // Error
   *
   * m = l.ilup(m)
   *
   * r.eq(l.det(m), 15) // true
   *
   * let m2 = l.$(0, 5, 7, 5).setDim(2, 2)
   * m2 = l.ilup(m2)
   * r.eq(l.det(m2), -35) // true
   */
  det (m) {
    m = this.cast(m);
    if (!m.isLUP()) {
      throw Error('`m` must be LU-factorised.')
    }
    const salg = this.salg;
    const dim = m.getDim()[0];
    let prod = salg.num(1);
    for (let i = dim - 1; i >= 0; i -= 1) {
      prod = salg.imul(prod, m[i * dim + i]);
    }
    if (m.permutation.length % 4 !== 0) {
      prod = salg.ineg(prod);
    }
    return prod
  }

  /**
   * @desc
   * The reviver function for the {@link LinearAlgebraicElement}s.
   *
   * @type {Function}
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(5, 4, 5, 7).setDim(2, 2)
   * let str = JSON.stringify(m1)
   * let m2 = JSON.parse(str, l.reviver)
   * l.eq(m1, m2) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * let r = new RealAlgebra()
   * let c = new ComplexAlgebra(r)
   * let l = new LinearAlgebra(c)
   *
   * let m1 = l.$(1, 2, 1, 2).setDim(2, 2)
   * m1 = l.ilup(m1)
   * let str = JSON.stringify(m1)
   * let m2 = JSON.parse(str, l.reviver)
   * m1.isLUP() // true
   * m2.isLUP() // true
   * // nullify just to use eq method
   * m1.permutation = null
   * m2.permutation = null
   * l.eq(m1, m2) // true
   */
  get reviver () {
    const salg = this.salg;
    return function (key, value) {
      value = salg.reviver(key, value);
      value = Matrix.reviver(key, value);
      return value
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const rnum = new RealAlgebra(1e-10);
const lnum = new LinearAlgebra(rnum);

function inormalise (v0) {
  return lnum.isdiv(v0, lnum.abs(v0))
}

function cross3 (v0, v1) {
  return lnum.$(
    v0[1] * v1[2] - v0[2] * v1[1],
    v0[2] * v1[0] - v0[0] * v1[2],
    v0[0] * v1[1] - v0[1] * v1[0])
}

// generate a matrix which rotate CCW around v
// th: rotation angle in radian
function rotateV3 (th, v) {
  const c = Math.cos(th);
  const s = Math.sin(th);
  const d = 1 - c;
  const dv = lnum.smul(v, d);
  const sv = lnum.smul(v, s);
  const a00 = v[0] * dv[0];
  const a01 = v[0] * dv[1];
  const a02 = v[0] * dv[2];
  const a11 = v[1] * dv[1];
  const a12 = v[1] * dv[2];
  const a22 = v[2] * dv[2];
  return lnum.$(
    c + a00, -sv[2] + a01, sv[1] + a02,
    sv[2] + a01, c + a11, -sv[0] + a12,
    -sv[1] + a02, sv[0] + a12, c + a22).setDim(3, 3)
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const rnum$1 = new RealAlgebra();
const lnum$1 = new LinearAlgebra(rnum$1);

function interpolateDirection (v0, v1, v2, nsub, isub, jsub) {
  const ax1 = inormalise(cross3(v0, v1));
  const ax2 = inormalise(cross3(v0, v2));
  const th1 = Math.acos(lnum$1.dot(v0, v1));
  const th2 = Math.acos(lnum$1.dot(v0, v2));
  const v1i = lnum$1.mmul(rotateV3(th1 * isub / nsub, ax1), v0);
  const v2i = lnum$1.mmul(rotateV3(th2 * isub / nsub, ax2), v0);
  const ax3 = inormalise(cross3(v1i, v2i));
  const th3 = Math.acos(lnum$1.dot(v1i, v2i));
  return lnum$1.mmul(rotateV3(th3 * jsub / isub, ax3), v1i)
}

function genHalfOctahedron (nSub) {
  // numerical only
  const vv = [
    [0, 0, 1],
    [-1, 0, 0],
    [0, -1, 0],
    [1, 0, 0],
    [0, 1, 0]];
  const v = [];
  const id = [];
  // vertices
  v.push(...vv[0]);
  for (let iSub = 1; iSub <= nSub; iSub += 1) {
    for (let i = 1; i <= 4; i += 1) {
      const ip1 = (i % 4) + 1;
      for (let jSub = 0; jSub < iSub; jSub += 1) {
        v.push(...interpolateDirection(
          vv[0], vv[i], vv[ip1], nSub, iSub, jSub));
      }
    }
  }
  // indices
  id.push(1);
  for (let i = 1; i <= 4; i += 1) {
    id.push(i, 0);
  }
  id.push(1);
  let j = 1;
  let i = 5;
  for (let iSub = 1; iSub < nSub; iSub += 1) {
    const j0 = j;
    const i0 = i;
    for (let k = 1; k <= 4; k += 1) {
      id.push(j, i);
      i += 1;
      for (let jSub = 0; jSub < iSub; jSub += 1) {
        id.push(j, i);
        j += 1;
        i += 1;
      }
    }
    id.push(j0, i0);
  }
  id.push(j, j);
  return { v: v, i: id }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function genCylinder (nph) {
  // numerical only
  const vn = [];
  const id = [];
  const dph = -2 * Math.PI / nph;
  const c = [];
  const s = [];
  for (let i = 0; i < nph; i += 1) {
    const ph = i * dph;
    c.push(Math.cos(ph));
    s.push(Math.sin(ph));
  }
  // (vertex, normal vector) tuples
  vn.push(0, 0, 0);
  vn.push(0, 0, -1);
  for (let i = 0; i < nph; i += 1) {
    vn.push(c[i], s[i], 0);
    vn.push(0, 0, -1);
  }
  for (let i = 0; i < nph; i += 1) {
    vn.push(c[i], s[i], 0);
    vn.push(c[i], s[i], 0);
  }
  for (let i = 0; i < nph; i += 1) {
    vn.push(c[i], s[i], 1);
    vn.push(c[i], s[i], 0);
  }
  for (let i = 0; i < nph; i += 1) {
    vn.push(c[i], s[i], 1);
    vn.push(0, 0, 1);
  }
  vn.push(0, 0, 1);
  vn.push(0, 0, 1);
  // indices
  id.push(1);
  for (let i = 1; i <= nph; i += 1) {
    id.push(i, 0);
  }
  id.push(1);
  let start = 1;
  for (let j = 0; j < 3; j += 1) {
    for (let i = start, n = start + nph; i < n; i += 1) {
      id.push(i, i + nph);
    }
    id.push(start);
    start += nph;
    id.push(start);
  }
  for (let i = start, n = start + nph; i < n; i += 1) {
    id.push(i, n);
  }
  id.push(start);
  id.push(start);
  return { vn: vn, i: id }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const createVertexShader = (gl, src) => {
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, src);
  gl.compileShader(vs);
  return vs
};

const createVertexShaderDebug = (gl, src) => {
  const vs = createVertexShader(gl, src);
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
    console.warn(`
      Failed to compile a vertex shader: ${gl.getShaderInfoLog(vs)}
    `);
  }
  return vs
};

const createFragmentShader = (gl, src) => {
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, src);
  gl.compileShader(fs);
  return fs
};

const createFragmentShaderDebug = (gl, src) => {
  const fs = createFragmentShader(gl, src);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
    console.warn(`
      Failed to compile a fragment shader: ${gl.getShaderInfoLog(fs)}
    `);
  }
  return fs
};

const createProgram = (
  gl, vs, fs, { tfVaryings, tfBuffMode, uboBlockBindings = [] } = {}
) => {
  const prg = gl.createProgram();
  gl.attachShader(prg, vs);
  gl.attachShader(prg, fs);
  if (tfVaryings) {
    gl.transformFeedbackVaryings(prg, tfVaryings, tfBuffMode);
  }
  gl.linkProgram(prg);
  for (const { blockName, bindingPointIndex } of uboBlockBindings) {
    gl.uniformBlockBinding(prg, gl.getUniformBlockIndex(prg, blockName),
      bindingPointIndex);
  }
  return prg
};

const createProgramDebug = (gl, ...args) => {
  const prg = createProgram(gl, ...args);
  if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
    console.warn(`
      Failed to link a program: ${gl.getProgramInfoLog(prg)}
    `);
  }
  return prg
};

const createBuffer = (gl, target, dataOrSize, usage) => {
  const buf = gl.createBuffer();
  gl.bindBuffer(target, buf);
  gl.bufferData(target, dataOrSize, usage);
  gl.bindBuffer(target, null);
  return buf
};

const updateBuffer = (
  gl, target, buf, offset, data, srcOffset = 0, length = 0
) => {
  gl.bindBuffer(target, buf);
  gl.bufferSubData(target, offset, data, srcOffset, length);
  gl.bindBuffer(target, null);
};

const createUniformBuffer = (gl, size, usage, index) => {
  const target = gl.UNIFORM_BUFFER;
  const buf = createBuffer(gl, target, size, usage);
  gl.bindBufferBase(target, index, buf);
  return buf
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const TOL_CUT = 0.00001; // 32 / 2 ** 23

const DATA_TEXTURE_WIDTH_BIT_LENGTH = 11;
const DATA_TEXTURE_WIDTH = 2 ** DATA_TEXTURE_WIDTH_BIT_LENGTH;

const SSGID_BIT_LENGTH = 8;
const MAX_SSG_COUNT = 2 ** SSGID_BIT_LENGTH;
const SSGID_BIT = MAX_SSG_COUNT - 1;

const ODID_BIT_LENGTH = 24;
const MAX_OD_COUNT = 2 ** ODID_BIT_LENGTH;
const ODID_BIT = MAX_OD_COUNT - 1 << SSGID_BIT_LENGTH;
const INVALID_ODID = MAX_OD_COUNT - 1;

const TYPEID_NONE = 0;
const TYPEID_OD = 1;
const TYPEID_ATOM = 2;
const TYPE_TEXT = ['None', 'Occupation domain', 'Atom', 'Bond'];
const MAX_SSG_TEXTURE_WIDTH = 3 * MAX_SSG_COUNT; // <= 2048 is assumed

const CUT_TEXTURE_WIDTH_BIT_LENGTH = 8;
const CUT_TEXTURE_WIDTH = 2 ** CUT_TEXTURE_WIDTH_BIT_LENGTH;
const MAX_RFRACTLATT_COUNT = CUT_TEXTURE_WIDTH ** 2;

const SSG_TEXTURE_UNIT = 0;
const OD_COLOUR_RADIUS_TEXTURE_UNIT = 1;
const CUT_TEXTURE_UNIT = 2;

const ENVIRONMENT_UNIFORM_BINDING_POINT_INDEX = 0;
const CARTN_TRANSFORM_UNIFORM_BINDING_POINT_INDEX = 1;
const HIGHLIGHT_UNIFORM_BINDING_POINT_INDEX = 2;

const ENVIRONMENT_UNIFORM_BLOCK_NAME = 'Environment';
const ENVIRONMENT_UNIFORM_BLOCK_LAYOUT =
`layout(std140) uniform ${ENVIRONMENT_UNIFORM_BLOCK_NAME} {
  vec3 directionalLightDir;
  vec3 ambientLightColour;
};`;
const ENVIRONMENT_UNIFORM_BUFFER_SIZE = 32;
const ENVIRONMENT_UNIFORM_BLOCK_BINDING = {
  blockName: ENVIRONMENT_UNIFORM_BLOCK_NAME,
  bindingPointIndex: ENVIRONMENT_UNIFORM_BINDING_POINT_INDEX
};

const CARTN_TRANSFORM_UNIFORM_BLOCK_NAME = 'CartnTransform';
const CARTN_TRANSFORM_UNIFORM_BLOCK_LAYOUT =
`layout(std140) uniform ${CARTN_TRANSFORM_UNIFORM_BLOCK_NAME} {
  mat3 aParCartn123;
  mat3 aParCartn456;
  mat3 aPerpCartn123;
  mat3 aPerpCartn456;
  vec3 originFract123;
  vec3 originFract456;
};`;
const CARTN_TRANSFORM_UNIFORM_BUFFER_SIZE = 224;
const CARTN_TRANSFORM_UNIFORM_BLOCK_BINDING = {
  blockName: CARTN_TRANSFORM_UNIFORM_BLOCK_NAME,
  bindingPointIndex: CARTN_TRANSFORM_UNIFORM_BINDING_POINT_INDEX
};

const HIGHLIGHT_UNIFORM_BLOCK_NAME = 'Highlight';
const HIGHLIGHT_UNIFORM_BLOCK_LAYOUT =
`layout(std140) uniform ${HIGHLIGHT_UNIFORM_BLOCK_NAME} {
  float rCutParCartn;
  float baseRadius;
  float odBaseOpacity;
  vec4 unhighlightColourFactor;
  vec4 unhighlightRadiusFactor;
  uvec4 highlightRef;
  uvec4 highlightMask;
};`;
const HIGHLIGHT_UNIFORM_BUFFER_SIZE = 80;
const HIGHLIGHT_UNIFORM_BLOCK_BINDING = {
  blockName: HIGHLIGHT_UNIFORM_BLOCK_NAME,
  bindingPointIndex: HIGHLIGHT_UNIFORM_BINDING_POINT_INDEX
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const FILL_VIEWPORT_FAR_VS = `#version 300 es
const vec4 xxyy = vec4(-1.0, 1.0, -1.0, 1.0);
const int ixy[12] = int[](0, 3, 0, 2, 1, 3, 1, 2, 1, 3, 0, 2);
void main() {
  int i = gl_VertexID * 2;
  int j = i + 1;
  gl_Position = vec4(xxyy[ixy[i]], xxyy[ixy[j]], 1.0, 1.0);
}`;

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const DRAW_ATOMS_VS = `#version 300 es
layout(location = 0) in vec3 sphPosition;
layout(location = 1) in vec3 position;
layout(location = 2) in vec4 colour;
layout(location = 3) in vec4 radius;
uniform mat4 vmat, pmat;
out vec3 vNormal;
out vec4 vColour;
void main() {
  vec4 vpos = vec4(position, 1.0) * vmat;
  vec3 dir = normalize(-vpos.xyz);
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, vpos.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, vpos.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, vpos.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  gl_Position = vec4(radius.r * sphPosition, 1.0) * mmat * pmat;
  gl_Position.z *= gl_Position.w;
  vNormal = (vec4(sphPosition, 0.0) * mmat).xyz;
  vColour = colour;
}`;

const DRAW_ATOMS_INFO_VS = `#version 300 es
layout(location = 0) in vec3 sphPosition;
layout(location = 1) in vec3 position;
layout(location = 2) in vec4 radius;
layout(location = 3) in uvec4 info;
uniform mat4 vmat, pmat;
flat out uvec4 vColour;
void main() {
  vec4 vpos = vec4(position, 1.0) * vmat;
  vec3 dir = normalize(-vpos.xyz);
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, vpos.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, vpos.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, vpos.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  gl_Position = vec4(radius.r * sphPosition, 1.0) * mmat * pmat;
  gl_Position.z *= gl_Position.w;
  vColour = info;
}`;

const DRAW_HALF_BONDS_VS = `#version 300 es
layout(location = 0) in vec3 cylPosition;
layout(location = 1) in vec3 cylNormal;
layout(location = 2) in vec3 position;
layout(location = 3) in vec4 colour;
layout(location = 4) in vec4 radius;
layout(location = 5) in vec4 displacementOccupancy1;
layout(location = 6) in vec4 targetRadius1;
uniform mat4 vmat, pmat;
out vec3 vNormal;
out vec4 vColour;
void main() {
  vec3 dir = displacementOccupancy1.xyz;
  float len = length(dir);
  dir /= len;
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, position.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, position.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, position.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  float cylZ = cylPosition.z * 0.5;
  float edgeRadius = (radius.r * (1.0 - cylZ) + targetRadius1.r * cylZ) * 0.3;
  gl_Position = ((vec4(cylPosition.xy * edgeRadius, cylZ * len, 1.0) * mmat) *
    vmat) * pmat;
  gl_Position.z *= gl_Position.w;
  vNormal = ((vec4(cylNormal.xy / edgeRadius, cylNormal.z * 2.0 / len, 0.0) *
    mmat) * vmat).xyz;
  vColour = colour;
  if (colour.a == 0.0 || displacementOccupancy1.a == 0.0) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
}`;

const DRAW_HALF_BONDS_INFO_VS = `#version 300 es
layout(location = 0) in vec3 cylPosition;
layout(location = 1) in vec3 position;
layout(location = 2) in vec4 radius;
layout(location = 3) in uvec4 info;
layout(location = 4) in vec4 displacementOccupancy1;
layout(location = 5) in vec4 targetRadius1;
uniform mat4 vmat, pmat;
flat out uvec4 vColour;
void main() {
  vec3 dir = displacementOccupancy1.xyz;
  float len = length(dir);
  dir /= len;
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, position.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, position.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, position.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  float cylZ = cylPosition.z * 0.5;
  float edgeRadius = (radius.r * (1.0 - cylZ) + targetRadius1.r * cylZ) * 0.3;
  gl_Position = ((vec4(cylPosition.xy * edgeRadius, cylZ * len, 1.0) * mmat) *
    vmat) * pmat;
  gl_Position.z *= gl_Position.w;
  vColour = info;
  if (radius.r == 0.0 || displacementOccupancy1.a == 0.0) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
}`;

const DRAW_CLUSTER_VERTICES_VS = `#version 300 es
layout(location = 0) in vec3 sphPosition;
layout(location = 1) in vec3 position;
layout(location = 2) in uvec4 info;
layout(location = 3) in vec4 displacementOccupancy1;
layout(location = 4) in vec4 targetColour1;
layout(location = 5) in vec4 targetRadius1;
uniform mat4 vmat, pmat;
out vec3 vNormal;
out vec4 vColour;
void main() {
  vec4 vpos = vec4(position + displacementOccupancy1.xyz, 1.0) * vmat;
  vec3 dir = normalize(-vpos.xyz);
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, vpos.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, vpos.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, vpos.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  gl_Position = vec4(targetRadius1.r * sphPosition, 1.0) * mmat * pmat;
  gl_Position.z *= gl_Position.w;
  vNormal = (vec4(sphPosition, 0.0) * mmat).xyz;
  vColour = targetColour1;
  if (info[0] == ${TYPEID_NONE}u || displacementOccupancy1.a == 0.0) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
}`;

const DRAW_CLUSTER_VERTICES_INFO_VS = `#version 300 es
layout(location = 0) in vec3 sphPosition;
layout(location = 1) in vec3 position;
layout(location = 2) in uvec4 info;
layout(location = 3) in vec4 displacementOccupancy1;
layout(location = 4) in vec4 targetRadius1;
uniform mat4 vmat, pmat;
flat out uvec4 vColour;
void main() {
  vec4 vpos = vec4(position + displacementOccupancy1.xyz, 1.0) * vmat;
  vec3 dir = normalize(-vpos.xyz);
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, vpos.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, vpos.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, vpos.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  gl_Position = vec4(targetRadius1.r * sphPosition, 1.0) * mmat * pmat;
  gl_Position.z *= gl_Position.w;
  vColour = info;
  if (info[0] == ${TYPEID_NONE}u || displacementOccupancy1.a == 0.0) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
  vColour = info;
}`;

const DRAW_CLUSTER_EDGES_VS = `#version 300 es
layout(location = 0) in vec3 cylPosition;
layout(location = 1) in vec3 cylNormal;
layout(location = 2) in vec3 position;
layout(location = 3) in vec4 colour;
layout(location = 4) in vec4 radius;
layout(location = 5) in vec4 displacementOccupancy1;
layout(location = 6) in vec4 displacementOccupancy2;
uniform mat4 vmat, pmat;
out vec3 vNormal;
out vec4 vColour;
void main() {
  vec3 dir = displacementOccupancy1.xyz - displacementOccupancy2.xyz;
  float len = length(dir);
  dir /= len;
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  vec3 origin = position + displacementOccupancy2.xyz;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, origin.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, origin.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, origin.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  float edgeRadius = radius.r * 0.3;
  gl_Position = ((vec4(cylPosition.xy * edgeRadius, cylPosition.z * len, 1.0) *
    mmat) * vmat) * pmat;
  gl_Position.z *= gl_Position.w;
  vNormal = ((vec4(cylNormal.xy / edgeRadius, cylNormal.z / len, 0.0) * mmat) *
    vmat).xyz;
  vColour = colour;
  if (
    colour.a == 0.0 ||
    displacementOccupancy1.a == 0.0 ||
    displacementOccupancy2.a == 0.0
  ) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
}`;

const DRAW_CLUSTER_EDGES_INFO_VS = `#version 300 es
layout(location = 0) in vec3 cylPosition;
layout(location = 1) in vec3 position;
layout(location = 2) in vec4 radius;
layout(location = 3) in uvec4 info;
layout(location = 4) in vec4 displacementOccupancy1;
layout(location = 5) in vec4 displacementOccupancy2;
uniform mat4 vmat, pmat;
flat out uvec4 vColour;
void main() {
  vec3 dir = displacementOccupancy1.xyz - displacementOccupancy2.xyz;
  float len = length(dir);
  dir /= len;
  float snth = length(dir.xy);
  float csph = snth == 0.0 ? 1.0 : dir.x / snth;
  float snph = snth == 0.0 ? 0.0 : dir.y / snth;
  vec3 origin = position + displacementOccupancy2.xyz;
  mat4 mmat;
  mmat[0] = vec4(csph * dir.z, -snph, dir.x, origin.x);
  mmat[1] = vec4(snph * dir.z, csph, dir.y, origin.y);
  mmat[2] = vec4(-snth, 0.0, dir.z, origin.z);
  mmat[3] = vec4(0.0, 0.0, 0.0, 1.0);
  float edgeRadius = radius.r * 0.3;
  gl_Position = ((vec4(cylPosition.xy * edgeRadius, cylPosition.z * len, 1.0) *
    mmat) * vmat) * pmat;
  gl_Position.z *= gl_Position.w;
  vColour = info;
  if (
    radius.r == 0.0 ||
    displacementOccupancy1.a == 0.0 ||
    displacementOccupancy2.a == 0.0
  ) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
}`;

const DRAW_CLUSTER_FACES_VS = `#version 300 es
layout(location = 0) in int vId;
layout(location = 1) in vec3 position;
layout(location = 2) in vec4 colour;
layout(location = 3) in vec4 displacementOccupancy1;
layout(location = 4) in vec4 displacementOccupancy2;
layout(location = 5) in vec4 displacementOccupancy3;
uniform mat4 vmat, pmat;
out vec3 vPosition;
out vec4 vColour;
void main() {
  vec3 v[3] = vec3[3](
    position + displacementOccupancy1.xyz,
    position + displacementOccupancy2.xyz,
    position + displacementOccupancy3.xyz
  );
  gl_Position = vec4(v[vId], 1.0) * vmat;
  vPosition = gl_Position.xyz;
  gl_Position *= pmat;
  gl_Position.z *= gl_Position.w;
  vColour = colour;
  vColour.a *= 0.8;
  if (
    colour.a == 0.0 ||
    displacementOccupancy1.a == 0.0 ||
    displacementOccupancy2.a == 0.0 ||
    displacementOccupancy3.a == 0.0
  ) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
}`;

const DRAW_CLUSTER_FACES_INFO_VS = `#version 300 es
layout(location = 0) in int vId;
layout(location = 1) in vec3 position;
layout(location = 2) in uvec4 info;
layout(location = 3) in vec4 displacementOccupancy1;
layout(location = 4) in vec4 displacementOccupancy2;
layout(location = 5) in vec4 displacementOccupancy3;
uniform mat4 vmat, pmat;
flat out uvec4 vColour;
void main() {
  vec3 v[3] = vec3[3](
    position + displacementOccupancy1.xyz,
    position + displacementOccupancy2.xyz,
    position + displacementOccupancy3.xyz
  );
  gl_Position = vec4(v[vId], 1.0) * vmat * pmat;
  gl_Position.z *= gl_Position.w;
  vColour = info;
  if (
    info[0] == ${TYPEID_NONE}u ||
    displacementOccupancy1.a == 0.0 ||
    displacementOccupancy2.a == 0.0 ||
    displacementOccupancy3.a == 0.0
  ) {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
}`;

// export const DRAW_LINES_VS = `#version 300 es
// layout(location = 0) in vec3 position;
// layout(location = 1) in vec4 colour;
// uniform mat4 vpmat;
// uniform vec3 originOffset;
// out vec4 vColour;
// void main() {
//   gl_Position = vec4(position + originOffset, 1.0) * vpmat;
//   vColour = colour;
// }`

const DRAW_ODFRAGS_VS = `#version 300 es
layout(location = 0) in vec3 position;
layout(location = 1) in vec4 colour;
layout(location = 2) in vec3 displacement;
uniform mat4 vmat, pmat;
out vec3 vPosition;
out vec4 vColour;
void main() {
  gl_PointSize = 5.0;
  gl_Position = vec4(position + displacement, 1.0) * vmat;
  vPosition = gl_Position.xyz;
  gl_Position *= pmat;
  gl_Position.z *= gl_Position.w;
  vColour = colour;
}`;

const DRAW_ODFRAGS_INFO_VS = `#version 300 es
layout(location = 0) in vec3 position;
layout(location = 1) in uvec4 info;
layout(location = 2) in vec3 displacement;
uniform mat4 vmat, pmat;
flat out uvec4 vColour;
void main() {
  gl_PointSize = 5.0;
  gl_Position = vec4(position + displacement, 1.0) * vmat * pmat;
  gl_Position.z *= gl_Position.w;
  vColour = info;
}`;

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const PROJ_VS = `#version 300 es
layout(location = 0) in lowp ivec3 rFractLatt123;
layout(location = 1) in lowp ivec3 rFractLatt456;
layout(location = 2) in vec3 rFractSite123;
layout(location = 3) in vec3 rFractSite456;
${CARTN_TRANSFORM_UNIFORM_BLOCK_LAYOUT}
flat out uvec2 vRFractLattId;
out vec3 vRParCartn;
out vec3 vRPerpCartn;
void main() {
  vec3 rFract123 = vec3(rFractLatt123) + rFractSite123 - originFract123;
  vec3 rFract456 = vec3(rFractLatt456) + rFractSite456 - originFract456;
  vRParCartn = rFract123 * aParCartn123 + rFract456 * aParCartn456;
  vRPerpCartn = -(rFract123 * aPerpCartn123 + rFract456 * aPerpCartn456);
  uvec3 rFractLatt123u = uvec3(ivec3(rFractLatt123) + 128);
  uvec3 rFractLatt456u = uvec3(ivec3(rFractLatt456) + 128);
  vRFractLattId = uvec2(
    rFractLatt123u[0] << 24u | rFractLatt123u[1] << 16u |
    rFractLatt123u[2] << 8u | rFractLatt456u[0],
    rFractLatt456u[1] << 24u | rFractLatt456u[2] << 16u);
}`;

const CUT_3D_VS = `#version 300 es
layout(location = 0) in vec3 rPerpCartn;
layout(location = 1) in vec3 displacementPerpCartn;
layout(location = 2) in uint odIdSSGId;
layout(location = 3) in vec3 bOD0;
layout(location = 4) in vec3 bOD1;
layout(location = 5) in vec3 bOD2;
layout(location = 6) in vec3 rOD0;
flat out uvec4 vColour;
void main() {
  mat3 bOD = mat3(bOD0, bOD1, bOD2);
  vec3 v = bOD * (rPerpCartn + displacementPerpCartn - rOD0);
  if (
    v.x + v.y + v.z <= 1.0 + ${TOL_CUT} &&
    all(greaterThanEqual(v, vec3(-${TOL_CUT})))
  ) {
    gl_Position = vec4(
      (vec2(gl_VertexID % ${CUT_TEXTURE_WIDTH},
        gl_VertexID >> ${CUT_TEXTURE_WIDTH_BIT_LENGTH}) * 2.0 + 1.0)
        / float(${CUT_TEXTURE_WIDTH}) - 1.0,
      0.0, 1.0);
  } else {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
  gl_PointSize = 1.0;
  vColour = uvec4(odIdSSGId, 0u, 0u, 0u);
}`;

const CUT_2D_VS = `#version 300 es
layout(location = 0) in vec3 rPerpCartn;
layout(location = 1) in vec3 displacementPerpCartn;
layout(location = 2) in uint odIdSSGId;
layout(location = 3) in vec2 bOD0;
layout(location = 4) in vec2 bOD1;
layout(location = 5) in vec2 rOD0;
flat out uvec4 vColour;
void main() {
  mat2 bOD = mat2(bOD0, bOD1);
  vec2 v = bOD * (rPerpCartn.xy + displacementPerpCartn.xy - rOD0);
  if (
    v.x + v.y <= 1.0 + ${TOL_CUT} &&
    all(greaterThanEqual(v, vec2(-${TOL_CUT})))
  ) {
    gl_Position = vec4(
      (vec2(gl_VertexID % ${CUT_TEXTURE_WIDTH},
        gl_VertexID >> ${CUT_TEXTURE_WIDTH_BIT_LENGTH}) * 2.0 + 1.0)
        / float(${CUT_TEXTURE_WIDTH}) - 1.0,
      0.0, 1.0);
  } else {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
  gl_PointSize = 1.0;
  vColour = uvec4(odIdSSGId, 0u, 0u, 0u);
}`;

const CUT_1D_VS = `#version 300 es
layout(location = 0) in vec3 rPerpCartn;
layout(location = 1) in vec3 displacementPerpCartn;
layout(location = 2) in uint odIdSSGId;
layout(location = 3) in float bOD0;
layout(location = 4) in float rOD0;
flat out uvec4 vColour;
void main() {
  float v = bOD0 * (rPerpCartn.x + displacementPerpCartn.x - rOD0);
  if (v <= 1.0 + ${TOL_CUT} && v >= float(-${TOL_CUT})) {
    gl_Position = vec4(
      (vec2(gl_VertexID % ${CUT_TEXTURE_WIDTH},
        gl_VertexID >> ${CUT_TEXTURE_WIDTH_BIT_LENGTH}) * 2.0 + 1.0)
        / float(${CUT_TEXTURE_WIDTH}) - 1.0,
      0.0, 1.0);
  } else {
    gl_Position = vec4(vec3(1.0), 0.0);
  }
  gl_PointSize = 1.0;
  vColour = uvec4(odIdSSGId, 0u, 0u, 0u);
}`;

const CUT_0D_VS = `#version 300 es
layout(location = 0) in vec3 rPerpCartn;
layout(location = 1) in vec3 displacementPerpCartn;
layout(location = 2) in uint odIdSSGId;
flat out uvec4 vColour;
void main() {
  gl_Position = vec4(
    (vec2(gl_VertexID % ${CUT_TEXTURE_WIDTH},
      gl_VertexID >> ${CUT_TEXTURE_WIDTH_BIT_LENGTH}) * 2.0 + 1.0)
      / float(${CUT_TEXTURE_WIDTH}) - 1.0,
    0.0, 1.0);
  gl_PointSize = 1.0;
  vColour = uvec4(odIdSSGId, 0u, 0u, 0u);
}`;

const CUT_VS = [CUT_0D_VS, CUT_1D_VS, CUT_2D_VS, CUT_3D_VS];

const COLOUR_ATOMS_VS = `#version 300 es
layout(location = 0) in uvec2 rFractLattId;
layout(location = 1) in vec3 rParCartn;
uniform highp usampler2DArray cut;
uniform sampler2D odColourRadius;
${HIGHLIGHT_UNIFORM_BLOCK_LAYOUT}
out vec4 vColour;
out vec4 vRadius;
flat out uvec4 vInfo;
void main() {
  uint odIdSSGId = texelFetch(cut, ivec3(
    gl_VertexID % ${CUT_TEXTURE_WIDTH},
    gl_VertexID >> ${CUT_TEXTURE_WIDTH_BIT_LENGTH}, 0), 0).r;
  uint odId = odIdSSGId >> ${SSGID_BIT_LENGTH}u;
  vInfo = uvec4(${TYPEID_ATOM}u, odIdSSGId, rFractLattId);
  if (odId != ${INVALID_ODID}u && length(rParCartn) < rCutParCartn) {
    uint id = odId * 2u;
    vColour = texelFetch(odColourRadius, ivec2(
      id % ${DATA_TEXTURE_WIDTH}u,
      id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
    id += 1u;
    vRadius = texelFetch(odColourRadius, ivec2(
      id % ${DATA_TEXTURE_WIDTH}u,
      id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
    vRadius.r *= baseRadius;
  } else {
    vColour = vec4(0.0, 0.0, 0.0, 0.0);
    vRadius = vec4(0.0, 0.0, 0.0, 0.0);
    vInfo[0] = ${TYPEID_NONE}u;
  }
  if ((vInfo & highlightMask) != (highlightRef & highlightMask)) {
    vColour *= unhighlightColourFactor;
    vRadius *= unhighlightRadiusFactor;
  }
}`;

const MASK_DISPLACEMENTS_VS = `#version 300 es
layout(location = 0) in uint displacementId;
layout(location = 1) in vec3 displacement;
layout(location = 2) in uvec4 info;
uniform highp usampler2DArray cut;
uniform sampler2D odColourRadius;
${HIGHLIGHT_UNIFORM_BLOCK_LAYOUT}
out vec4 vDisplacementOccupancy;
out vec4 vTargetColour;
out vec4 vTargetRadius;
void main() {
  uint odIdSSGId = texelFetch(cut, ivec3(
    gl_InstanceID % ${CUT_TEXTURE_WIDTH},
    gl_InstanceID >> ${CUT_TEXTURE_WIDTH_BIT_LENGTH}, displacementId), 0).r;
  uint odId = odIdSSGId >> ${SSGID_BIT_LENGTH}u;
  vDisplacementOccupancy = vec4(displacement, 0.0);
  if (odId != ${INVALID_ODID}u) {
    vDisplacementOccupancy.a = 1.0;
    uint id = odId * 2u;
    vTargetColour = texelFetch(odColourRadius, ivec2(
      id % ${DATA_TEXTURE_WIDTH}u,
      id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
    id += 1u;
    vTargetRadius = texelFetch(odColourRadius, ivec2(
      id % ${DATA_TEXTURE_WIDTH}u,
      id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
    vTargetRadius.r *= baseRadius;
  }
  if ((info & highlightMask) != (highlightRef & highlightMask)) {
    vTargetColour *= unhighlightColourFactor;
    vTargetRadius *= unhighlightRadiusFactor;
  }
}`;

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const PREP_ODFRAGS_3D_VS = `#version 300 es
layout(location = 0) in uint odId;
layout(location = 1) in vec3 rOD0;
layout(location = 2) in vec3 rOD1;
layout(location = 3) in vec3 rOD2;
layout(location = 4) in vec3 rOD3;
layout(location = 5) in uint ssgId;
uniform highp sampler2D ssg;
flat out uint vODIdSSGId;
out vec3 vBOD0;
out vec3 vBOD1;
out vec3 vBOD2;
out vec3 vROD0;
out vec3 vROD1;
out vec3 vROD2;
out vec3 vROD3;
void main() {
  uint id = ssgId * 3u;
  mat3 gPerp;
  gPerp[0] = texelFetch(ssg, ivec2(id, 1), 0).xyz;
  gPerp[1] = texelFetch(ssg, ivec2(id + 1u, 1), 0).xyz;
  gPerp[2] = texelFetch(ssg, ivec2(id + 2u, 1), 0).xyz;
  vec3 v[4] = vec3[4](rOD0 * gPerp, rOD1 * gPerp, rOD2 * gPerp, rOD3 * gPerp);
  bool flag = dot(cross(v[1] - v[0], v[2] - v[0]), v[3] - v[0]) > 0.0;
  vROD0 = flag ? v[0] : v[1];
  vROD1 = flag ? v[1] : v[0];
  vROD2 = v[2];
  vROD3 = v[3];
  mat3 bOD = inverse(mat3(vROD1 - vROD0, vROD2 - vROD0, vROD3 - vROD0));
  vBOD0 = bOD[0];
  vBOD1 = bOD[1];
  vBOD2 = bOD[2];
  vODIdSSGId = odId << ${SSGID_BIT_LENGTH}u | ssgId;
}`;

const PREP_ODFRAGS_3D_TF_VARYINGS = [
  'vODIdSSGId',
  'vBOD0',
  'vBOD1',
  'vBOD2',
  'vROD0',
  'vROD1',
  'vROD2',
  'vROD3'
];

const PREP_ODFRAGS_2D_VS = `#version 300 es
layout(location = 0) in uint odId;
layout(location = 1) in vec2 rOD0;
layout(location = 2) in vec2 rOD1;
layout(location = 3) in vec2 rOD2;
layout(location = 4) in uint ssgId;
uniform highp sampler2D ssg;
flat out uint vODIdSSGId;
out vec2 vBOD0;
out vec2 vBOD1;
out vec2 vROD0;
out vec2 vROD1;
out vec2 vROD2;
void main() {
  uint id = ssgId * 3u;
  mat2 gPerp;
  gPerp[0] = texelFetch(ssg, ivec2(id, 1), 0).xy;
  gPerp[1] = texelFetch(ssg, ivec2(id + 1u, 1), 0).xy;
  vROD0 = rOD0 * gPerp;
  vROD1 = rOD1 * gPerp;
  vROD2 = rOD2 * gPerp;
  mat2 bOD = inverse(mat2(vROD1 - vROD0, vROD2 - vROD0));
  vBOD0 = bOD[0];
  vBOD1 = bOD[1];
  vODIdSSGId = odId << ${SSGID_BIT_LENGTH}u | ssgId;
}`;

const PREP_ODFRAGS_2D_TF_VARYINGS = [
  'vODIdSSGId',
  'vBOD0',
  'vBOD1',
  'vROD0',
  'vROD1',
  'vROD2'
];

const PREP_ODFRAGS_1D_VS = `#version 300 es
layout(location = 0) in uint odId;
layout(location = 1) in float rOD0;
layout(location = 2) in float rOD1;
layout(location = 3) in uint ssgId;
uniform highp sampler2D ssg;
flat out uint vODIdSSGId;
out float vBOD0;
out float vROD0;
out float vROD1;
void main() {
  uint id = ssgId * 3u;
  float gPerp = texelFetch(ssg, ivec2(id, 1), 0).x;
  vROD0 = rOD0 * gPerp;
  vROD1 = rOD1 * gPerp;
  vBOD0 = 1.0 / (vROD1 - vROD0);
  vODIdSSGId = odId << ${SSGID_BIT_LENGTH}u | ssgId;
}`;

const PREP_ODFRAGS_1D_TF_VARYINGS = [
  'vODIdSSGId',
  'vBOD0',
  'vROD0',
  'vROD1'
];

const PREP_ODFRAGS_0D_VS = `#version 300 es
layout(location = 0) in uint odId;
layout(location = 1) in uint ssgId;
flat out uint vODIdSSGId;
void main() {
  vODIdSSGId = odId << ${SSGID_BIT_LENGTH}u | ssgId;
}`;

const PREP_ODFRAGS_0D_TF_VARYINGS = [
  'vODIdSSGId'
];

const PREP_ODFRAGS_VS = [
  PREP_ODFRAGS_0D_VS,
  PREP_ODFRAGS_1D_VS,
  PREP_ODFRAGS_2D_VS,
  PREP_ODFRAGS_3D_VS
];

const PREP_ODFRAGS_TF_VARYINGS = [
  PREP_ODFRAGS_0D_TF_VARYINGS,
  PREP_ODFRAGS_1D_TF_VARYINGS,
  PREP_ODFRAGS_2D_TF_VARYINGS,
  PREP_ODFRAGS_3D_TF_VARYINGS
];

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const GEN_OD_INSTANCES_3D_VS = `#version 300 es
layout(location = 0) in int vId;
layout(location = 1) in uint odIdSSGId;
layout(location = 2) in vec3 rOD0;
layout(location = 3) in vec3 rOD1;
layout(location = 4) in vec3 rOD2;
layout(location = 5) in vec3 rOD3;
uniform sampler2D odColourRadius;
${HIGHLIGHT_UNIFORM_BLOCK_LAYOUT}
out vec3 vPosition;
out vec4 vColour;
flat out uvec4 vInfo;
void main() {
  vec3 v[4] = vec3[4](rOD0, rOD1, rOD2, rOD3);
  vPosition = v[vId];
  uint odId = odIdSSGId >> ${SSGID_BIT_LENGTH}u;
  uint id = odId * 2u;
  vColour = texelFetch(odColourRadius, ivec2(
    id % ${DATA_TEXTURE_WIDTH}u,
    id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
  vInfo = uvec4(${TYPEID_OD}u, odIdSSGId, 0u, 0u);
  vColour.a *= odBaseOpacity;
  if ((vInfo & highlightMask) != (highlightRef & highlightMask)) {
    vColour *= unhighlightColourFactor;
  }
}`;

const GEN_OD_INSTANCES_2D_VS = `#version 300 es
layout(location = 0) in int vId;
layout(location = 1) in uint odIdSSGId;
layout(location = 2) in vec2 rOD0;
layout(location = 3) in vec2 rOD1;
layout(location = 4) in vec2 rOD2;
uniform sampler2D odColourRadius;
${HIGHLIGHT_UNIFORM_BLOCK_LAYOUT}
out vec3 vPosition;
out vec4 vColour;
flat out uvec4 vInfo;
void main() {
  vec2 v[3] = vec2[3](rOD0, rOD1, rOD2);
  vPosition = vec3(v[vId], 0.0);
  uint odId = odIdSSGId >> ${SSGID_BIT_LENGTH}u;
  uint id = odId * 2u;
  vColour = texelFetch(odColourRadius, ivec2(
    id % ${DATA_TEXTURE_WIDTH}u,
    id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
  vInfo = uvec4(${TYPEID_OD}u, odIdSSGId, 0u, 0u);
  vColour.a *= odBaseOpacity;
  if ((vInfo & highlightMask) != (highlightRef & highlightMask)) {
    vColour *= unhighlightColourFactor;
  }
}`;

const GEN_OD_INSTANCES_1D_VS = `#version 300 es
layout(location = 0) in int vId;
layout(location = 1) in uint odIdSSGId;
layout(location = 2) in float rOD0;
layout(location = 3) in float rOD1;
uniform sampler2D odColourRadius;
${HIGHLIGHT_UNIFORM_BLOCK_LAYOUT}
out vec3 vPosition;
out vec4 vColour;
flat out uvec4 vInfo;
void main() {
  float v[2] = float[2](rOD0, rOD1);
  vPosition = vec3(v[vId], 0.0, 0.0);
  uint odId = odIdSSGId >> ${SSGID_BIT_LENGTH}u;
  uint id = odId * 2u;
  vColour = texelFetch(odColourRadius, ivec2(
    id % ${DATA_TEXTURE_WIDTH}u,
    id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
  vInfo = uvec4(${TYPEID_OD}u, odIdSSGId, 0u, 0u);
  vColour.a *= odBaseOpacity;
  if ((vInfo & highlightMask) != (highlightRef & highlightMask)) {
    vColour *= unhighlightColourFactor;
  }
}`;

const GEN_OD_INSTANCES_0D_VS = `#version 300 es
layout(location = 0) in int vId;
layout(location = 1) in uint odIdSSGId;
uniform sampler2D odColourRadius;
${HIGHLIGHT_UNIFORM_BLOCK_LAYOUT}
out vec3 vPosition;
out vec4 vColour;
flat out uvec4 vInfo;
void main() {
  vPosition = vec3(0.0);
  uint odId = odIdSSGId >> ${SSGID_BIT_LENGTH}u;
  uint id = odId * 2u;
  vColour = texelFetch(odColourRadius, ivec2(
    id % ${DATA_TEXTURE_WIDTH}u,
    id >> ${DATA_TEXTURE_WIDTH_BIT_LENGTH}), 0);
  vInfo = uvec4(${TYPEID_OD}u, odIdSSGId, 0u, 0u);
  vColour.a *= odBaseOpacity;
  if ((vInfo & highlightMask) != (highlightRef & highlightMask)) {
    vColour *= unhighlightColourFactor;
  }
}`;

const GEN_OD_INSTANCES_VS = [
  GEN_OD_INSTANCES_0D_VS,
  GEN_OD_INSTANCES_1D_VS,
  GEN_OD_INSTANCES_2D_VS,
  GEN_OD_INSTANCES_3D_VS
];

const GEN_OD_INSTANCES_TF_VARYINGS = ['vPosition', 'vColour', 'vInfo'];

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const SIMPLE_FS = `#version 300 es
precision highp float;
in vec4 vColour;
layout(location = 0) out vec4 outColour;
void main() {
  outColour = vColour;
}`;

const SIMPLE_FS_DUMMY_POSITION = `#version 300 es
precision highp float;
in vec3 vPosition;
in vec4 vColour;
layout(location = 0) out vec4 outColour;
void main() {
  outColour = vColour;
}`;

const SIMPLE_UINT_FS = `#version 300 es
precision highp int;
flat in uvec4 vColour;
layout(location = 0) out uvec4 outColour;
void main() {
  outColour = vColour;
}`;

// ad hoc implementation
const NORMAL_FS = `#version 300 es
precision highp float;
in vec3 vNormal;
in vec4 vColour;
${ENVIRONMENT_UNIFORM_BLOCK_LAYOUT}
uniform float reflectivity;
layout(location = 0) out vec4 outColour;
void main() {
  vec3 normal = normalize(vNormal);
  vec3 normalLightDir = -normalize(directionalLightDir);
  float cos = dot(normal, normalLightDir);
  outColour = vec4(
    2.0 * vColour.xyz * ((1.0 - reflectivity) * max(cos, 0.0)
    + (1.0 - abs(cos)) * ambientLightColour)
    + reflectivity * vec3(pow(clamp(dot(normal,
    normalize(normalLightDir + vec3(0, 0, 1))), 0.0, 1.0), 5.0)), vColour.a *
    smoothstep(0.0, 1.0, 3.0 * gl_FragCoord.z));
}`;

// ad hoc implementation
const FLAT_FS = `#version 300 es
precision highp float;
in vec3 vPosition;
in vec4 vColour;
${ENVIRONMENT_UNIFORM_BLOCK_LAYOUT}
uniform float reflectivity;
layout(location = 0) out vec4 outColour;
void main() {
  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));
  vec3 normalLightDir = -normalize(directionalLightDir);
  float cos = dot(normal, normalLightDir);
  outColour = vec4(
    2.0 * vColour.xyz * ((1.0 - reflectivity) * max(cos, 0.0)
    + (1.0 - abs(cos)) * ambientLightColour)
    + reflectivity * vec3(pow(clamp(dot(normal,
    normalize(normalLightDir + vec3(0, 0, 1))), 0.0, 1.0), 5.0)), vColour.a *
    smoothstep(0.0, 1.0, 3.0 * gl_FragCoord.z));
}`;

const WHITE_FS = `#version 300 es
precision highp float;
layout(location = 0) out vec4 outColour;
void main() {
  outColour = vec4(1.0, 1.0, 1.0, 1.0);
}`;

const DUMMY_FS = `#version 300 es
void main() {
  discard;
}`;

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const rnum$2 = new RealAlgebra();
const lnum$2 = new LinearAlgebra(rnum$2);

function inormalise$1 (v0) {
  return lnum$2.isdiv(v0, lnum$2.abs(v0))
}

function rtp3 (v) {
  const sqrtx2y2 = Math.hypot(v[0], v[1]);
  return {
    r: Math.hypot(sqrtx2y2, v[2]),
    t: Math.atan2(sqrtx2y2, v[2]),
    p: Math.atan2(v[1], v[0]) }
}

function cross3$1 (v0, v1) {
  return lnum$2.$(
    v0[1] * v1[2] - v0[2] * v1[1],
    v0[2] * v1[0] - v0[0] * v1[2],
    v0[0] * v1[1] - v0[1] * v1[0])
}

// generate a matrix which rotate CCW around v
// th: rotation angle in radian
function rotateV3$1 (th, v) {
  const c = Math.cos(th);
  const s = Math.sin(th);
  const d = 1 - c;
  const dv = lnum$2.smul(v, d);
  const sv = lnum$2.smul(v, s);
  const a00 = v[0] * dv[0];
  const a01 = v[0] * dv[1];
  const a02 = v[0] * dv[2];
  const a11 = v[1] * dv[1];
  const a12 = v[1] * dv[2];
  const a22 = v[2] * dv[2];
  return lnum$2.$(
    c + a00, -sv[2] + a01, sv[1] + a02,
    sv[2] + a01, c + a11, -sv[0] + a12,
    -sv[1] + a02, sv[0] + a12, c + a22).setDim(3, 3)
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const rnum$3 = new RealAlgebra();
const lnum$3 = new LinearAlgebra(rnum$3);

class Camera {
  constructor () {
    this.refWidth = 512;
    this.position = [0, 0, 50];
    this.lookAt = [0, 0, 0];
    this.upDir = [0, 1, 0];
    this.fov = 0.3;
    this.distMin = 5;
    this.distMax = 100;
    // this.near = 0.01
    // this.far = 100
    this.orthographic = true;
    this.rotFactor = 0.02;
    this.moveFactor = 0.0005;
    this.zoomFactor = 0.005;
  }

  set position (position) {
    if (Array.isArray(position) && position.length === 3) {
      this._position = lnum$3.copy(position);
    }
  }

  get position () {
    return lnum$3.copy(this._position)
  }

  set lookAt (lookAt) {
    if (Array.isArray(lookAt) && lookAt.length === 3) {
      this._lookAt = lnum$3.copy(lookAt);
    }
  }

  get lookAt () {
    return lnum$3.copy(this._lookAt)
  }

  set upDir (upDir) {
    if (Array.isArray(upDir) && upDir.length === 3 && !lnum$3.isZero(upDir)) {
      this._upDir = inormalise$1(lnum$3.copy(upDir));
    }
  }

  get upDir () {
    return lnum$3.copy(this._upDir)
  }

  get distance () {
    return lnum$3.abs(lnum$3.sub(this.position, this.lookAt))
  }

  get near () {
    return this.distance * 0.01
  }

  get far () {
    return this.distance * 1.99
  }

  viewMat () {
    const mPos = lnum$3.neg(this.position);
    const rtp = rtp3(lnum$3.add(this.lookAt, mPos));
    const a = rotateV3$1(-rtp.p, [0, 0, 1]);
    const b = rotateV3$1(-rtp.t + Math.PI, [0, 1, 0]);
    const c = lnum$3.mmul(b, a);
    const u = lnum$3.mmul(c, this.upDir);
    const rot = lnum$3.mmul(rotateV3$1(Math.atan2(u[0], u[1]), [0, 0, 1]), c);
    const trans = lnum$3.mmul(rot, mPos);
    return lnum$3.$(
      ...rot.slice(0, 3), trans[0],
      ...rot.slice(3, 6), trans[1],
      ...rot.slice(6, 9), trans[2],
      0, 0, 0, 1).setDim(4, 4)
  }

  projectionMat (targetWidth, targetHeight) {
    if (this.orthographic) {
      return this.orthographicMat(targetWidth, targetHeight)
    } else {
      return this.pseudoPerspectiveMat(targetWidth, targetHeight)
    }
  }

  orthographicMat (targetWidth, targetHeight) {
    const aspectRatio = targetWidth / targetHeight;
    const width = 2 * Math.tan(this.fov / 2) * this.distance *
      targetWidth / this.refWidth;
    const height = width / aspectRatio;
    const far = this.far;
    const near = this.near;
    const farMinusNear = this.far - this.near;
    return lnum$3.$(
      2 / width, 0, 0, 0,
      0, 2 / height, 0, 0,
      0, 0, -2 / farMinusNear, -(far + near) / farMinusNear,
      0, 0, 0, 1).setDim(4, 4)
  }

  pseudoPerspectiveMat (targetWidth, targetHeight) {
    const aspectRatio = targetWidth / targetHeight;
    const far = this.far;
    const near = this.near;
    const farMinusNear = far - near;
    const a = Math.tan(this.fov / 2) * targetWidth / this.refWidth;
    return lnum$3.$(
      1 / a, 0, 0, 0,
      0, aspectRatio / a, 0, 0,
      0, 0, -2 / farMinusNear, -(far + near) / farMinusNear,
      0, 0, -1, 0).setDim(4, 4)
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const rnum$4 = new RealAlgebra();
const lnum$4 = new LinearAlgebra(rnum$4);
const eps = 1e-5;

// real roots of x^2 - 2bx + c = 0
const realRootsOfQuadEq = (b, c) => {
  const d = b * b - c;
  if (d <= 0) {
    const dummy = b;
    return [dummy, dummy]
  }
  const rtd = Math.sqrt(d);
  if (b > 0) {
    const x1 = b + rtd;
    return [c / x1, x1]
  } else {
    const x0 = b - rtd;
    return [x0, c / x0]
  }
};

const genCoefMatrices = (dim, dimD, g, vv, vf, ff) => {
  // v: variable, f: fixed, d: dependent
  const i = dim - (dimD + 1);
  const idim = i * dim;
  const gvvi = g[idim + i];
  const gvfi = lnum$4.$(...g.slice(idim, idim + i));
  const gffi = lnum$4.$(...g.filter((a, k) => {
    return Math.floor(k / dim) < i && k % dim < i
  })).setDim(i, i);
  const gddiLU = lnum$4.ilup(lnum$4.$(...g.filter((a, k) => {
    return Math.floor(k / dim) > i && k % dim > i
  })).setDim(dimD, dimD));
  const gdvi = lnum$4.$(...g.filter((a, k) => {
    return Math.floor(k / dim) > i && k % dim === i
  }));
  const gdfi = lnum$4.$(...g.filter((a, k) => {
    return Math.floor(k / dim) > i && k % dim < i
  })).setDim(dimD, i);

  // ad hoc fix
  gdvi.setDim(dimD, 1);
  const vddddvi = lnum$4.dot(gdvi, lnum$4.solve(gddiLU, gdvi));
  gdvi.setDim();

  const dddfi = lnum$4.solve(gddiLU, gdfi);
  const fddddfi = lnum$4.mmul(lnum$4.transpose(gdfi), dddfi);
  const vvi = gvvi - vddddvi;
  vv.push(vvi);
  const vddddfi = i === dim - 1
    ? new Array(i).fill(0)
    : lnum$4.mmul(gdvi, dddfi);
  vf.push(lnum$4.isdiv(lnum$4.sub(gvfi, vddddfi), -vvi));
  ff.push(lnum$4.isdiv(lnum$4.sub(gffi, fddddfi), vvi));
};

// ORIGINAL
/*
const genCoefMatrices2 = (dim, dimD, constVect, vv, vf, ff, vc, fc, cc, c0) => {
  const i = dim - (dimD + 1)
  const vfi = vf[dimD]
  const ffi = ff[dimD]
  let vci = -constVect[i]
  let cci = -vci * constVect[i]
  const tmp1 = lnum.$(...constVect.slice(0, i))
  const tmp2 = lnum.dot(vfi, tmp1)
  vci += tmp2
  let fci = lnum.smul(vfi, -2 * constVect[i])
  cci += -2 * constVect[i] * tmp2
  const tmp3 = lnum.mmul(ffi, tmp1)
  fci = lnum.iadd(fci, lnum.smul(tmp3, 2))
  cci += lnum.dot(tmp1, tmp3) - c0 * (1 + eps) / vv[dimD]
  vc.push(vci)
  fc.push(fci)
  cc.push(cci)
}
*/

const genCoefMatrices2 = (dim, dimD, constVect, vv, vf, ff, vc, fc, cc, c0) => {
  const i = dim - (dimD + 1);
  const vfi = vf[dimD];
  const ffi = ff[dimD];
  let vci = -constVect[i];
  let cci = -vci * constVect[i];

  // const tmp1 = lnum.$(...constVect.slice(0, i))
  let tmp2 = 0;
  for (let j = i - 1; j >= 0; j -= 1) {
    tmp2 += vfi[j] * constVect[j];
  }

  vci += tmp2;

  let fci = [];
  for (let j = 0; j < i; j += 1) {
    let sum = 0;
    for (let k = i - 1; k >= 0; k -= 1) {
      sum += ffi[j * i + k] * constVect[k];
    }
    fci.push(-2 * constVect[i] * vfi[j] + sum * 2);
    cci += sum * constVect[j];
  }
  cci += -2 * constVect[i] * tmp2 - c0 * (1 + eps) / vv[dimD];

  vc.push(vci);
  fc.push(fci);
  cc.push(cci);
};

// SLOW ...
/*
const findRangeForDepth = (dim, depth, current, vv, vf, ff, vc, fc, cc) => {
  const dimD = dim - (depth + 1)
  const tmp = lnum.$(...current.slice(0, depth))
  const b = vc[dimD] + lnum.dot(vf[dimD], tmp)
  const c = cc[dimD] +
    lnum.dot(tmp, lnum.iadd(lnum.mmul(ff[dimD], tmp), fc[dimD]))
  return realRootsOfQuadEq(b, c)
}
*/

const findRangeForDepth = (dim, depth, current, vv, vf, ff, vc, fc, cc) => {
  const dimD = dim - (depth + 1);
  const vfDimD = vf[dimD];
  const fcDimD = fc[dimD];
  const ffDimD = ff[dimD];
  let b = vc[dimD];
  let c = cc[dimD];
  let k = depth ** 2;
  const start = depth - 1;
  for (let i = start; i >= 0; i -= 1) {
    const currentI = current[i];
    b += vfDimD[i] * currentI;
    let sum = 0;
    for (let j = start; j >= 0; j -= 1) {
      k -= 1;
      sum += ffDimD[k] * current[j];
    }
    c += (sum + fcDimD[i]) * currentI;
  }
  return realRootsOfQuadEq(b, c)
};

// m and v are the linear transformation matrix and the translation
// vector, repsectively, by which a cutoff region represented by an ellipse
// is mapped into the sphere of radius 1.
// Convention of transformation is as follows:
// x' = m (x + v)
// Usage:
//   xFractGenerator(m)(v)
function xFractGenerator (m) {
  const dim = Math.sqrt(m.length);
  m = lnum$4.$(...m).setDim(dim, dim);
  // numerical only
  const g = lnum$4.mmul(lnum$4.transpose(m), m);
  // v: variable, f: fixed, c: constant, index === dimD
  const vv = [];
  const vf = [];
  const ff = [];
  for (let dimD = 0; dimD < dim; dimD += 1) {
    genCoefMatrices(dim, dimD, g, vv, vf, ff);
  }
  return function * (v) {
    const vc = [];
    const fc = [];
    const cc = [];
    for (let dimD = 0; dimD < dim; dimD += 1) {
      genCoefMatrices2(dim, dimD, v, vv, vf, ff, vc, fc, cc, 1);
    }
    const setRangeForDepth = (depth, current, nextIncrement, stop) => {
      const range = findRangeForDepth(dim, depth, current, vv, vf, ff, vc, fc,
        cc);
      const min = Math.floor(range[0]) + 1;
      const max = Math.ceil(range[1]) - 1;
      const diff = max - min;
      current[depth] = min + Math.floor(diff / 2);
      if (diff % 2 === 0) {
        nextIncrement[depth] = -1;
      } else {
        nextIncrement[depth] = 1;
      }
      stop[depth] = min - 1;
    };
    const current = new Array(dim).fill(0);
    const nextIncrement = new Array(dim).fill(0);
    const stop = new Array(dim).fill(0);
    let depth = 0;
    setRangeForDepth(depth, current, nextIncrement, stop);
    while (true) {
      if (current[depth] !== stop[depth]) {
        if (depth < dim - 1) {
          depth += 1;
          setRangeForDepth(depth, current, nextIncrement, stop);
          continue
        }
        yield current;
      } else {
        if (depth === 0) {
          break
        } else {
          depth -= 1;
        }
      }
      current[depth] += nextIncrement[depth];
      if (nextIncrement[depth] > 0) {
        nextIncrement[depth] = -(nextIncrement[depth] + 1);
      } else {
        nextIncrement[depth] = -(nextIncrement[depth] - 1);
      }
    }
  }
}

// m and v are the linear transformation matrix and the translation
// vector, repsectively, by which a cutoff region represented by an ellipse
// is mapped into the sphere of radius 1.
// Convention of transformation is as follows:
// x' = m (x + v)
// Usage:
//   xFractGenerator(m)(v)
function xFractGenerator2 (mPar, mPerp) {
  const dim = mPar.getDim()[1];
  const dimPar = mPar.getDim()[0];
  const dimPerp = mPerp.getDim()[0];
  // error check
  // ...
  if (dimPerp === 0) {
    return xFractGenerator(mPar)
  }
  // numerical only
  const gPar = lnum$4.mmul(lnum$4.transpose(mPar), mPar);
  const gPerp = lnum$4.mmul(lnum$4.transpose(mPerp), mPerp);
  const g = lnum$4.add(gPar, gPerp);
  // v: variable, f: fixed, c: constant, index === dimD
  const vvPar = [];
  const vfPar = [];
  const ffPar = [];
  const vvPerp = [];
  const vfPerp = [];
  const ffPerp = [];
  for (let dimD = 0; dimD < dim; dimD += 1) {
    if (dimD < dimPar) {
      genCoefMatrices(dim, dimD, gPar, vvPar, vfPar, ffPar);
    } else {
      genCoefMatrices(dim, dimD, g, vvPar, vfPar, ffPar);
    }
    if (dimD < dimPerp) {
      genCoefMatrices(dim, dimD, gPerp, vvPerp, vfPerp, ffPerp);
    } else if (dimD < dimPar) {
      genCoefMatrices(dim, dimD, g, vvPerp, vfPerp, ffPerp);
    }
  }
  return function * (v) {
    const vcPar = [];
    const fcPar = [];
    const ccPar = [];
    const vcPerp = [];
    const fcPerp = [];
    const ccPerp = [];
    for (let dimD = 0; dimD < dim; dimD += 1) {
      if (dimD < dimPar) {
        genCoefMatrices2(dim, dimD, v, vvPar, vfPar, ffPar, vcPar, fcPar, ccPar,
          1);
      } else {
        genCoefMatrices2(dim, dimD, v, vvPar, vfPar, ffPar, vcPar, fcPar, ccPar,
          2);
      }
      if (dimD < dimPerp) {
        genCoefMatrices2(dim, dimD, v, vvPerp, vfPerp, ffPerp, vcPerp, fcPerp,
          ccPerp, 1);
      } else if (dimD < dimPar) {
        genCoefMatrices2(dim, dimD, v, vvPerp, vfPerp, ffPerp, vcPerp, fcPerp,
          ccPerp, 2);
      }
    }
    const setRangeForDepth = (depth, current, nextIncrement, stop) => {
      const dimD = dim - (depth + 1);
      const rangePar = findRangeForDepth(dim, depth, current, vvPar, vfPar,
        ffPar, vcPar, fcPar, ccPar);
      let range;
      if (dimD < dimPerp || dimD < dimPar) {
        const rangePerp = findRangeForDepth(dim, depth, current, vvPerp, vfPerp,
          ffPerp, vcPerp, fcPerp, ccPerp);
        const range0 = Math.max(rangePar[0], rangePerp[0]);
        range = [
          range0, Math.max(Math.min(rangePar[1], rangePerp[1]), range0)];
      } else {
        range = rangePar;
      }
      const min = Math.floor(range[0]) + 1;
      const max = Math.ceil(range[1]) - 1;
      const diff = max - min;
      current[depth] = min + Math.floor(diff / 2);
      if (diff % 2 === 0) {
        nextIncrement[depth] = -1;
      } else {
        nextIncrement[depth] = 1;
      }
      stop[depth] = min - 1;
    };
    const current = new Array(dim).fill(0);
    const nextIncrement = new Array(dim).fill(0);
    const stop = new Array(dim).fill(0);
    let depth = 0;
    setRangeForDepth(depth, current, nextIncrement, stop);
    while (true) {
      if (current[depth] !== stop[depth]) {
        if (depth < dim - 1) {
          depth += 1;
          setRangeForDepth(depth, current, nextIncrement, stop);
          continue
        }
        yield current;
      } else {
        if (depth === 0) {
          break
        } else {
          depth -= 1;
        }
      }
      current[depth] += nextIncrement[depth];
      if (nextIncrement[depth] > 0) {
        nextIncrement[depth] = -(nextIncrement[depth] + 1);
      } else {
        nextIncrement[depth] = -(nextIncrement[depth] - 1);
      }
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */
// ... ad hoc

const genHighlightRefBit = (
  { typeId, odId, ssgId, lattFractCoord }, lattOffset
) => {
  lattOffset = lattOffset || [0, 0, 0, 0, 0, 0];
  const offset = [0, 0, 0, 0, 0, 0].map(
    (x, i) => i < lattOffset.length
      ? lattOffset[i]
      : x
  );
  if (lattFractCoord) {
    lattFractCoord = lattFractCoord.map(
      (x, i) => {
        x = x - offset[i];
        if (Math.abs(x) >= 128) {
          x = -128;
        }
        return x + 128
      }
    );
  }
  return [
    typeId,
    odId << SSGID_BIT_LENGTH & ODID_BIT |
    ssgId - 1 & SSGID_BIT, // ssgId -> ssgInternalId
    lattFractCoord
      ? lattFractCoord[0] << 24 |
        lattFractCoord[1] << 16 |
        lattFractCoord[2] << 8 |
        lattFractCoord[3]
      : 0,
    lattFractCoord
      ? lattFractCoord[4] << 24 |
        lattFractCoord[5] << 16
      : 0
  ]
};

const genHighlightMaskBit = ({ type, od, ssg, latt }) => {
  return [
    type ? ~0 : 0,
    (od ? ODID_BIT : 0) |
    (ssg ? SSGID_BIT : 0),
    latt ? ~0 : 0,
    latt ? ~0 : 0
  ]
};

const NOT_READY = 0;
const NSUB_OCTAHEDRON = 7;
const NPHI_CYLINDER = 15;
const CLEAR_INFO = genHighlightRefBit({
  typeId: TYPEID_NONE,
  odId: INVALID_ODID,
  ssgId: 0,
  lattFractCoord: null
});
const VBO_ODFRAG_ASYM_STRIDE = [2, 12, 28, 52];
const VBO_ODFRAG_STRIDE = [4, 16, 44, 88];
const ODFRAG_VID_START = [0, 1, 1, 0];
const NUM_ODFRAG_VIDS = [1, 2, 3, 8];
const DRAW_ODFRAG_MODE = ['POINTS', 'LINES', 'TRIANGLES', 'TRIANGLE_STRIP'];

const genViewportsFromPanel = function * (panel, left, bottom, right, top) {
  if (panel.splitX) {
    const splitX = panel.splitX * (right - left) + left;
    yield * genViewportsFromPanel(panel.subpanel1, left, bottom, splitX, top);
    yield * genViewportsFromPanel(panel.subpanel2, splitX, bottom, right, top);
  } else if (panel.splitY) {
    const splitY = top - panel.splitY * (top - bottom);
    yield * genViewportsFromPanel(panel.subpanel1, left, splitY, right, top);
    yield * genViewportsFromPanel(panel.subpanel2, left, bottom, right, splitY);
  } else {
    const x = Math.round(left);
    const y = Math.round(bottom);
    const width = Math.round(right) - x;
    const height = Math.round(top) - y;
    yield { ...panel, x, y, width, height };
  }
};

const clientSizeOf = (gl, viewport) => {
  const canvas = gl.canvas;
  const clientWidth = canvas.clientWidth;
  const clientHeight = canvas.clientHeight;
  // the following codes should be used if padding may be non-zero
  // const style = window.getComputedStyle(canvas)
  // const pl = parseInt(style.getPropertyValue('padding-left'), 10)
  // const pr = parseInt(style.getPropertyValue('padding-right'), 10)
  // const pt = parseInt(style.getPropertyValue('padding-top'), 10)
  // const pb = parseInt(style.getPropertyValue('padding-bottom'), 10)
  // clientWidth -= (pl + pr)
  // clientHeight -= (pt + pb)
  const viewportClientWidth = viewport.width / gl.drawingBufferWidth *
    clientWidth;
  const viewportClientHeight = viewport.height / gl.drawingBufferHeight *
    clientHeight;
  return [viewportClientWidth, viewportClientHeight]
};

const canvasCoordOf = (gl, [clientX, clientY]) => {
  const canvas = gl.canvas;
  const clientWidth = canvas.clientWidth;
  const clientHeight = canvas.clientHeight;
  const clientRect = canvas.getBoundingClientRect();
  // currently, padding, etc. are not considered
  let x = (clientX - clientRect.left) / clientWidth * gl.drawingBufferWidth;
  x = Math.max(Math.min(Math.floor(x), gl.drawingBufferWidth - 1), 0);
  let y = (1 - (clientY - clientRect.top) / clientHeight) *
    gl.drawingBufferHeight - 1;
  y = Math.max(Math.min(Math.floor(y), gl.drawingBufferHeight - 1), 0);
  return { x, y }
};

class QCWeb2Core {
  constructor (
    canvas,
    store,
    overlayPanelSelector,
    quasicrystalSelector,
    overlayPanelSetData,
    subscribers = {}
  ) {
    const gl = this.gl = canvas.getContext('webgl2');
    if (gl) {
      this.store = store;
      this.overlayPanelSelector = overlayPanelSelector;
      this.quasicrystalSelector = quasicrystalSelector;
      this.overlayPanelSetData = overlayPanelSetData;
      this.subscribers = subscribers;
      this.onLost = e => {
        console.log('context lost');
        e.preventDefault();
        if (this.requestId !== 0) {
          window.cancelAnimationFrame(this.requestId);
          this.requestId = 0;
        }
      };
      this.onRestored = e => {
        console.log('context restored');
        this.initialise();
      };
      canvas.addEventListener('webglcontextlost', this.onLost, false);
      canvas.addEventListener('webglcontextrestored', this.onRestored, false);
      this.initialise();

      // test for lose context
      // const ext = gl.getExtension('WEBGL_lose_context')
      // window.setInterval(() => {
      //   ext.loseContext()
      //   window.setTimeout(() => ext.restoreContext(), 3000)
      // }, 20000)
    }
  }

  destructor () {
    const gl = this.gl;
    if (gl) {
      const canvas = gl.canvas;
      canvas.removeEventListener('webglcontextlost', this.onLost, false);
      canvas.removeEventListener('webglcontextrestored', this.onRestored, false);
      this.onLost = null;
      this.onRestored = null;
      this.update = null;
      if (this.requestId !== 0) {
        window.cancelAnimationFrame(this.requestId);
        this.requestId = 0;
      }
      this.finalise();
      this.store = null;
      this.gl = null;
    }
  }

  initialise () {
    this.initialiseResources();
    this.initialiseUpdater();
    this.initialiseUI();
    this.requestId = window.requestAnimationFrame(this.update);
    this.prev = window.performance.now();
    this.frameCount = 0;
  }

  finalise () {
    this.finaliseUpdater();
    this.finaliseResources();
  }

  initialiseResources () {
    this.initialiseVertexShaders();
    this.initialiseFragmentShaders();
    this.initialisePrograms();
    this.initialiseFramebuffers();
    this.initialiseUniformBuffers();
    this.initialiseVertexBuffers();
    this.initialiseTextures();
  }

  finaliseResources () {
    this.finalisePrograms();
    this.finaliseVertexShaders();
    this.finaliseFragmentShaders();
    this.finaliseFramebuffers();
    this.finaliseUniformBuffers();
    this.finaliseVertexBuffers();
    this.finaliseTextures();
  }

  initialiseVertexShaders () {
    const gl = this.gl;
    const vs = this.vs = {};
    vs.fillViewportFar = createVertexShaderDebug(gl, FILL_VIEWPORT_FAR_VS);
    vs.drawAtoms = createVertexShaderDebug(gl, DRAW_ATOMS_VS);
    vs.drawAtomsInfo = createVertexShaderDebug(gl, DRAW_ATOMS_INFO_VS);
    vs.drawHalfBonds = createVertexShaderDebug(gl, DRAW_HALF_BONDS_VS);
    vs.drawHalfBondsInfo = createVertexShaderDebug(gl, DRAW_HALF_BONDS_INFO_VS);
    vs.drawVertices = createVertexShaderDebug(gl, DRAW_CLUSTER_VERTICES_VS);
    vs.drawVerticesInfo = createVertexShaderDebug(gl, DRAW_CLUSTER_VERTICES_INFO_VS);
    vs.drawEdges = createVertexShaderDebug(gl, DRAW_CLUSTER_EDGES_VS);
    vs.drawEdgesInfo = createVertexShaderDebug(gl, DRAW_CLUSTER_EDGES_INFO_VS);
    vs.drawFaces = createVertexShaderDebug(gl, DRAW_CLUSTER_FACES_VS);
    vs.drawFacesInfo = createVertexShaderDebug(gl, DRAW_CLUSTER_FACES_INFO_VS);
    // vs.drawLines = createVertexShader(gl, DRAW_LINES_VS)
    vs.drawODFrags = createVertexShaderDebug(gl, DRAW_ODFRAGS_VS);
    vs.drawODFragsInfo = createVertexShaderDebug(gl, DRAW_ODFRAGS_INFO_VS);
    vs.proj = createVertexShaderDebug(gl, PROJ_VS);
    vs.colourAtoms = createVertexShaderDebug(gl, COLOUR_ATOMS_VS);
    vs.cut = CUT_VS.map(src => createVertexShaderDebug(gl, src));
    vs.maskDisplacements = createVertexShaderDebug(gl, MASK_DISPLACEMENTS_VS);
    vs.prepODFrags = PREP_ODFRAGS_VS.map(src => createVertexShaderDebug(gl, src));
    vs.genODInstances = GEN_OD_INSTANCES_VS.map(
      src => createVertexShaderDebug(gl, src)
    );
  }

  finaliseVertexShaders () {
    const gl = this.gl;
    for (const vs of Object.values(this.vs)) {
      if (Array.isArray(vs)) {
        for (const vsi of vs) {
          gl.deleteShader(vsi);
        }
      } else {
        gl.deleteShader(vs);
      }
    }
  }

  initialiseFragmentShaders () {
    const gl = this.gl;
    const fs = this.fs = {};
    fs.simple = createFragmentShaderDebug(gl, SIMPLE_FS);
    fs.simpleDummyPosition = createFragmentShaderDebug(gl, SIMPLE_FS_DUMMY_POSITION);
    fs.simpleUint = createFragmentShaderDebug(gl, SIMPLE_UINT_FS);
    fs.normal = createFragmentShaderDebug(gl, NORMAL_FS);
    fs.flat = createFragmentShaderDebug(gl, FLAT_FS);
    fs.white = createFragmentShaderDebug(gl, WHITE_FS);
    fs.dummy = createFragmentShaderDebug(gl, DUMMY_FS);
  }

  finaliseFragmentShaders () {
    const gl = this.gl;
    for (const fs of Object.values(this.fs)) {
      gl.deleteShader(fs);
    }
  }

  initialisePrograms () {
    const gl = this.gl;
    const vs = this.vs;
    const fs = this.fs;
    const prg = this.prg = {};
    prg.fillBGWhite = createProgramDebug(gl, vs.fillViewportFar, fs.white);
    prg.drawAtoms = createProgramDebug(
      gl, vs.drawAtoms, fs.normal,
      { uboBlockBindings: [ENVIRONMENT_UNIFORM_BLOCK_BINDING] }
    );
    prg.drawAtomsInfo = createProgramDebug(
      gl, vs.drawAtomsInfo, fs.simpleUint
    );
    prg.drawHalfBonds = createProgramDebug(
      gl, vs.drawHalfBonds, fs.normal,
      { uboBlockBindings: [ENVIRONMENT_UNIFORM_BLOCK_BINDING] }
    );
    prg.drawHalfBondsInfo = createProgramDebug(
      gl, vs.drawHalfBondsInfo, fs.simpleUint
    );
    prg.drawVertices = createProgramDebug(
      gl, vs.drawVertices, fs.normal,
      { uboBlockBindings: [ENVIRONMENT_UNIFORM_BLOCK_BINDING] }
    );
    prg.drawVerticesInfo = createProgramDebug(
      gl, vs.drawVerticesInfo, fs.simpleUint
    );
    prg.drawEdges = createProgramDebug(
      gl, vs.drawEdges, fs.normal,
      { uboBlockBindings: [ENVIRONMENT_UNIFORM_BLOCK_BINDING] }
    );
    prg.drawEdgesInfo = createProgramDebug(
      gl, vs.drawEdgesInfo, fs.simpleUint
    );
    prg.drawFaces = createProgramDebug(
      gl, vs.drawFaces, fs.flat,
      { uboBlockBindings: [ENVIRONMENT_UNIFORM_BLOCK_BINDING] }
    );
    prg.drawFacesInfo = createProgramDebug(
      gl, vs.drawFacesInfo, fs.simpleUint
    );
    // prg.drawLines = createProgram(gl, vs.drawLines, fs.simple)
    prg.proj = createProgramDebug(
      gl, vs.proj, fs.dummy,
      {
        tfVaryings: ['vRFractLattId', 'vRParCartn', 'vRPerpCartn'],
        tfBuffMode: gl.INTERLEAVED_ATTRIBS,
        uboBlockBindings: [CARTN_TRANSFORM_UNIFORM_BLOCK_BINDING]
      }
    );
    prg.colourAtoms = createProgramDebug(
      gl, vs.colourAtoms, fs.dummy,
      {
        tfVaryings: ['vColour', 'vRadius', 'vInfo'],
        tfBuffMode: gl.INTERLEAVED_ATTRIBS,
        uboBlockBindings: [HIGHLIGHT_UNIFORM_BLOCK_BINDING]
      }
    );
    gl.useProgram(prg.colourAtoms);
    gl.uniform1i(
      gl.getUniformLocation(prg.colourAtoms, 'odColourRadius'),
      OD_COLOUR_RADIUS_TEXTURE_UNIT
    );
    gl.uniform1i(
      gl.getUniformLocation(prg.colourAtoms, 'cut'), CUT_TEXTURE_UNIT
    );
    gl.useProgram(null);
    prg.cut = vs.cut.map(vsi => createProgramDebug(gl, vsi, fs.simpleUint));
    prg.maskDisplacements = createProgramDebug(
      gl, vs.maskDisplacements, fs.dummy,
      {
        tfVaryings: [
          'vDisplacementOccupancy', 'vTargetColour', 'vTargetRadius'
        ],
        tfBuffMode: gl.INTERLEAVED_ATTRIBS,
        uboBlockBindings: [HIGHLIGHT_UNIFORM_BLOCK_BINDING]
      }
    );
    gl.useProgram(prg.maskDisplacements);
    gl.uniform1i(
      gl.getUniformLocation(prg.maskDisplacements, 'odColourRadius'),
      OD_COLOUR_RADIUS_TEXTURE_UNIT
    );
    gl.uniform1i(
      gl.getUniformLocation(prg.maskDisplacements, 'cut'), CUT_TEXTURE_UNIT
    );
    gl.useProgram(null);
    prg.genODInstances = vs.genODInstances.map(vsi => createProgramDebug(
      gl, vsi, fs.dummy,
      {
        tfVaryings: GEN_OD_INSTANCES_TF_VARYINGS,
        tfBuffMode: gl.INTERLEAVED_ATTRIBS,
        uboBlockBindings: [HIGHLIGHT_UNIFORM_BLOCK_BINDING]
      }
    ));
    for (const p of prg.genODInstances) {
      gl.useProgram(p);
      gl.uniform1i(
        gl.getUniformLocation(p, 'odColourRadius'),
        OD_COLOUR_RADIUS_TEXTURE_UNIT
      );
      gl.useProgram(null);
    }
    prg.drawODFrags = [
      fs.simpleDummyPosition, fs.simpleDummyPosition, fs.flat, fs.flat
    ].map(
      (fs, dimPerp) => createProgramDebug(
        gl, vs.drawODFrags, fs,
        dimPerp >= 2
          ? { uboBlockBindings: [ENVIRONMENT_UNIFORM_BLOCK_BINDING] }
          : undefined
      )
    );
    prg.drawODFragsInfo = createProgramDebug(
      gl, vs.drawODFragsInfo, fs.simpleUint
    );
    prg.prepODFrags = vs.prepODFrags.map((vsi, i) => createProgramDebug(
      gl, vsi, fs.dummy,
      {
        tfVaryings: PREP_ODFRAGS_TF_VARYINGS[i],
        tfBuffMode: gl.INTERLEAVED_ATTRIBS
      }
    ));
  }

  finalisePrograms () {
    const gl = this.gl;
    for (const prg of Object.values(this.prg)) {
      if (Array.isArray(prg)) {
        for (const prgi of prg) {
          gl.deleteProgram(prgi);
        }
      } else {
        gl.deleteProgram(prg);
      }
    }
  }

  initialiseFramebuffers () {
    const gl = this.gl;
    this.fbo = {};
    this.rbo = {};
    this.pbo = {};
    this.sync = {};
    // info
    {
      const fbo = this.fbo.info = gl.createFramebuffer();
      const rboColour = this.rbo.infoColour = gl.createRenderbuffer();
      const rboDepth = this.rbo.infoDepth = gl.createRenderbuffer();
      this.pbo.info = createBuffer(
        gl, gl.PIXEL_PACK_BUFFER, 16, gl.DYNAMIC_READ
      );
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
      gl.readBuffer(gl.COLOR_ATTACHMENT0);
      gl.bindRenderbuffer(gl.RENDERBUFFER, rboColour);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA32UI, 1, 1);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
        gl.RENDERBUFFER, rboColour);
      gl.bindRenderbuffer(gl.RENDERBUFFER, rboDepth);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT24, 1, 1);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
        gl.RENDERBUFFER, rboDepth);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      // fbo and pbo are kept bound
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.pbo.info);
      this.infoODLabels = null;
      this.sync.info = null;
    }
  }

  finaliseFramebuffers () {
    const gl = this.gl;
    for (const fbo of this.fbo) {
      gl.deleteFramebuffer(fbo);
    }
    for (const rbo of this.rbo) {
      gl.deleteRenderbuffer(rbo);
    }
    for (const pbo of this.pbo) {
      gl.deleteBuffer(pbo);
    }
  }

  initialiseUniformBuffers () {
    const gl = this.gl;
    const ubo = this.ubo = {};
    ubo.environment = createUniformBuffer(
      gl, ENVIRONMENT_UNIFORM_BUFFER_SIZE, gl.DYNAMIC_DRAW,
      ENVIRONMENT_UNIFORM_BINDING_POINT_INDEX
    );
    ubo.cartnTransform = createUniformBuffer(
      gl, CARTN_TRANSFORM_UNIFORM_BUFFER_SIZE, gl.DYNAMIC_DRAW,
      CARTN_TRANSFORM_UNIFORM_BINDING_POINT_INDEX
    );
    ubo.highlight = createUniformBuffer(
      gl, HIGHLIGHT_UNIFORM_BUFFER_SIZE, gl.DYNAMIC_DRAW,
      HIGHLIGHT_UNIFORM_BINDING_POINT_INDEX
    );
  }

  finaliseUniformBuffers () {
    const gl = this.gl;
    for (const ubo of Object.values(this.ubo)) {
      gl.deleteBuffer(ubo);
    }
  }

  initialiseVertexBuffers () {
    const gl = this.gl;
    this.vbo = {};
    this.ibo = {};
    this.vao = {};
    // sphere
    {
      const sphere = genHalfOctahedron(NSUB_OCTAHEDRON);
      this.vbo.sphere = createBuffer(
        gl, gl.ARRAY_BUFFER, new Float32Array(sphere.v), gl.STATIC_DRAW
      );
      // !!! Uint32 no need ???
      this.ibo.sphere = createBuffer(
        gl, gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(sphere.i), gl.STATIC_DRAW
      );
      this.vCountSphere = sphere.i.length;
    }
    // cylinder
    {
      const cylinder = genCylinder(NPHI_CYLINDER);
      this.vbo.cylinder = createBuffer(
        gl, gl.ARRAY_BUFFER, new Float32Array(cylinder.vn), gl.STATIC_DRAW
      );
      // !!! Uint32 no need ???
      this.ibo.cylinder = createBuffer(
        gl, gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(cylinder.i), gl.STATIC_DRAW
      );
      this.vCountCylinder = cylinder.i.length;
    }
    // site ssg id
    this.vbo.siteSSGId = gl.createBuffer();
    this.vboSiteSSGIdSize = 0;
    // fract_coord site
    this.vbo.siteFractCoord = gl.createBuffer();
    this.vboSiteFractCoordSize = 0;
    // od fragment asym
    this.vbo.odFragAsym = gl.createBuffer();
    this.vboODFragAsymSize = 0;
    // od fragment
    this.vbo.odFrag = gl.createBuffer();
    this.vboODFragSize = 0;
    // od fragment vid
    this.vbo.odFragVId = createBuffer(
      gl,
      gl.ARRAY_BUFFER,
      new Int8Array([0, 0, 1, 2, 3, 0, 1, 1]),
      gl.STATIC_DRAW
    );
    // od instance
    this.vbo.odInstance = gl.createBuffer();
    this.vboODInstanceSize = 0;
    // fract coords
    this.vbo.lattFractCoord = createBuffer(
      gl, gl.ARRAY_BUFFER, MAX_RFRACTLATT_COUNT * 6, gl.DYNAMIC_DRAW
    );
    // proj
    this.vbo.proj = createBuffer(
      gl, gl.ARRAY_BUFFER, MAX_RFRACTLATT_COUNT * 8 * 4, gl.DYNAMIC_COPY
    );
    // proj dummy
    this.vbo.projDummy = createBuffer(
      gl,
      gl.ARRAY_BUFFER,
      new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]),
      gl.STATIC_DRAW
    );
    // atom
    this.vbo.atom = createBuffer(
      gl, gl.ARRAY_BUFFER, MAX_RFRACTLATT_COUNT * 12 * 4, gl.DYNAMIC_COPY
    );
    // atom dummy
    this.vbo.atomDummy = createBuffer(
      gl,
      gl.ARRAY_BUFFER,
      new Float32Array([0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]),
      gl.STATIC_DRAW
    );
    // bond etc.
    this.vbo.bondetc = createBuffer(
      gl, gl.ARRAY_BUFFER, MAX_RFRACTLATT_COUNT * 36 * 4, gl.DYNAMIC_COPY
    );
    // face vid
    this.vbo.faceVId = createBuffer(
      gl,
      gl.ARRAY_BUFFER,
      new Int8Array([0, 1, 2]),
      gl.STATIC_DRAW
    );
    // displacement
    this.vbo.displacement = gl.createBuffer();
    this.vboDisplacementSize = 0;
    // asym bond displacement
    this.vbo.asymBondDisplacement = gl.createBuffer();
    this.vboAsymBondDisplacementSize = 0;
    // bond displacement
    this.vbo.bondDisplacement = gl.createBuffer();
    this.vboBondDisplacementSize = 0;
    // vertex displacement
    this.vbo.vertexDisplacement = gl.createBuffer();
    this.vboVertexDisplacementSize = 0;
    // edge displacement
    this.vbo.edgeDisplacement = gl.createBuffer();
    this.vboEdgeDisplacementSize = 0;
    // face displacement
    this.vbo.faceDisplacement = gl.createBuffer();
    this.vboFaceDisplacementSize = 0;
    // vao colour atoms
    {
      const vao = this.vao.colourAtoms = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribIPointer(0, 2, gl.UNSIGNED_INT, 32, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao mask asym bonds
    {
      const vao = this.vao.maskAsymBonds = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.asymBondDisplacement);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribIPointer(0, 1, gl.UNSIGNED_BYTE, 28, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 28, 4);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao mask bonds
    {
      const vao = this.vao.maskBonds = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondDisplacement);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribIPointer(0, 1, gl.UNSIGNED_BYTE, 28, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 28, 4);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao mask vertices
    {
      const vao = this.vao.maskVertices = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.vertexDisplacement);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribIPointer(0, 1, gl.UNSIGNED_BYTE, 16, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 16, 4);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao mask edges
    {
      const vao = this.vao.maskEdges = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.edgeDisplacement);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribIPointer(0, 1, gl.UNSIGNED_BYTE, 16, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 16, 4);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao mask faces
    {
      const vao = this.vao.maskFaces = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.faceDisplacement);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribIPointer(0, 1, gl.UNSIGNED_BYTE, 16, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 16, 4);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw odfrags (only perp)
    {
      const vao = this.vao.drawODFrags = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odInstance);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 44, 0);
      gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 44, 12);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.displacement);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw odfrags info (only perp)
    {
      const vao = this.vao.drawODFragsInfo = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odInstance);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 44, 0);
      gl.vertexAttribIPointer(1, 4, gl.UNSIGNED_INT, 44, 28);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.displacement);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // atoms experimental ...
    // vao draw atoms par
    {
      const vao = this.vao.drawAtomsPar = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.sphere);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.sphere);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 48, 16);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw atoms info par
    {
      const vao = this.vao.drawAtomsInfoPar = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.sphere);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.sphere);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 48, 16);
      gl.vertexAttribIPointer(3, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw atoms perp
    {
      const vao = this.vao.drawAtomsPerp = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.sphere);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.sphere);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 20);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 48, 16);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw atoms info perp
    {
      const vao = this.vao.drawAtomsInfoPerp = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.sphere);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.sphere);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 20);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 48, 16);
      gl.vertexAttribIPointer(3, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // ... atoms experimental
    // bonds experimental ...
    // vao draw bonds (only par)
    {
      const vao = this.vao.drawHalfBonds = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.cylinder);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.cylinder);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(3);
      gl.enableVertexAttribArray(4);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 48, 16);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(5);
      gl.enableVertexAttribArray(6);
      gl.vertexAttribDivisor(5, 1);
      gl.vertexAttribDivisor(6, 1);
      gl.vertexAttribPointer(5, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(6, 4, gl.FLOAT, false, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw bonds info (only par)
    {
      const vao = this.vao.drawHalfBondsInfo = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.cylinder);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.cylinder);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 48, 16);
      gl.vertexAttribIPointer(3, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(4);
      gl.enableVertexAttribArray(5);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribDivisor(5, 1);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(5, 4, gl.FLOAT, false, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // ... bonds experimental
    // vertices experimental ...
    // vao draw vertices (only par)
    {
      const vao = this.vao.drawVertices = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.sphere);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.sphere);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(3);
      gl.enableVertexAttribArray(4);
      gl.enableVertexAttribArray(5);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribDivisor(5, 1);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 48, 16);
      gl.vertexAttribPointer(5, 4, gl.FLOAT, false, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw vertices info (only par)
    {
      const vao = this.vao.drawVerticesInfo = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.sphere);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.sphere);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 12, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(3);
      gl.enableVertexAttribArray(4);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // ... vertices experimental
    // edges experimental ...
    // vao draw edges (only par)
    {
      const vao = this.vao.drawEdges = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.cylinder);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.cylinder);
      gl.enableVertexAttribArray(0);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(3);
      gl.enableVertexAttribArray(4);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 48, 0);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 48, 16);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(5);
      gl.enableVertexAttribArray(6);
      gl.vertexAttribDivisor(5, 1);
      gl.vertexAttribDivisor(6, 1);
      gl.vertexAttribPointer(5, 4, gl.FLOAT, false, 96, 0);
      gl.vertexAttribPointer(6, 4, gl.FLOAT, false, 96, 48);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw edges info (only par)
    {
      const vao = this.vao.drawEdgesInfo = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo.cylinder);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.cylinder);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 48, 16);
      gl.vertexAttribIPointer(3, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(4);
      gl.enableVertexAttribArray(5);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribDivisor(5, 1);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 96, 0);
      gl.vertexAttribPointer(5, 4, gl.FLOAT, false, 96, 48);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // ... edges experimental
    // faces experimental ...
    // vao draw faces (only par)
    {
      const vao = this.vao.drawFaces = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.faceVId);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribIPointer(0, 1, gl.BYTE, 1, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 48, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(3);
      gl.enableVertexAttribArray(4);
      gl.enableVertexAttribArray(5);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribDivisor(5, 1);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 144, 0);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 144, 48);
      gl.vertexAttribPointer(5, 4, gl.FLOAT, false, 144, 96);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // vao draw faces info (only par)
    {
      const vao = this.vao.drawFacesInfo = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.faceVId);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribIPointer(0, 1, gl.BYTE, 1, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribDivisor(1, 1);
      gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 32, 8);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.atom);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribDivisor(2, 1);
      gl.vertexAttribIPointer(2, 4, gl.UNSIGNED_INT, 48, 32);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondetc);
      gl.enableVertexAttribArray(3);
      gl.enableVertexAttribArray(4);
      gl.enableVertexAttribArray(5);
      gl.vertexAttribDivisor(3, 1);
      gl.vertexAttribDivisor(4, 1);
      gl.vertexAttribDivisor(5, 1);
      gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 144, 0);
      gl.vertexAttribPointer(4, 4, gl.FLOAT, false, 144, 48);
      gl.vertexAttribPointer(5, 4, gl.FLOAT, false, 144, 96);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    // ... faces experimental
    gl.bindVertexArray(null);
  }

  finaliseVertexBuffers () {
    const gl = this.gl;
    for (const vao of Object.values(this.vao)) {
      gl.deleteVertexArray(vao);
    }
    for (const vbo of Object.values(this.vbo)) {
      gl.deleteBuffer(vbo);
    }
    for (const ibo of Object.values(this.ibo)) {
      gl.deleteBuffer(ibo);
    }
  }

  initialiseTextures () {
    const gl = this.gl;
    this.tex = {};
    this.fbTex = {};
    // ssg
    {
      const ssg = this.tex.ssg = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0 + SSG_TEXTURE_UNIT);
      gl.bindTexture(gl.TEXTURE_2D, ssg);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA32F, MAX_SSG_TEXTURE_WIDTH, 2);
    }
    // od-colour-radius
    {
      const odColourRadius = this.tex.odColourRadius = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0 + OD_COLOUR_RADIUS_TEXTURE_UNIT);
      gl.bindTexture(gl.TEXTURE_2D, odColourRadius);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      this.odColourRadiusTextureHeight = 0;
    }
    // cut
    {
      const texCut = this.tex.cut = gl.createTexture();
      const width = CUT_TEXTURE_WIDTH;
      const depth = this.texCutDepth = 1;
      gl.activeTexture(gl.TEXTURE0 + CUT_TEXTURE_UNIT);
      gl.bindTexture(gl.TEXTURE_2D_ARRAY, texCut);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.R32UI, width, width, depth);
      const fbCut = this.fbTex.cut = gl.createFramebuffer();
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fbCut);
      gl.framebufferTextureLayer(
        gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, texCut, 0, 0
      );
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    }
  }

  finaliseTextures () {
    const gl = this.gl;
    for (const fbTex of this.fbTex) {
      gl.deleteFramebuffer(fbTex);
    }
    for (const tex of Object.values(this.tex)) {
      gl.deleteTexture(tex);
    }
  }

  initialiseUpdater () {
    this.lastUpdateFailed = true;
    this.lastContext = null;
    this.lastInfo = null;
    this.atomSites = [];
    this.mapODIdToAtomSiteId = [];
    this.deltaOFract = null;
    this.deltaOFractOffset = null;
    this.rCutParCartn = 3.0;
    this.rCutParCartnMin = 1e-3;
    this.rCutParCartnMax = 30.0;
    this.baseRadius = 0.3;
    this.odBaseOpacity = 0.5;
    // ad hoc ...
    this.unhighlightColourFactor = [0.2, 0.2, 0.2, 0.2];
    this.unhighlightRadiusFactor = [0.2, 0.2, 0.2, 0.2];
    this.highlightRef = {
      typeId: TYPEID_NONE,
      type: TYPE_TEXT[TYPEID_NONE],
      odId: INVALID_ODID,
      odLabel: '',
      ssgId: 0,
      lattFractCoord: null
    };
    this.highlightMask = {
      type: false,
      od: false,
      ssg: false,
      latt: false
    };
    // ... ad hoc
    // ad hoc ...
    this.cameraPar = new Camera();
    this.cameraPar.orthographic = false;
    this.cameraPerp = new Camera();
    this.cameraPerp.orthographic = false;
    if (this.subscribers.cameraOrthographic) {
      this.subscribers.cameraOrthographic(this.cameraPar.orthographic);
    }
    // ... ad hoc

    const selectState = ctx => ctx.state;
    const selectCanvasSize = createSelector(
      [
        () => this.gl,
        () => this.gl.canvas,
        () => this.gl.canvas.clientWidth,
        () => this.gl.canvas.clientHeight
      ],
      (gl, canvas, clientWidth, clientHeight) => {
        // the following codes should be used if padding may be non-zero
        // const style = window.getComputedStyle(canvas)
        // const pl = parseInt(style.getPropertyValue('padding-left'), 10)
        // const pr = parseInt(style.getPropertyValue('padding-right'), 10)
        // const pt = parseInt(style.getPropertyValue('padding-top'), 10)
        // const pb = parseInt(style.getPropertyValue('padding-bottom'), 10)
        // clientWidth -= (pl + pr)
        // clientHeight -= (pt + pb)
        canvas.width = clientWidth; // - pl - pr
        canvas.height = clientHeight; // - pt - pb
        return [gl.drawingBufferWidth, gl.drawingBufferHeight]
      }
    );
    const selectWidth = createSelector(
      [selectCanvasSize], canvasSize => canvasSize[0]
    );
    const selectHeight = createSelector(
      [selectCanvasSize], canvasSize => canvasSize[1]
    );
    const selectOverlayPanel = createSelector(
      [selectState], this.overlayPanelSelector
    );
    const selectViewports = createSelector(
      [selectOverlayPanel, selectWidth, selectHeight],
      (overlayPanel, width, height) => Array.from(
        genViewportsFromPanel(overlayPanel.rootPanel, 0, 0, width, height)
      )
    );
    const selectCurrentPosition = createSelector(
      [
        () => this.gl,
        () => this.ui.clientMousePosition
      ],
      canvasCoordOf
    );
    const selectDragStartPosition = createSelector(
      [
        () => this.gl,
        () => this.ui.clientDragStartPosition
      ],
      (gl, clientPosition) => clientPosition
        ? canvasCoordOf(gl, clientPosition)
        : undefined
    );
    const selectQuasicrystal = createSelector(
      [selectState], this.quasicrystalSelector
    );
    const selectDict = createSelector(
      [selectQuasicrystal],
      qc => qc.dictionary
    );
    const selectData = createSelector(
      [selectQuasicrystal],
      qc => qc.data
    );
    const createDataItemSelector = (catId, objId) => {
      const itemSelector = createSelector(
        [selectDict, selectData],
        (dict, data) => selectDataItem(dict, data, catId, objId).value
      );
      return (deps, res) => createSelector([itemSelector, ...deps], res)
    };
    const filterMatrix = matrix => matrix && matrix.every(Number.isFinite)
      ? matrix : false;
    const filterIntegerMatrix = matrix =>
      matrix && matrix.every(Number.isInteger)
        ? matrix : false;
    const filterMatrixArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        if (arr.every(filterMatrix)) {
          return arr
        }
      }
      return false
    };
    const filterIntegerMatrixArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        if (arr.every(filterIntegerMatrix)) {
          return arr
        }
      }
      return false
    };
    const filterNumberArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        if (arr.every(Number.isFinite)) {
          return arr
        }
      }
      return false
    };
    const filterIntegerArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        if (arr.every(Number.isInteger)) {
          return arr
        }
      }
      return false
    };
    const filterIntegerListArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        if (arr.every(
          list => Array.isArray(list) && list.every(Number.isInteger)
        )) {
          return arr
        }
      }
      return false
    };
    const filterStringArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        if (arr.every(str => str)) {
          return arr
        }
      }
      return false
    };
    const filterUniqueStringArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        const set = new Set();
        for (const str of arr) {
          if (!str || set.has(str)) {
            return false
          }
          set.add(str);
        }
        return arr
      }
      return false
    };
    const filterArray = arr => {
      if (arr) {
        arr = arr.map(x => x.value);
        if (arr.every(x => x)) {
          return arr
        }
      }
      return false
    };
    const selectDimPar = createDataItemSelector(
      'cell', 'parallel_space_dimension'
    )([], dim => Number.isInteger(dim) && dim >= 1 && dim <= 3 ? dim : false);
    const selectDimPerp = createDataItemSelector(
      'cell', 'perpendicular_space_dimension'
    )([], dim => Number.isInteger(dim) && dim >= 0 && dim <= 3 ? dim : false);
    const selectAParCartn = createDataItemSelector(
      'cell', 'basis_parallel'
    )([], filterMatrix);
    const selectAPerpCartn = createDataItemSelector(
      'cell', 'basis_perpendicular'
    )([], filterMatrix);
    const selectOFract = createDataItemSelector(
      'cell', 'origin_fract'
    )([], filterMatrix);
    const selectBCartn = createDataItemSelector(
      'cell', 'reciprocal_basis'
    )([], filterMatrix);
    const selectSSGMultiplicity = createDataItemSelector(
      'superspace_group', 'multiplicity'
    )([], mult => Number.isInteger(mult) && mult >= 1 ? mult : false);
    const selectSSGMultiplicationTableSymopIds = createDataItemSelector(
      'superspace_group', 'multiplication_table_symop_id'
    )([], filterIntegerMatrix);
    const selectSSGIds = createDataItemSelector(
      'superspace_group_symop', 'id'
    )([], filterUniqueStringArray);
    const selectR = createDataItemSelector(
      'superspace_group_symop', 'r'
    )([], filterIntegerMatrixArray);
    const selectRPerpNoStrain = createDataItemSelector(
      'superspace_group_symop', 'r_perpendicular_no_strain'
    )([], filterMatrixArray);
    const selectTPerpNoStrain = createDataItemSelector(
      'superspace_group_symop', 't_perpendicular_no_strain'
    )([], filterMatrixArray);
    const selectODDispColours = createDataItemSelector(
      'occupation_domain', 'display_colour'
    )([], filterArray);
    const selectODDispOpacities = createDataItemSelector(
      'occupation_domain', 'display_opacity'
    )([], filterNumberArray);
    const selectODDispRadii = createDataItemSelector(
      'occupation_domain', 'display_radius'
    )([], filterNumberArray);
    const selectAtomSiteLabels = createDataItemSelector(
      'atom_site', 'label'
    )([], filterUniqueStringArray);
    const selectModelSiteLabels = createDataItemSelector(
      'model_site', 'label'
    )([], filterStringArray);
    const selectModelSiteSymopIds = createDataItemSelector(
      'model_site', 'symop_id'
    )([], filterIntegerListArray);
    const selectModelSiteFractCoords = createDataItemSelector(
      'model_site', 'fract_coord'
    )([], filterMatrixArray);
    const selectAsymBondSiteLabels1 = createDataItemSelector(
      'asym_bond', 'atom_site_label_1'
    )([], filterStringArray);
    const selectAsymBondSymopIds1 = createDataItemSelector(
      'asym_bond', 'symop_id_1'
    )([], filterIntegerArray);
    const selectAsymBondCellTranslations1 = createDataItemSelector(
      'asym_bond', 'cell_translation_1'
    )([], filterIntegerMatrixArray);
    const selectAsymBondSiteLabels2 = createDataItemSelector(
      'asym_bond', 'atom_site_label_2'
    )([], filterStringArray);
    const selectAsymBondSymopIds2 = createDataItemSelector(
      'asym_bond', 'symop_id_2'
    )([], filterIntegerArray);
    const selectAsymBondCellTranslations2 = createDataItemSelector(
      'asym_bond', 'cell_translation_2'
    )([], filterIntegerMatrixArray);
    const selectGeomBondSiteLabels1 = createDataItemSelector(
      'geom_bond', 'atom_site_label_1'
    )([], filterStringArray);
    const selectGeomBondSymopIds1 = createDataItemSelector(
      'geom_bond', 'symop_id_1'
    )([], filterIntegerArray);
    const selectGeomBondCellTranslations1 = createDataItemSelector(
      'geom_bond', 'cell_translation_1'
    )([], filterIntegerMatrixArray);
    const selectGeomBondSiteLabels2 = createDataItemSelector(
      'geom_bond', 'atom_site_label_2'
    )([], filterStringArray);
    const selectGeomBondSymopIds2 = createDataItemSelector(
      'geom_bond', 'symop_id_2'
    )([], filterIntegerArray);
    const selectGeomBondCellTranslations2 = createDataItemSelector(
      'geom_bond', 'cell_translation_2'
    )([], filterIntegerMatrixArray);
    const selectClusterVertexSiteLabels = createDataItemSelector(
      'cluster_vertex', 'atom_site_label'
    )([], filterStringArray);
    const selectClusterVertexSymopIds = createDataItemSelector(
      'cluster_vertex', 'symop_id'
    )([], filterIntegerArray);
    const selectClusterVertexCellTranslations = createDataItemSelector(
      'cluster_vertex', 'cell_translation'
    )([], filterIntegerMatrixArray);
    const selectClusterVertexSiteLabels1 = createDataItemSelector(
      'cluster_vertex', 'atom_site_label_1'
    )([], filterStringArray);
    const selectClusterVertexSymopIds1 = createDataItemSelector(
      'cluster_vertex', 'symop_id_1'
    )([], filterIntegerArray);
    const selectClusterVertexCellTranslations1 = createDataItemSelector(
      'cluster_vertex', 'cell_translation_1'
    )([], filterIntegerMatrixArray);
    const selectClusterEdgeSiteLabels = createDataItemSelector(
      'cluster_edge', 'atom_site_label'
    )([], filterStringArray);
    const selectClusterEdgeSymopIds = createDataItemSelector(
      'cluster_edge', 'symop_id'
    )([], filterIntegerArray);
    const selectClusterEdgeCellTranslations = createDataItemSelector(
      'cluster_edge', 'cell_translation'
    )([], filterIntegerMatrixArray);
    const selectClusterEdgeSiteLabels1 = createDataItemSelector(
      'cluster_edge', 'atom_site_label_1'
    )([], filterStringArray);
    const selectClusterEdgeSymopIds1 = createDataItemSelector(
      'cluster_edge', 'symop_id_1'
    )([], filterIntegerArray);
    const selectClusterEdgeCellTranslations1 = createDataItemSelector(
      'cluster_edge', 'cell_translation_1'
    )([], filterIntegerMatrixArray);
    const selectClusterEdgeSiteLabels2 = createDataItemSelector(
      'cluster_edge', 'atom_site_label_2'
    )([], filterStringArray);
    const selectClusterEdgeSymopIds2 = createDataItemSelector(
      'cluster_edge', 'symop_id_2'
    )([], filterIntegerArray);
    const selectClusterEdgeCellTranslations2 = createDataItemSelector(
      'cluster_edge', 'cell_translation_2'
    )([], filterIntegerMatrixArray);
    const selectClusterFaceSiteLabels = createDataItemSelector(
      'cluster_face', 'atom_site_label'
    )([], filterStringArray);
    const selectClusterFaceSymopIds = createDataItemSelector(
      'cluster_face', 'symop_id'
    )([], filterIntegerArray);
    const selectClusterFaceCellTranslations = createDataItemSelector(
      'cluster_face', 'cell_translation'
    )([], filterIntegerMatrixArray);
    const selectClusterFaceSiteLabels1 = createDataItemSelector(
      'cluster_face', 'atom_site_label_1'
    )([], filterStringArray);
    const selectClusterFaceSymopIds1 = createDataItemSelector(
      'cluster_face', 'symop_id_1'
    )([], filterIntegerArray);
    const selectClusterFaceCellTranslations1 = createDataItemSelector(
      'cluster_face', 'cell_translation_1'
    )([], filterIntegerMatrixArray);
    const selectClusterFaceSiteLabels2 = createDataItemSelector(
      'cluster_face', 'atom_site_label_2'
    )([], filterStringArray);
    const selectClusterFaceSymopIds2 = createDataItemSelector(
      'cluster_face', 'symop_id_2'
    )([], filterIntegerArray);
    const selectClusterFaceCellTranslations2 = createDataItemSelector(
      'cluster_face', 'cell_translation_2'
    )([], filterIntegerMatrixArray);
    const selectClusterFaceSiteLabels3 = createDataItemSelector(
      'cluster_face', 'atom_site_label_3'
    )([], filterStringArray);
    const selectClusterFaceSymopIds3 = createDataItemSelector(
      'cluster_face', 'symop_id_3'
    )([], filterIntegerArray);
    const selectClusterFaceCellTranslations3 = createDataItemSelector(
      'cluster_face', 'cell_translation_3'
    )([], filterIntegerMatrixArray);
    const selectODLabels = createDataItemSelector(
      'occupation_domain', 'label'
    )([], filterUniqueStringArray);
    const selectODSiteLabels = createDataItemSelector(
      'occupation_domain', 'atom_site_label'
    )([], filterStringArray);
    const selectODAsymPolytopes = createDataItemSelector(
      'occupation_domain', 'polytope_asymmetric_unit'
    )([], filterArray);

    const selectOFractPlusDelta = createSelector(
      [() => this.deltaOFract, selectOFract],
      (deltaOFract, oFract) => {
        if (deltaOFract && oFract && deltaOFract.length === oFract.length) {
          return lnum.add(oFract, deltaOFract)
        }
        return oFract
      }
    );

    const updateEnvironmentUniform = createSelector(
      [],
      () => {
        const gl = this.gl;
        const arr =
          new DataView(new ArrayBuffer(ENVIRONMENT_UNIFORM_BUFFER_SIZE));
        const float32view = new Float32Array(arr.buffer);
        // ad hoc ...
        const directionalLightDir = [-0.3, -0.7, -0.5];
        const ambientLightColour = [0.5, 0.5, 0.5];
        // ... ad hoc
        float32view.set(directionalLightDir, 0);
        float32view.set(ambientLightColour, 4);
        updateBuffer(gl, gl.UNIFORM_BUFFER, this.ubo.environment, 0, arr);
        return this.requestId
      }
    );
    const updateHighlightUniform = createSelector(
      [
        () => this.rCutParCartn,
        () => this.baseRadius,
        () => this.odBaseOpacity,
        () => this.unhighlightColourFactor,
        () => this.unhighlightRadiusFactor,
        () => this.deltaOFractOffset,
        () => this.highlightRef,
        () => this.highlightMask
      ],
      (
        rCutParCartn,
        baseRadius,
        odBaseOpacity,
        unhighlightColourFactor,
        unhighlightRadiusFactor,
        deltaOFractOffset,
        highlightRef,
        highlightMask
      ) => {
        const gl = this.gl;
        const arr = new DataView(new ArrayBuffer(HIGHLIGHT_UNIFORM_BUFFER_SIZE));
        const float32View = new Float32Array(arr.buffer);
        const uint32View = new Uint32Array(arr.buffer);
        float32View.set([rCutParCartn, baseRadius, odBaseOpacity], 0);
        float32View.set(unhighlightColourFactor, 4);
        float32View.set(unhighlightRadiusFactor, 8);
        uint32View.set([
          ...genHighlightRefBit(highlightRef, deltaOFractOffset),
          ...genHighlightMaskBit(highlightMask)
        ], 12);
        updateBuffer(gl, gl.UNIFORM_BUFFER, this.ubo.highlight, 0, arr);
        if (this.subscribers.highlightRefString) {
          this.subscribers.highlightRefString({
            type: this.highlightRef.type,
            odLabel: this.highlightRef.odLabel || '.',
            ssgId: this.highlightRef.ssgId.toString(),
            lattFractCoord: this.highlightRef.lattFractCoord === null
              ? '.'
              : lnum.$(...this.highlightRef.lattFractCoord).toString()
          });
        }
        if (this.subscribers.highlightMask) {
          this.subscribers.highlightMask(this.highlightMask);
        }
        return this.requestId
      }
    );
    const updateCartnTransformUniform = createSelector(
      [
        selectAParCartn,
        selectAPerpCartn,
        selectOFractPlusDelta
      ],
      (aParCartn, aPerpCartn, oFract) => {
        if (!aParCartn || !aPerpCartn || !oFract) {
          return NOT_READY
        }
        const dim = oFract.length;
        const dimPar = aParCartn.getDim()[0];
        const dimPerp = aPerpCartn.getDim()[0];
        const arr = new Float32Array(56);
        const end1 = Math.min(dim, 3);
        const end2 = Math.min(dim, 6);
        for (let i = 0; i < dimPar; i += 1) {
          const ii = i * dim;
          arr.set(aParCartn.slice(ii, ii + end1), i * 4);
        }
        for (let i = 0; i < dimPar; i += 1) {
          const ii = i * dim;
          arr.set(aParCartn.slice(ii + end1, ii + end2), i * 4 + 12);
        }
        for (let i = 0; i < dimPerp; i += 1) {
          const ii = i * dim;
          arr.set(aPerpCartn.slice(ii, ii + end1), i * 4 + 24);
        }
        for (let i = 0; i < dimPerp; i += 1) {
          const ii = i * dim;
          arr.set(aPerpCartn.slice(ii + end1, ii + end2), i * 4 + 36);
        }
        arr.set(oFract.slice(0, end1), 48);
        arr.set(oFract.slice(end1, end2), 52);
        const gl = this.gl;
        updateBuffer(gl, gl.UNIFORM_BUFFER, this.ubo.cartnTransform, 0, arr);
        return this.requestId
      }
    );
    const updateSSGTexture = createSelector(
      [
        selectSSGIds,
        selectRPerpNoStrain,
        selectTPerpNoStrain
      ],
      (ssgIds, rPerp, tPerp) => {
        if (!ssgIds || !rPerp || !tPerp) {
          return NOT_READY
        }
        const order = rPerp.length;
        if (order === 0) {
          return NOT_READY
        }
        if (order > MAX_SSG_COUNT) {
          return NOT_READY
        }
        if (order * 3 > MAX_SSG_TEXTURE_WIDTH) {
          return NOT_READY
        }
        const width = MAX_SSG_TEXTURE_WIDTH;
        const offset = width * 4;
        const dimPerp = tPerp[0].length;
        const arr = new Float32Array(offset * 2);
        for (let i = 0; i < order; i += 1) {
          const is = ssgIds[i] - 1; // original to internal id
          const rot = [1, 0, 0, 0, 1, 0, 0, 0, 1].map((x, k) => {
            const i = Math.floor(k / 3);
            const j = k % 3;
            if (i < dimPerp && j < dimPerp) {
              return rPerp[is][i * dimPerp + j]
            } else {
              return x
            }
          });
          const trans = [0, 0, 0].map((x, i) => i < dimPerp ? tPerp[is][i] : x);
          arr[offset + is * 12] = rot[0];
          arr[offset + is * 12 + 1] = rot[1];
          arr[offset + is * 12 + 2] = rot[2];
          arr[offset + is * 12 + 3] = trans[0];
          arr[offset + is * 12 + 4] = rot[3];
          arr[offset + is * 12 + 5] = rot[4];
          arr[offset + is * 12 + 6] = rot[5];
          arr[offset + is * 12 + 7] = trans[1];
          arr[offset + is * 12 + 8] = rot[6];
          arr[offset + is * 12 + 9] = rot[7];
          arr[offset + is * 12 + 10] = rot[8];
          arr[offset + is * 12 + 11] = trans[2];
        }
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + SSG_TEXTURE_UNIT);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, 2, gl.RGBA, gl.FLOAT,
          arr);
        return this.requestId
      }
    );
    const updateODColourRadiusTexture = createSelector(
      [
        selectODLabels,
        selectODDispColours,
        selectODDispOpacities,
        selectODDispRadii
      ],
      (labels, colours, opacities, radii) => {
        if (!labels || !colours || !opacities || !radii) {
          return NOT_READY
        }
        const n = labels.length;
        if (
          colours.length !== n ||
          opacities.length !== n ||
          radii.length !== n ||
          n > MAX_OD_COUNT
        ) {
          return NOT_READY
        }
        const width = DATA_TEXTURE_WIDTH;
        const height = Math.ceil(2 * n / width);
        if (height === 0) {
          return NOT_READY
        }
        const arr = new Float32Array(width * height * 4);
        for (let i = 0; i < n; i += 1) {
          const colour = colours[i];
          const red = parseInt(colour.substring(1, 3), 16) / 255;
          const green = parseInt(colour.substring(3, 5), 16) / 255;
          const blue = parseInt(colour.substring(5, 7), 16) / 255;
          const opacity = opacities[i];
          const radius = radii[i];
          arr.set([red, green, blue, opacity, radius], i * 8);
        }
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + OD_COLOUR_RADIUS_TEXTURE_UNIT);
        if (height > this.odColourRadiusTextureHeight) {
          this.odColourRadiusTextureHeight = height;
          gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA16F, width, height);
        }
        gl.texSubImage2D(
          gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.FLOAT, arr
        );
        return this.requestId
      }
    );
    const updateAtomSites = createSelector(
      [
        selectAtomSiteLabels,
        selectModelSiteLabels,
        selectModelSiteSymopIds,
        selectModelSiteFractCoords
      ], (
        atomSiteLabels,
        modelSiteLabels,
        modelSiteSymopIds,
        modelSiteFractCoords
      ) => {
        if (
          !atomSiteLabels ||
          !modelSiteLabels ||
          !modelSiteSymopIds ||
          !modelSiteFractCoords
        ) {
          return NOT_READY
        }
        const gl = this.gl;
        // clean up
        for (const atomSite of this.atomSites) {
          for (const vao of atomSite.vaoGenODInstance) {
            if (vao) {
              gl.deleteVertexArray(vao);
            }
          }
          for (const vao of atomSite.vaoProj) {
            if (vao) {
              gl.deleteVertexArray(vao);
            }
          }
          for (const eqvPosVaoCut of atomSite.eqvPositionsVaoCut) {
            for (const vao of eqvPosVaoCut) {
              if (vao) {
                gl.deleteVertexArray(vao);
              }
            }
          }
        }
        const atomSites = this.atomSites = [];
        const eqvPosSSGIdData = [];
        const siteFractCoordData = [];
        for (let i = 0; i < atomSiteLabels.length; i += 1) {
          const siteLabel = atomSiteLabels[i];
          const modelSiteIds = modelSiteLabels
            .map((label, id) => [label, id])
            .filter(([label]) => label === siteLabel)
            .map(([, id]) => id);
          const numEqvPositions = modelSiteIds.length;
          const eqvPosSSGIds = modelSiteIds.map(id => modelSiteSymopIds[id]);
          const siteSymOrder = eqvPosSSGIds[0].length;
          const ssgIdStart = eqvPosSSGIdData.length;
          const eqvPosSSGIdsFlat = eqvPosSSGIds.flat();
          eqvPosSSGIdData.push(...eqvPosSSGIdsFlat);
          const mapSSGInternalIdToEqvPosId =
            Array.from(eqvPosSSGIdsFlat, () => 0);
          for (let j = 0; j < eqvPosSSGIds.length; j += 1) {
            for (const ssgId of eqvPosSSGIds[j]) {
              mapSSGInternalIdToEqvPosId[ssgId - 1] = j; // internal id
            }
          }
          const eqvPosFractCoords = modelSiteIds.map(
            id => modelSiteFractCoords[id]
          );
          const eqvPosFractCoordsEmbed = eqvPosFractCoords.map(
            fractCoord => [0, 0, 0, 0, 0, 0].map(
              (x, i) => i < fractCoord.length ? fractCoord[i] : x
            )
          );
          const siteFractCoordStart = siteFractCoordData.length;
          siteFractCoordData.push(...eqvPosFractCoordsEmbed);
          atomSites.push({
            label: siteLabel,
            eqvPosFractCoords: eqvPosFractCoords,
            mapSSGInternalIdToEqvPosId: mapSSGInternalIdToEqvPosId,
            siteSymOrder: siteSymOrder,
            ssgIdStart: ssgIdStart,
            numEqvPositions: numEqvPositions,
            fractCoordStart: siteFractCoordStart,
            lattFractCoordGenerator: null,
            lattFractCoordCache:
              Array.from({ length: numEqvPositions }, () => []),
            odFragsAsym: null,
            odFrags: null,
            rPerpCartnMax: 0,
            vaoGenODInstance: [],
            vaoProj: [],
            eqvPositionsVaoCut:
              Array.from({ length: numEqvPositions }, () => []),
            eqvPositionsDisplacementData: [],
            eqvPositionsBondData: [],
            eqvPositionsVertexData: [],
            eqvPositionsEdgeData: [],
            eqvPositionsFaceData: []
          });
        }
        if (eqvPosSSGIdData.legnth === 0 || siteFractCoordData.length === 0) {
          return NOT_READY
        }
        // vbo siteSSGId
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.siteSSGId);
          const size = eqvPosSSGIdData.length;
          if (this.vboSiteSSGIdSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboSiteSSGIdSize = size;
          }
          // conversion to internal id
          const arr = new Uint8Array(eqvPosSSGIdData.map(id => id - 1));
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // vbo siteFractCoord
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.siteFractCoord);
          const size = siteFractCoordData.length * 24;
          if (this.vboSiteFractCoordSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboSiteFractCoordSize = size;
          }
          const arr = new Float32Array(siteFractCoordData.flat());
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // vao proj
        for (const atomSite of atomSites) {
          const siteFractCoordStart = atomSite.fractCoordStart;
          for (let i = 0, n = atomSite.numEqvPositions; i < n; i += 1) {
            if (atomSite.vaoProj[i]) {
              gl.deleteVertexArray(atomSite.vaoProj[i]);
            }
            const vao = atomSite.vaoProj[i] = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.lattFractCoord);
            gl.enableVertexAttribArray(0);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribIPointer(0, 3, gl.BYTE, 6, 0);
            gl.vertexAttribIPointer(1, 3, gl.BYTE, 6, 3);
            const offset = (siteFractCoordStart + i) * 24;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.siteFractCoord);
            gl.enableVertexAttribArray(2);
            gl.enableVertexAttribArray(3);
            gl.vertexAttribDivisor(2, 1);
            gl.vertexAttribDivisor(3, 1);
            gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 24, offset);
            gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 24, offset + 12);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
          }
        }
        gl.bindVertexArray(null);
        return this.requestId
      }
    );
    const updateDisplacements = createSelector(
      [
        selectAsymBondSiteLabels1,
        selectAsymBondSymopIds1,
        selectAsymBondCellTranslations1,
        selectAsymBondSiteLabels2,
        selectAsymBondSymopIds2,
        selectAsymBondCellTranslations2,
        selectGeomBondSiteLabels1,
        selectGeomBondSymopIds1,
        selectGeomBondCellTranslations1,
        selectGeomBondSiteLabels2,
        selectGeomBondSymopIds2,
        selectGeomBondCellTranslations2,
        selectClusterVertexSiteLabels,
        selectClusterVertexSymopIds,
        selectClusterVertexCellTranslations,
        selectClusterVertexSiteLabels1,
        selectClusterVertexSymopIds1,
        selectClusterVertexCellTranslations1,
        selectClusterEdgeSiteLabels,
        selectClusterEdgeSymopIds,
        selectClusterEdgeCellTranslations,
        selectClusterEdgeSiteLabels1,
        selectClusterEdgeSymopIds1,
        selectClusterEdgeCellTranslations1,
        selectClusterEdgeSiteLabels2,
        selectClusterEdgeSymopIds2,
        selectClusterEdgeCellTranslations2,
        selectClusterFaceSiteLabels,
        selectClusterFaceSymopIds,
        selectClusterFaceCellTranslations,
        selectClusterFaceSiteLabels1,
        selectClusterFaceSymopIds1,
        selectClusterFaceCellTranslations1,
        selectClusterFaceSiteLabels2,
        selectClusterFaceSymopIds2,
        selectClusterFaceCellTranslations2,
        selectClusterFaceSiteLabels3,
        selectClusterFaceSymopIds3,
        selectClusterFaceCellTranslations3,
        selectSSGMultiplicity,
        selectSSGMultiplicationTableSymopIds,
        selectR,
        selectAParCartn,
        selectAPerpCartn,
        updateAtomSites
      ], (
        asymBondSiteLabels1,
        asymBondSymopIds1,
        asymBondCellTranslations1,
        asymBondSiteLabels2,
        asymBondSymopIds2,
        asymBondCellTranslations2,
        bondSiteLabels1,
        bondSymopIds1,
        bondCellTranslations1,
        bondSiteLabels2,
        bondSymopIds2,
        bondCellTranslations2,
        vertexSiteLabels,
        vertexSymopIds,
        vertexCellTranslations,
        vertexSiteLabels1,
        vertexSymopIds1,
        vertexCellTranslations1,
        edgeSiteLabels,
        edgeSymopIds,
        edgeCellTranslations,
        edgeSiteLabels1,
        edgeSymopIds1,
        edgeCellTranslations1,
        edgeSiteLabels2,
        edgeSymopIds2,
        edgeCellTranslations2,
        faceSiteLabels,
        faceSymopIds,
        faceCellTranslations,
        faceSiteLabels1,
        faceSymopIds1,
        faceCellTranslations1,
        faceSiteLabels2,
        faceSymopIds2,
        faceCellTranslations2,
        faceSiteLabels3,
        faceSymopIds3,
        faceCellTranslations3,
        ssgMult,
        ssgMultTableSymopIds,
        ssgR,
        aParCartn,
        aPerpCartn,
        ...updates
      ) => {
        if (
          !asymBondSiteLabels1 ||
          !asymBondSymopIds1 ||
          !asymBondCellTranslations1 ||
          !asymBondSiteLabels2 ||
          !asymBondSymopIds2 ||
          !asymBondCellTranslations2 ||
          !bondSiteLabels1 ||
          !bondSymopIds1 ||
          !bondCellTranslations1 ||
          !bondSiteLabels2 ||
          !bondSymopIds2 ||
          !bondCellTranslations2 ||
          !vertexSiteLabels ||
          !vertexSymopIds ||
          !vertexCellTranslations ||
          !vertexSiteLabels1 ||
          !vertexSymopIds1 ||
          !vertexCellTranslations1 ||
          !edgeSiteLabels ||
          !edgeSymopIds ||
          !edgeCellTranslations ||
          !edgeSiteLabels1 ||
          !edgeSymopIds1 ||
          !edgeCellTranslations1 ||
          !edgeSiteLabels2 ||
          !edgeSymopIds2 ||
          !edgeCellTranslations2 ||
          !faceSiteLabels ||
          !faceSymopIds ||
          !faceCellTranslations ||
          !faceSiteLabels1 ||
          !faceSymopIds1 ||
          !faceCellTranslations1 ||
          !faceSiteLabels2 ||
          !faceSymopIds2 ||
          !faceCellTranslations2 ||
          !faceSiteLabels3 ||
          !faceSymopIds3 ||
          !faceCellTranslations3 ||
          !ssgMult ||
          !ssgMultTableSymopIds ||
          !ssgR ||
          !aParCartn ||
          !aPerpCartn ||
          updates.some(x => x === NOT_READY)
        ) {
          return NOT_READY
        }
        const dim = aParCartn.getDim()[1];
        const displacementData = [];
        const asymBondDispIdData = [];
        const asymBondDispGlobalIdData = [];
        const bondDispIdData = [];
        const bondDispGlobalIdData = [];
        const vertexDispIdData = [];
        const vertexDispGlobalIdData = [];
        const edgeDispIdData = [];
        const edgeDispGlobalIdData = [];
        const faceDispIdData = [];
        const faceDispGlobalIdData = [];
        let maxEqvPosDispCount = 0;
        for (const [atomSiteId, atomSite] of this.atomSites.entries()) {
          const siteLabel = atomSite.label;
          const eqvPosFractCoords = atomSite.eqvPosFractCoords;
          const mapSSGInternalIdToEqvPosId = atomSite.mapSSGInternalIdToEqvPosId;
          const atomSiteDisplacements = eqvPosFractCoords.map(
            () => [lnum.$(...Array.from({ length: dim }, () => 0))]
          );
          const atomSiteDisplacementTargetAtomSiteIds = eqvPosFractCoords.map(
            () => [atomSiteId]
          );
          // prepare for asymmetric bonds
          const atomSiteAsymBonds = eqvPosFractCoords.map(x => []);
          {
            const bond1Ids = asymBondSiteLabels1
              .map((label, id) => [label, id])
              .filter(([label]) => label === siteLabel)
              .map(([, id]) => id);
            const bond2Ids = asymBondSiteLabels2
              .map((label, id) => [label, id])
              .filter(([label]) => label === siteLabel)
              .map(([, id]) => id);
            const targetAtomSiteLabels = [
              ...bond1Ids.map(id => asymBondSiteLabels2[id]),
              ...bond2Ids.map(id => asymBondSiteLabels1[id])
            ];
            const targetAtomSiteIds = targetAtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const internalSSGIds = [
              ...bond1Ids.map(id => asymBondSymopIds1[id] - 1),
              ...bond2Ids.map(id => asymBondSymopIds2[id] - 1)
            ];
            const targetInternalSSGIds = [
              ...bond1Ids.map(id => asymBondSymopIds2[id] - 1),
              ...bond2Ids.map(id => asymBondSymopIds1[id] - 1)
            ];
            const siteFractCoords = internalSSGIds.map(
              id => eqvPosFractCoords[mapSSGInternalIdToEqvPosId[id]]
            );
            const targetSiteFractCoords = targetInternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[targetAtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const relCellTranslations = [
              ...bond1Ids.map(id => lnum.sub(
                asymBondCellTranslations2[id],
                asymBondCellTranslations1[id]
              )),
              ...bond2Ids.map(id => lnum.sub(
                asymBondCellTranslations1[id],
                asymBondCellTranslations2[id]
              ))
            ];
            const displacementsAsym = relCellTranslations.map(
              (x, i) => lnum.add(x,
                lnum.sub(targetSiteFractCoords[i], siteFractCoords[i])
              )
            );
            for (let i = 0, n = targetAtomSiteLabels.length; i < n; i += 1) {
              const targetAtomSiteId = targetAtomSiteIds[i];
              const targetAtomSite = this.atomSites[targetAtomSiteId];
              const targetMapSSGInternalIdToEqvPosId =
                targetAtomSite.mapSSGInternalIdToEqvPosId;
              const ssgId = internalSSGIds[i];
              const targetSSGId = targetInternalSSGIds[i];
              const eqvPosId = mapSSGInternalIdToEqvPosId[ssgId];
              const targetEqvPosId =
                targetMapSSGInternalIdToEqvPosId[targetSSGId];
              const disp = displacementsAsym[i];
              let dispId;
              if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                if (lnum.eq(disp, x)) {
                  dispId = xId;
                  return false
                }
                return true
              })) {
                dispId = atomSiteDisplacements[eqvPosId].length;
                atomSiteDisplacements[eqvPosId].push(disp);
                atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                  .push(targetAtomSiteId);
              }
              const eqvPosBonds = atomSiteAsymBonds[eqvPosId];
              if (eqvPosBonds.every(
                (x, xId) =>
                  dispId !== x.displacementId ||
                  targetAtomSiteId !== x.targetAtomSiteId ||
                  targetEqvPosId !== x.targetEqvPosId
              )) {
                eqvPosBonds.push({
                  displacementId: dispId,
                  targetAtomSiteId,
                  targetEqvPosId
                });
              }
            }
          }
          // prepare for bonds
          const atomSiteBonds = eqvPosFractCoords.map(x => []);
          {
            const bond1Ids = bondSiteLabels1
              .map((label, id) => [label, id])
              .filter(([label]) => label === siteLabel)
              .map(([, id]) => id);
            const bond2Ids = bondSiteLabels2
              .map((label, id) => [label, id])
              .filter(([label]) => label === siteLabel)
              .map(([, id]) => id);
            const targetAtomSiteLabels = [
              ...bond1Ids.map(id => bondSiteLabels2[id]),
              ...bond2Ids.map(id => bondSiteLabels1[id])
            ];
            const targetAtomSiteIds = targetAtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const internalSSGIds = [
              ...bond1Ids.map(id => bondSymopIds1[id] - 1),
              ...bond2Ids.map(id => bondSymopIds2[id] - 1)
            ];
            const targetInternalSSGIds = [
              ...bond1Ids.map(id => bondSymopIds2[id] - 1),
              ...bond2Ids.map(id => bondSymopIds1[id] - 1)
            ];
            const siteFractCoords = internalSSGIds.map(
              id => eqvPosFractCoords[mapSSGInternalIdToEqvPosId[id]]
            );
            const targetSiteFractCoords = targetInternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[targetAtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const relCellTranslations = [
              ...bond1Ids.map(id =>
                lnum.sub(bondCellTranslations2[id], bondCellTranslations1[id])
              ),
              ...bond2Ids.map(id =>
                lnum.sub(bondCellTranslations1[id], bondCellTranslations2[id])
              )
            ];
            const displacementsAsym = relCellTranslations.map(
              (x, i) => lnum.add(x,
                lnum.sub(targetSiteFractCoords[i], siteFractCoords[i])
              )
            );
            for (let i = 0, n = targetAtomSiteLabels.length; i < n; i += 1) {
              const targetAtomSiteId = targetAtomSiteIds[i];
              const targetAtomSite = this.atomSites[targetAtomSiteId];
              const targetMapSSGInternalIdToEqvPosId =
                targetAtomSite.mapSSGInternalIdToEqvPosId;
              const displacementAsym = displacementsAsym[i];
              const ssgIdAsym = internalSSGIds[i];
              const targetSSGIdAsym = targetInternalSSGIds[i];
              for (const [id, g] of ssgR.entries()) {
                const ssgId = ssgMultTableSymopIds[ssgMult * id + ssgIdAsym] - 1;
                const targetSSGId =
                  ssgMultTableSymopIds[ssgMult * id + targetSSGIdAsym] - 1;
                const eqvPosId = mapSSGInternalIdToEqvPosId[ssgId];
                const targetEqvPosId =
                  targetMapSSGInternalIdToEqvPosId[targetSSGId];
                const disp = lnum.mmul(g, displacementAsym);
                let dispId;
                if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                  if (lnum.eq(disp, x)) {
                    dispId = xId;
                    return false
                  }
                  return true
                })) {
                  dispId = atomSiteDisplacements[eqvPosId].length;
                  atomSiteDisplacements[eqvPosId].push(disp);
                  atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                    .push(targetAtomSiteId);
                }
                const eqvPosBonds = atomSiteBonds[eqvPosId];
                if (eqvPosBonds.every(
                  (x, xId) =>
                    dispId !== x.displacementId ||
                    targetAtomSiteId !== x.targetAtomSiteId ||
                    targetEqvPosId !== x.targetEqvPosId
                )) {
                  eqvPosBonds.push({
                    displacementId: dispId,
                    targetAtomSiteId,
                    targetEqvPosId
                  });
                }
              }
            }
          }
          // prepare for vertices
          const atomSiteVertices = eqvPosFractCoords.map(x => []);
          {
            const vertexIds = vertexSiteLabels
              .map((label, id) => [label, id])
              .filter(([label]) => label === siteLabel)
              .map(([, id]) => id);
            const target1AtomSiteLabels =
              vertexIds.map(id => vertexSiteLabels1[id]);
            const target1AtomSiteIds = target1AtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const internalSSGIds = vertexIds.map(id => vertexSymopIds[id] - 1);
            const target1InternalSSGIds =
              vertexIds.map(id => vertexSymopIds1[id] - 1);
            const siteFractCoords = internalSSGIds.map(
              id => eqvPosFractCoords[mapSSGInternalIdToEqvPosId[id]]
            );
            const target1SiteFractCoords = target1InternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[target1AtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const relCellTranslations1 = vertexIds.map(id =>
              lnum.sub(vertexCellTranslations1[id], vertexCellTranslations[id])
            );
            const displacementsAsym1 = relCellTranslations1.map(
              (x, i) => lnum.add(x,
                lnum.sub(target1SiteFractCoords[i], siteFractCoords[i])
              )
            );
            for (let i = 0, n = vertexIds.length; i < n; i += 1) {
              const target1AtomSiteId = target1AtomSiteIds[i];
              const target1AtomSite = this.atomSites[target1AtomSiteId];
              const target1MapSSGInternalIdToEqvPosId =
                target1AtomSite.mapSSGInternalIdToEqvPosId;
              const displacementAsym1 = displacementsAsym1[i];
              const ssgIdAsym = internalSSGIds[i];
              const target1SSGIdAsym = target1InternalSSGIds[i];
              for (const [id, g] of ssgR.entries()) {
                const ssgId = ssgMultTableSymopIds[ssgMult * id + ssgIdAsym] - 1;
                const target1SSGId =
                  ssgMultTableSymopIds[ssgMult * id + target1SSGIdAsym] - 1;
                const eqvPosId = mapSSGInternalIdToEqvPosId[ssgId];
                const target1EqvPosId =
                  target1MapSSGInternalIdToEqvPosId[target1SSGId];
                const disp1 = lnum.mmul(g, displacementAsym1);
                let dispId1;
                if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                  if (lnum.eq(disp1, x)) {
                    dispId1 = xId;
                    return false
                  }
                  return true
                })) {
                  dispId1 = atomSiteDisplacements[eqvPosId].length;
                  atomSiteDisplacements[eqvPosId].push(disp1);
                  atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                    .push(target1AtomSiteId);
                }
                const eqvPosVertices = atomSiteVertices[eqvPosId];
                if (eqvPosVertices.every(
                  (x, xId) =>
                    dispId1 !== x.displacementId1 ||
                    target1AtomSiteId !== x.target1AtomSiteId ||
                    target1EqvPosId !== x.target1EqvPosId
                )) {
                  eqvPosVertices.push({
                    displacementId1: dispId1,
                    target1AtomSiteId,
                    target1EqvPosId
                  });
                }
              }
            }
          }
          // prepare for edges
          const atomSiteEdges = eqvPosFractCoords.map(x => []);
          {
            const edgeIds = edgeSiteLabels
              .map((label, id) => [label, id])
              .filter(([label]) => label === siteLabel)
              .map(([, id]) => id);
            const target1AtomSiteLabels = edgeIds.map(id => edgeSiteLabels1[id]);
            const target2AtomSiteLabels = edgeIds.map(id => edgeSiteLabels2[id]);
            const target1AtomSiteIds = target1AtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const target2AtomSiteIds = target2AtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const internalSSGIds = edgeIds.map(id => edgeSymopIds[id] - 1);
            const target1InternalSSGIds =
              edgeIds.map(id => edgeSymopIds1[id] - 1);
            const target2InternalSSGIds =
              edgeIds.map(id => edgeSymopIds2[id] - 1);
            const siteFractCoords = internalSSGIds.map(
              id => eqvPosFractCoords[mapSSGInternalIdToEqvPosId[id]]
            );
            const target1SiteFractCoords = target1InternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[target1AtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const target2SiteFractCoords = target2InternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[target2AtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const relCellTranslations1 = edgeIds.map(id =>
              lnum.sub(edgeCellTranslations1[id], edgeCellTranslations[id])
            );
            const relCellTranslations2 = edgeIds.map(id =>
              lnum.sub(edgeCellTranslations2[id], edgeCellTranslations[id])
            );
            const displacementsAsym1 = relCellTranslations1.map(
              (x, i) => lnum.add(x,
                lnum.sub(target1SiteFractCoords[i], siteFractCoords[i])
              )
            );
            const displacementsAsym2 = relCellTranslations2.map(
              (x, i) => lnum.add(x,
                lnum.sub(target2SiteFractCoords[i], siteFractCoords[i])
              )
            );
            for (let i = 0, n = edgeIds.length; i < n; i += 1) {
              const target1AtomSiteId = target1AtomSiteIds[i];
              const target2AtomSiteId = target2AtomSiteIds[i];
              const target1AtomSite = this.atomSites[target1AtomSiteId];
              const target2AtomSite = this.atomSites[target2AtomSiteId];
              const target1MapSSGInternalIdToEqvPosId =
                target1AtomSite.mapSSGInternalIdToEqvPosId;
              const target2MapSSGInternalIdToEqvPosId =
                target2AtomSite.mapSSGInternalIdToEqvPosId;
              const displacementAsym1 = displacementsAsym1[i];
              const displacementAsym2 = displacementsAsym2[i];
              const ssgIdAsym = internalSSGIds[i];
              const target1SSGIdAsym = target1InternalSSGIds[i];
              const target2SSGIdAsym = target2InternalSSGIds[i];
              for (const [id, g] of ssgR.entries()) {
                const ssgId = ssgMultTableSymopIds[ssgMult * id + ssgIdAsym] - 1;
                const target1SSGId =
                  ssgMultTableSymopIds[ssgMult * id + target1SSGIdAsym] - 1;
                const target2SSGId =
                  ssgMultTableSymopIds[ssgMult * id + target2SSGIdAsym] - 1;
                const eqvPosId = mapSSGInternalIdToEqvPosId[ssgId];
                const target1EqvPosId =
                  target1MapSSGInternalIdToEqvPosId[target1SSGId];
                const target2EqvPosId =
                  target2MapSSGInternalIdToEqvPosId[target2SSGId];
                const disp1 = lnum.mmul(g, displacementAsym1);
                const disp2 = lnum.mmul(g, displacementAsym2);
                let dispId1;
                if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                  if (lnum.eq(disp1, x)) {
                    dispId1 = xId;
                    return false
                  }
                  return true
                })) {
                  dispId1 = atomSiteDisplacements[eqvPosId].length;
                  atomSiteDisplacements[eqvPosId].push(disp1);
                  atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                    .push(target1AtomSiteId);
                }
                let dispId2;
                if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                  if (lnum.eq(disp2, x)) {
                    dispId2 = xId;
                    return false
                  }
                  return true
                })) {
                  dispId2 = atomSiteDisplacements[eqvPosId].length;
                  atomSiteDisplacements[eqvPosId].push(disp2);
                  atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                    .push(target2AtomSiteId);
                }

                const eqvPosEdges = atomSiteEdges[eqvPosId];
                if (eqvPosEdges.every(
                  (x, xId) => (
                    dispId1 !== x.displacementId1 ||
                    target1AtomSiteId !== x.target1AtomSiteId ||
                    target1EqvPosId !== x.target1EqvPosId ||
                    dispId2 !== x.displacementId2 ||
                    target2AtomSiteId !== x.target2AtomSiteId ||
                    target2EqvPosId !== x.target2EqvPosId
                  ) && (
                    dispId2 !== x.displacementId1 ||
                    target2AtomSiteId !== x.target1AtomSiteId ||
                    target2EqvPosId !== x.target1EqvPosId ||
                    dispId1 !== x.displacementId2 ||
                    target1AtomSiteId !== x.target2AtomSiteId ||
                    target1EqvPosId !== x.target2EqvPosId
                  )
                )) {
                  eqvPosEdges.push({
                    displacementId1: dispId1,
                    displacementId2: dispId2,
                    target1AtomSiteId,
                    target2AtomSiteId,
                    target1EqvPosId,
                    target2EqvPosId
                  });
                }
              }
            }
          }
          // prepare for faces
          const atomSiteFaces = eqvPosFractCoords.map(x => []);
          {
            const faceIds = faceSiteLabels
              .map((label, id) => [label, id])
              .filter(([label]) => label === siteLabel)
              .map(([, id]) => id);
            const target1AtomSiteLabels = faceIds.map(id => faceSiteLabels1[id]);
            const target2AtomSiteLabels = faceIds.map(id => faceSiteLabels2[id]);
            const target3AtomSiteLabels = faceIds.map(id => faceSiteLabels3[id]);
            const target1AtomSiteIds = target1AtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const target2AtomSiteIds = target2AtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const target3AtomSiteIds = target3AtomSiteLabels.map(
              label => this.atomSites
                .map((x, id) => [x.label, id])
                .filter(([xLabel]) => xLabel === label)
                .map(([, id]) => id)[0]
            );
            const internalSSGIds = faceIds.map(id => faceSymopIds[id] - 1);
            const target1InternalSSGIds =
              faceIds.map(id => faceSymopIds1[id] - 1);
            const target2InternalSSGIds =
              faceIds.map(id => faceSymopIds2[id] - 1);
            const target3InternalSSGIds =
              faceIds.map(id => faceSymopIds3[id] - 1);
            const siteFractCoords = internalSSGIds.map(
              id => eqvPosFractCoords[mapSSGInternalIdToEqvPosId[id]]
            );
            const target1SiteFractCoords = target1InternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[target1AtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const target2SiteFractCoords = target2InternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[target2AtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const target3SiteFractCoords = target3InternalSSGIds.map(
              (id, i) => {
                const targetAtomSite = this.atomSites[target3AtomSiteIds[i]];
                const targetMapSSGInternalIdToEqvPosId =
                  targetAtomSite.mapSSGInternalIdToEqvPosId;
                const targetEqvPosFractCoords = targetAtomSite.eqvPosFractCoords;
                return targetEqvPosFractCoords[
                  targetMapSSGInternalIdToEqvPosId[id]
                ]
              }
            );
            const relCellTranslations1 = faceIds.map(id =>
              lnum.sub(faceCellTranslations1[id], faceCellTranslations[id])
            );
            const relCellTranslations2 = faceIds.map(id =>
              lnum.sub(faceCellTranslations2[id], faceCellTranslations[id])
            );
            const relCellTranslations3 = faceIds.map(id =>
              lnum.sub(faceCellTranslations3[id], faceCellTranslations[id])
            );
            const displacementsAsym1 = relCellTranslations1.map(
              (x, i) => lnum.add(x,
                lnum.sub(target1SiteFractCoords[i], siteFractCoords[i])
              )
            );
            const displacementsAsym2 = relCellTranslations2.map(
              (x, i) => lnum.add(x,
                lnum.sub(target2SiteFractCoords[i], siteFractCoords[i])
              )
            );
            const displacementsAsym3 = relCellTranslations3.map(
              (x, i) => lnum.add(x,
                lnum.sub(target3SiteFractCoords[i], siteFractCoords[i])
              )
            );
            for (let i = 0, n = faceIds.length; i < n; i += 1) {
              const target1AtomSiteId = target1AtomSiteIds[i];
              const target2AtomSiteId = target2AtomSiteIds[i];
              const target3AtomSiteId = target3AtomSiteIds[i];
              const target1AtomSite = this.atomSites[target1AtomSiteId];
              const target2AtomSite = this.atomSites[target2AtomSiteId];
              const target3AtomSite = this.atomSites[target3AtomSiteId];
              const target1MapSSGInternalIdToEqvPosId =
                target1AtomSite.mapSSGInternalIdToEqvPosId;
              const target2MapSSGInternalIdToEqvPosId =
                target2AtomSite.mapSSGInternalIdToEqvPosId;
              const target3MapSSGInternalIdToEqvPosId =
                target3AtomSite.mapSSGInternalIdToEqvPosId;
              const displacementAsym1 = displacementsAsym1[i];
              const displacementAsym2 = displacementsAsym2[i];
              const displacementAsym3 = displacementsAsym3[i];
              const ssgIdAsym = internalSSGIds[i];
              const target1SSGIdAsym = target1InternalSSGIds[i];
              const target2SSGIdAsym = target2InternalSSGIds[i];
              const target3SSGIdAsym = target3InternalSSGIds[i];
              for (const [id, g] of ssgR.entries()) {
                const ssgId = ssgMultTableSymopIds[ssgMult * id + ssgIdAsym] - 1;
                const target1SSGId =
                  ssgMultTableSymopIds[ssgMult * id + target1SSGIdAsym] - 1;
                const target2SSGId =
                  ssgMultTableSymopIds[ssgMult * id + target2SSGIdAsym] - 1;
                const target3SSGId =
                  ssgMultTableSymopIds[ssgMult * id + target3SSGIdAsym] - 1;
                const eqvPosId = mapSSGInternalIdToEqvPosId[ssgId];
                const target1EqvPosId =
                  target1MapSSGInternalIdToEqvPosId[target1SSGId];
                const target2EqvPosId =
                  target2MapSSGInternalIdToEqvPosId[target2SSGId];
                const target3EqvPosId =
                  target3MapSSGInternalIdToEqvPosId[target3SSGId];
                const disp1 = lnum.mmul(g, displacementAsym1);
                const disp2 = lnum.mmul(g, displacementAsym2);
                const disp3 = lnum.mmul(g, displacementAsym3);
                let dispId1;
                if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                  if (lnum.eq(disp1, x)) {
                    dispId1 = xId;
                    return false
                  }
                  return true
                })) {
                  dispId1 = atomSiteDisplacements[eqvPosId].length;
                  atomSiteDisplacements[eqvPosId].push(disp1);
                  atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                    .push(target1AtomSiteId);
                }
                let dispId2;
                if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                  if (lnum.eq(disp2, x)) {
                    dispId2 = xId;
                    return false
                  }
                  return true
                })) {
                  dispId2 = atomSiteDisplacements[eqvPosId].length;
                  atomSiteDisplacements[eqvPosId].push(disp2);
                  atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                    .push(target2AtomSiteId);
                }
                let dispId3;
                if (atomSiteDisplacements[eqvPosId].every((x, xId) => {
                  if (lnum.eq(disp3, x)) {
                    dispId3 = xId;
                    return false
                  }
                  return true
                })) {
                  dispId3 = atomSiteDisplacements[eqvPosId].length;
                  atomSiteDisplacements[eqvPosId].push(disp3);
                  atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
                    .push(target3AtomSiteId);
                }
                const eqvPosFaces = atomSiteFaces[eqvPosId];
                if (eqvPosFaces.every(
                  (x, xId) => (
                    dispId1 !== x.displacementId1 ||
                    target1AtomSiteId !== x.target1AtomSiteId ||
                    target1EqvPosId !== x.target1EqvPosId ||
                    dispId2 !== x.displacementId2 ||
                    target2AtomSiteId !== x.target2AtomSiteId ||
                    target2EqvPosId !== x.target2EqvPosId ||
                    dispId3 !== x.displacementId3 ||
                    target3AtomSiteId !== x.target3AtomSiteId ||
                    target3EqvPosId !== x.target3EqvPosId
                  ) && (
                    dispId2 !== x.displacementId1 ||
                    target2AtomSiteId !== x.target1AtomSiteId ||
                    target2EqvPosId !== x.target1EqvPosId ||
                    dispId3 !== x.displacementId2 ||
                    target3AtomSiteId !== x.target2AtomSiteId ||
                    target3EqvPosId !== x.target2EqvPosId ||
                    dispId1 !== x.displacementId3 ||
                    target1AtomSiteId !== x.target3AtomSiteId ||
                    target1EqvPosId !== x.target3EqvPosId
                  ) && (
                    dispId3 !== x.displacementId1 ||
                    target3AtomSiteId !== x.target1AtomSiteId ||
                    target3EqvPosId !== x.target1EqvPosId ||
                    dispId1 !== x.displacementId2 ||
                    target1AtomSiteId !== x.target2AtomSiteId ||
                    target1EqvPosId !== x.target2EqvPosId ||
                    dispId2 !== x.displacementId3 ||
                    target2AtomSiteId !== x.target3AtomSiteId ||
                    target2EqvPosId !== x.target3EqvPosId
                  ) && (
                    dispId1 !== x.displacementId1 ||
                    target1AtomSiteId !== x.target1AtomSiteId ||
                    target1EqvPosId !== x.target1EqvPosId ||
                    dispId3 !== x.displacementId2 ||
                    target3AtomSiteId !== x.target2AtomSiteId ||
                    target3EqvPosId !== x.target2EqvPosId ||
                    dispId2 !== x.displacementId3 ||
                    target2AtomSiteId !== x.target3AtomSiteId ||
                    target2EqvPosId !== x.target3EqvPosId
                  ) && (
                    dispId2 !== x.displacementId1 ||
                    target2AtomSiteId !== x.target1AtomSiteId ||
                    target2EqvPosId !== x.target1EqvPosId ||
                    dispId1 !== x.displacementId2 ||
                    target1AtomSiteId !== x.target2AtomSiteId ||
                    target1EqvPosId !== x.target2EqvPosId ||
                    dispId3 !== x.displacementId3 ||
                    target3AtomSiteId !== x.target3AtomSiteId ||
                    target3EqvPosId !== x.target3EqvPosId
                  ) && (
                    dispId3 !== x.displacementId1 ||
                    target3AtomSiteId !== x.target1AtomSiteId ||
                    target3EqvPosId !== x.target1EqvPosId ||
                    dispId2 !== x.displacementId2 ||
                    target2AtomSiteId !== x.target2AtomSiteId ||
                    target2EqvPosId !== x.target2EqvPosId ||
                    dispId1 !== x.displacementId3 ||
                    target1AtomSiteId !== x.target3AtomSiteId ||
                    target1EqvPosId !== x.target3EqvPosId
                  )
                )) {
                  eqvPosFaces.push({
                    displacementId1: dispId1,
                    displacementId2: dispId2,
                    displacementId3: dispId3,
                    target1AtomSiteId,
                    target2AtomSiteId,
                    target3AtomSiteId,
                    target1EqvPosId,
                    target2EqvPosId,
                    target3EqvPosId
                  });
                }
              }
            }
          }
          const eqvPositionsDisplacementData = [];
          for (
            const [eqvPosId, eqvPosDisplacements]
            of atomSiteDisplacements.entries()
          ) {
            eqvPositionsDisplacementData.push({
              start: displacementData.length,
              targetAtomSiteIds:
                atomSiteDisplacementTargetAtomSiteIds[eqvPosId]
            });
            displacementData.push(...eqvPosDisplacements);
            maxEqvPosDispCount =
              Math.max(maxEqvPosDispCount, eqvPosDisplacements.length);
          }
          const eqvPositionsAsymBondData = [];
          for (const [eqvPosId, eqvPosBonds] of atomSiteAsymBonds.entries()) {
            const offset = eqvPositionsDisplacementData[eqvPosId].start;
            eqvPositionsAsymBondData.push({
              start: asymBondDispIdData.length,
              end: asymBondDispIdData.length + eqvPosBonds.length,
              dispIdOffset: offset,
              eqvPosBonds
            });
            asymBondDispIdData.push(...eqvPosBonds.map(
              x => [x.displacementId]
            ));
            asymBondDispGlobalIdData.push(...eqvPosBonds.map(
              x => [x.displacementId + offset]
            ));
          }
          const eqvPositionsBondData = [];
          for (const [eqvPosId, eqvPosBonds] of atomSiteBonds.entries()) {
            const offset = eqvPositionsDisplacementData[eqvPosId].start;
            eqvPositionsBondData.push({
              start: bondDispIdData.length,
              end: bondDispIdData.length + eqvPosBonds.length,
              dispIdOffset: offset,
              eqvPosBonds
            });
            bondDispIdData.push(...eqvPosBonds.map(
              x => [x.displacementId]
            ));
            bondDispGlobalIdData.push(...eqvPosBonds.map(
              x => [x.displacementId + offset]
            ));
          }
          const eqvPositionsVertexData = [];
          for (const [eqvPosId, eqvPosVertices] of atomSiteVertices.entries()) {
            eqvPositionsVertexData.push({
              start: vertexDispIdData.length,
              end: vertexDispIdData.length + eqvPosVertices.length
            });
            vertexDispIdData.push(...eqvPosVertices.map(
              x => [x.displacementId1]
            ));
            const offset = eqvPositionsDisplacementData[eqvPosId].start;
            vertexDispGlobalIdData.push(...eqvPosVertices.map(
              x => [x.displacementId1 + offset]
            ));
          }
          const eqvPositionsEdgeData = [];
          for (const [eqvPosId, eqvPosEdges] of atomSiteEdges.entries()) {
            eqvPositionsEdgeData.push({
              start: edgeDispIdData.length,
              end: edgeDispIdData.length + eqvPosEdges.length
            });
            edgeDispIdData.push(...eqvPosEdges.map(
              x => [x.displacementId1, x.displacementId2]
            ));
            const offset = eqvPositionsDisplacementData[eqvPosId].start;
            edgeDispGlobalIdData.push(...eqvPosEdges.map(
              x => [x.displacementId1 + offset, x.displacementId2 + offset]
            ));
          }
          const eqvPositionsFaceData = [];
          for (const [eqvPosId, eqvPosFaces] of atomSiteFaces.entries()) {
            eqvPositionsFaceData.push({
              start: faceDispIdData.length,
              end: faceDispIdData.length + eqvPosFaces.length
            });
            faceDispIdData.push(...eqvPosFaces.map(
              x => [x.displacementId1, x.displacementId2, x.displacementId3]
            ));
            const offset = eqvPositionsDisplacementData[eqvPosId].start;
            faceDispGlobalIdData.push(...eqvPosFaces.map(
              x => [
                x.displacementId1 + offset,
                x.displacementId2 + offset,
                x.displacementId3 + offset
              ]
            ));
          }
          atomSite.eqvPositionsDisplacementData = eqvPositionsDisplacementData;
          atomSite.eqvPositionsAsymBondData = eqvPositionsAsymBondData;
          atomSite.eqvPositionsBondData = eqvPositionsBondData;
          atomSite.eqvPositionsVertexData = eqvPositionsVertexData;
          atomSite.eqvPositionsEdgeData = eqvPositionsEdgeData;
          atomSite.eqvPositionsFaceData = eqvPositionsFaceData;
        }
        if (maxEqvPosDispCount > 255) {
          return NOT_READY
        }
        const gl = this.gl;
        // tex cut
        {
          const width = CUT_TEXTURE_WIDTH;
          const depth = maxEqvPosDispCount;
          if (this.texCutDepth < depth) {
            gl.deleteTexture(this.tex.cut);
            const texCut = this.tex.cut = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0 + CUT_TEXTURE_UNIT);
            gl.bindTexture(gl.TEXTURE_2D_ARRAY, texCut);
            gl.texParameteri(
              gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST
            );
            gl.texParameteri(
              gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST
            );
            gl.texStorage3D(
              gl.TEXTURE_2D_ARRAY, 1, gl.R32UI, width, width, depth
            );
            this.texCutDepth = depth;
          }
        }
        // vbo displacement
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.displacement);
          const size = displacementData.length *
            3 * // max perpendicular-space dimension
            4; // bytes per element
          if (this.vboDisplacementSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboDisplacementSize = size;
          }
          const arr = new Float32Array(size / 4);
          const baseOffset = 3;
          for (const [i, disp] of displacementData.entries()) {
            const offset = i * baseOffset;
            arr.set(lnum.ineg(lnum.mmul(aPerpCartn, disp)), offset);
          }
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // vbo asym bond displacement
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.asymBondDisplacement);
          const size = asymBondDispIdData.length *
            7 * // 1 times (max superspace dimension + id)
            4; // bytes per element
          if (this.vboAsymBondDisplacementSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboAsymBondDisplacementSize = size;
          }
          const arr = new DataView(new ArrayBuffer(size));
          const ui8 = new Uint8Array(arr.buffer);
          const f32 = new Float32Array(arr.buffer);
          for (const [i, [id1]] of asymBondDispIdData.entries()) {
            const disp1 = displacementData[asymBondDispGlobalIdData[i][0]];
            ui8.set([id1], i * 28);
            f32.set(lnum.mmul(aParCartn, disp1), i * 7 + 1);
            f32.set(lnum.ineg(lnum.mmul(aPerpCartn, disp1)), i * 7 + 4);
          }
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // vbo bond displacement
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.bondDisplacement);
          const size = bondDispIdData.length *
            7 * // 1 times (max superspace dimension + id)
            4; // bytes per element
          if (this.vboBondDisplacementSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboBondDisplacementSize = size;
          }
          const arr = new DataView(new ArrayBuffer(size));
          const ui8 = new Uint8Array(arr.buffer);
          const f32 = new Float32Array(arr.buffer);
          for (const [i, [id1]] of bondDispIdData.entries()) {
            const disp1 = displacementData[bondDispGlobalIdData[i][0]];
            ui8.set([id1], i * 28);
            f32.set(lnum.mmul(aParCartn, disp1), i * 7 + 1);
            f32.set(lnum.ineg(lnum.mmul(aPerpCartn, disp1)), i * 7 + 4);
          }
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // vbo vertex displacement
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.vertexDisplacement);
          const size = vertexDispIdData.length *
            4 * // 1 times (max parallel-space dimension + id)
            4; // bytes per element
          if (this.vboVertexDisplacementSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboVertexDisplacementSize = size;
          }
          const arr = new DataView(new ArrayBuffer(size));
          const ui8 = new Uint8Array(arr.buffer);
          const f32 = new Float32Array(arr.buffer);
          for (const [i, [id1]] of vertexDispIdData.entries()) {
            const disp1 = displacementData[vertexDispGlobalIdData[i][0]];
            ui8.set([id1], i * 16);
            f32.set(lnum.mmul(aParCartn, disp1), i * 4 + 1);
          }
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // vbo edge displacement
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.edgeDisplacement);
          const size = edgeDispIdData.length *
            8 * // 2 times (max parallel-space dimension + id)
            4; // bytes per element
          if (this.vboEdgeDisplacementSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboEdgeDisplacementSize = size;
          }
          const arr = new DataView(new ArrayBuffer(size));
          const ui8 = new Uint8Array(arr.buffer);
          const f32 = new Float32Array(arr.buffer);
          for (const [i, [id1, id2]] of edgeDispIdData.entries()) {
            const disp1 = displacementData[edgeDispGlobalIdData[i][0]];
            const disp2 = displacementData[edgeDispGlobalIdData[i][1]];
            ui8.set([id1], i * 32);
            f32.set(lnum.mmul(aParCartn, disp1), i * 8 + 1);
            ui8.set([id2], i * 32 + 16);
            f32.set(lnum.mmul(aParCartn, disp2), i * 8 + 5);
          }
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // vbo face displacement
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.faceDisplacement);
          const size = faceDispIdData.length *
            12 * // 3 times (max parallel-space dimension + id)
            4; // byte per element
          if (this.vboFaceDisplacementSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboFaceDisplacementSize = size;
          }
          const arr = new DataView(new ArrayBuffer(size));
          const ui8 = new Uint8Array(arr.buffer);
          const f32 = new Float32Array(arr.buffer);
          for (const [i, [id1, id2, id3]] of faceDispIdData.entries()) {
            const disp1 = displacementData[faceDispGlobalIdData[i][0]];
            const disp2 = displacementData[faceDispGlobalIdData[i][1]];
            const disp3 = displacementData[faceDispGlobalIdData[i][2]];
            ui8.set([id1], i * 48);
            f32.set(lnum.mmul(aParCartn, disp1), i * 12 + 1);
            ui8.set([id2], i * 48 + 16);
            f32.set(lnum.mmul(aParCartn, disp2), i * 12 + 5);
            ui8.set([id3], i * 48 + 32);
            f32.set(lnum.mmul(aParCartn, disp3), i * 12 + 9);
          }
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, arr);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        return this.requestId
      }
    );
    const updateODData = createSelector(
      [
        selectDimPerp,
        selectODSiteLabels,
        selectODAsymPolytopes,
        updateAtomSites
      ], (
        dimPerp,
        odSiteLabels,
        odAsymPolytopes,
        ...updates
      ) => {
        if (
          dimPerp === false ||
          !odSiteLabels ||
          !odAsymPolytopes ||
          updates.some(x => x === NOT_READY)
        ) {
          return NOT_READY
        }
        if (odSiteLabels.length > MAX_OD_COUNT) {
          return NOT_READY
        }
        const gl = this.gl;
        const mapODIdToAtomSiteId = this.mapODIdToAtomSiteId =
          Array.from(odSiteLabels, () => -1);
        const atomSites = this.atomSites;
        const odFragsAsym = [];
        let odFragCount = 0;
        let odFragCountSiteMax = 0;
        for (let i = 0; i < atomSites.length; i += 1) {
          const atomSite = atomSites[i];
          const siteLabel = atomSite.label;
          const siteSymOrder = atomSite.siteSymOrder;
          const numEqvPositions = atomSite.numEqvPositions;
          const odIds = odSiteLabels
            .map((label, id) => [label, id])
            .filter(([label]) => label === siteLabel)
            .map(([, id]) => id);
          for (const id of odIds) {
            mapODIdToAtomSiteId[id] = i;
          }
          const odFragsAsymStart = odFragsAsym.length;
          const polytopes = odIds.map(id => [id, odAsymPolytopes[id]]);
          let rPerpCartnMax = 0;
          for (const [id, polytope] of polytopes) {
            const simplexes = polytope.genSimplexes();
            for (const simplex of simplexes) {
              for (const v of simplex) {
                rPerpCartnMax = Math.max(rPerpCartnMax, lnum.abs(v));
              }
              odFragsAsym.push({ id, simplex });
            }
          }
          const odFragsAsymEnd = odFragsAsym.length;
          const odFragsSiteAsym = {
            start: odFragsAsymStart,
            end: odFragsAsymEnd,
            num: odFragsAsymEnd - odFragsAsymStart
          };
          const odFragsStart = odFragCount;
          const odFragCountSite = odFragsSiteAsym.num * siteSymOrder *
            numEqvPositions;
          odFragCount += odFragCountSite;
          odFragCountSiteMax = Math.max(odFragCountSiteMax, odFragCountSite);
          const odFragsSite = {
            start: odFragsStart,
            end: odFragCount,
            num: odFragCount - odFragsStart
          };
          // store
          atomSite.odFragsAsym = odFragsSiteAsym;
          atomSite.odFrags = odFragsSite;
          atomSite.rPerpCartnMax = rPerpCartnMax;
        }
        if (odFragsAsym.length === 0) {
          return NOT_READY
        }
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odFragAsym);
          const size =
            odFragsAsym.length * VBO_ODFRAG_ASYM_STRIDE[dimPerp];
          if (this.vboODFragAsymSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);
            this.vboODFragAsymSize = size;
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odFrag);
          const size = odFragCount * VBO_ODFRAG_STRIDE[dimPerp];
          if (this.vboODFragSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_COPY);
            this.vboODFragSize = size;
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odInstance);
          const size =
            odFragCountSiteMax * NUM_ODFRAG_VIDS[dimPerp] * 11 * 4;
          if (this.vboODInstanceSize < size) {
            gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_COPY);
            this.vboODInstanceSize = size;
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        // prepare OD fragments
        {
          const stride = VBO_ODFRAG_ASYM_STRIDE[dimPerp];
          const arr = new DataView(
            new ArrayBuffer(odFragsAsym.length * stride)
          );
          const view1 = new Uint16Array(arr.buffer);
          const view2 = dimPerp > 0 ? new Float32Array(arr.buffer, 4) : null;
          switch (dimPerp) {
            case 0: {
              view1.set(odFragsAsym.map(odFrag => odFrag.id), 0);
              break
            }
            case 1: {
              for (let i = 0, n = odFragsAsym.length; i < n; i += 1) {
                const odFrag = odFragsAsym[i];
                view1.set([odFrag.id], i * 6);
                view2.set(odFrag.simplex[0], i * 3);
                view2.set(odFrag.simplex[1], i * 3 + 1);
              }
              break
            }
            case 2: {
              for (let i = 0, n = odFragsAsym.length; i < n; i += 1) {
                const odFrag = odFragsAsym[i];
                view1.set([odFrag.id], i * 14);
                view2.set(odFrag.simplex[0], i * 7);
                view2.set(odFrag.simplex[1], i * 7 + 2);
                view2.set(odFrag.simplex[2], i * 7 + 4);
              }
              break
            }
            case 3: {
              for (let i = 0, n = odFragsAsym.length; i < n; i += 1) {
                const odFrag = odFragsAsym[i];
                view1.set([odFrag.id], i * 26);
                view2.set(odFrag.simplex[0], i * 13);
                view2.set(odFrag.simplex[1], i * 13 + 3);
                view2.set(odFrag.simplex[2], i * 13 + 6);
                view2.set(odFrag.simplex[3], i * 13 + 9);
              }
              break
            }
            default: {
              throw Error(`Debug info: unsupported dimPerp: ${dimPerp}`)
            }
          }
          updateBuffer(gl, gl.ARRAY_BUFFER, this.vbo.odFragAsym, 0, arr);
          const vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          gl.useProgram(this.prg.prepODFrags[dimPerp]);
          gl.enable(gl.RASTERIZER_DISCARD);
          gl.bindBufferBase(
            gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.odFrag
          );
          gl.beginTransformFeedback(gl.POINTS);
          for (const atomSite of atomSites) {
            const siteSymOrder = atomSite.siteSymOrder;
            const odFragsAsymStart = atomSite.odFragsAsym.start;
            const numODFragsAsym = atomSite.odFragsAsym.num;
            if (numODFragsAsym > 0) {
              for (let i = 0, n = atomSite.numEqvPositions; i < n; i += 1) {
                const siteSSGIdStart = atomSite.ssgIdStart + i * siteSymOrder;
                const baseOffset = stride * odFragsAsymStart;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odFragAsym);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribIPointer(
                  0, 1, gl.UNSIGNED_SHORT, stride, baseOffset
                );
                if (dimPerp > 0) {
                  for (let j = 0; j <= dimPerp; j += 1) {
                    const index = j + 1;
                    const offset = baseOffset + (1 + j * dimPerp) * 4;
                    gl.enableVertexAttribArray(index);
                    gl.vertexAttribPointer(
                      index, dimPerp, gl.FLOAT, false, stride, offset
                    );
                  }
                }
                {
                  const index = dimPerp === 0 ? 1 : dimPerp + 2;
                  gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.siteSSGId);
                  gl.enableVertexAttribArray(index);
                  gl.vertexAttribDivisor(index, 1);
                  gl.vertexAttribIPointer(
                    index, 1, gl.UNSIGNED_BYTE, 1, siteSSGIdStart
                  );
                }
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.drawArraysInstanced(
                  gl.POINTS, 0, numODFragsAsym, siteSymOrder
                );
              }
            }
          }
          gl.endTransformFeedback();
          gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
          gl.disable(gl.RASTERIZER_DISCARD);
          gl.useProgram(null);
          gl.bindVertexArray(null);
          gl.deleteVertexArray(vao);
        }
        // init vao
        for (const atomSite of atomSites) {
          // vao odfrags
          const odFragsStart = atomSite.odFrags.start;
          const numODFragsAsym = atomSite.odFragsAsym.num;
          const siteSymOrder = atomSite.siteSymOrder;
          const numODFrags = numODFragsAsym * siteSymOrder;
          for (let i = 0, n = atomSite.numEqvPositions; i < n; i += 1) {
            const odFragsStartI = odFragsStart + i * numODFrags;
            if (atomSite.vaoGenODInstance[i]) {
              gl.deleteVertexArray(atomSite.vaoGenODInstance[i]);
            }
            const vao = atomSite.vaoGenODInstance[i] = gl.createVertexArray();
            const stride = VBO_ODFRAG_STRIDE[dimPerp];
            const baseOffset = stride * odFragsStartI;
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odFragVId);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribIPointer(0, 1, gl.BYTE, 1, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odFrag);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribDivisor(1, 1);
            gl.vertexAttribIPointer(1, 1, gl.UNSIGNED_INT, stride, baseOffset);
            if (dimPerp > 0) {
              const baseOffset2 =
                baseOffset + stride - dimPerp * (dimPerp + 1) * 4;
              for (let j = 0; j <= dimPerp; j += 1) {
                const index = j + 2;
                const offset = baseOffset2 + j * dimPerp * 4;
                gl.enableVertexAttribArray(index);
                gl.vertexAttribDivisor(index, 1);
                gl.vertexAttribPointer(
                  index, dimPerp, gl.FLOAT, false, stride, offset
                );
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
          }
        }
        gl.bindVertexArray(null);
        return this.requestId
      }
    );
    const updateVaoCut = createSelector(
      [
        selectDimPerp,
        updateAtomSites,
        updateDisplacements,
        updateODData
      ],
      (dimPerp, ...updates) => {
        if (
          dimPerp === false ||
          updates.some(x => x === NOT_READY)
        ) {
          return NOT_READY
        }
        const gl = this.gl;
        const atomSites = this.atomSites;
        for (const atomSite of atomSites) {
          // vao cut
          for (
            const [eqvPosId, eqvPosDispData]
            of atomSite.eqvPositionsDisplacementData.entries()
          ) {
            for (const vao of atomSite.eqvPositionsVaoCut[eqvPosId]) {
              gl.deleteVertexArray(vao);
            }
            atomSite.eqvPositionsVaoCut[eqvPosId] = [];
            for (
              const [dispId, targetAtomSiteId]
              of eqvPosDispData.targetAtomSiteIds.entries()
            ) {
              const vao =
                atomSite.eqvPositionsVaoCut[eqvPosId][dispId] =
                gl.createVertexArray();
              const targetAtomSite = atomSites[targetAtomSiteId];
              const odFragsStart = targetAtomSite.odFrags.start;
              const numODFragsAsym = targetAtomSite.odFragsAsym.num;
              const siteSymOrder = targetAtomSite.siteSymOrder;
              const numODFrags = numODFragsAsym * siteSymOrder;
              const odFragsStartI = odFragsStart + eqvPosId * numODFrags;
              gl.bindVertexArray(vao);
              gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.proj);
              gl.enableVertexAttribArray(0);
              gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 32, 20);
              {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.displacement);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribDivisor(1, numODFrags);
                const offset = 12 * (eqvPosDispData.start + dispId);
                gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 12, offset);
              }
              const stride = VBO_ODFRAG_STRIDE[dimPerp];
              const baseOffset = stride * odFragsStartI;
              gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.odFrag);
              gl.enableVertexAttribArray(2);
              gl.vertexAttribDivisor(2, 1);
              gl.vertexAttribIPointer(2, 1, gl.UNSIGNED_INT, stride, baseOffset);
              if (dimPerp > 0) {
                const baseOffset2 = baseOffset + 4;
                for (let i = 0; i <= dimPerp; i += 1) {
                  const index = i + 3;
                  const offset = baseOffset2 + i * dimPerp * 4;
                  gl.enableVertexAttribArray(index);
                  gl.vertexAttribDivisor(index, 1);
                  gl.vertexAttribPointer(
                    index, dimPerp, gl.FLOAT, false, stride, offset
                  );
                }
              }
            }
          }
        }
        gl.bindVertexArray(null);
        return this.requestId
      }
    );
    const updateLattFractCoordGenerator = createSelector(
      [
        () => this.rCutParCartn,
        selectDimPerp,
        selectAParCartn,
        selectAPerpCartn,
        updateAtomSites,
        updateODData // for atomSite.rPerpCartnMax
      ],
      (rCutParCartn, dimPerp, aParCartn, aPerpCartn, ...updates) => {
        if (
          dimPerp === false ||
          !aParCartn ||
          !aPerpCartn ||
          updates.some(x => x === NOT_READY)
        ) {
          return NOT_READY
        }
        // ad hoc ...
        const mPar = lnum.sdiv(aParCartn, rCutParCartn);
        for (const atomSite of this.atomSites) {
          const rCutPerpCartn = atomSite.rPerpCartnMax;
          if (rCutPerpCartn > 0 || dimPerp === 0) {
            const mPerp = lnum.sdiv(aPerpCartn, rCutPerpCartn);
            atomSite.lattFractCoordGenerator = xFractGenerator2(mPar, mPerp);
          }
        }
        return this.requestId
      }
    );
    const updateLattFractCoord = createSelector(
      [
        selectOFractPlusDelta,
        updateAtomSites,
        updateLattFractCoordGenerator
      ],
      (oFract, ...updates) => {
        if (!oFract || updates.some(x => x === NOT_READY)) {
          return NOT_READY
        }
        const dim = oFract.length;
        const embed = [0, 0, 0, 0, 0, 0];
        for (const atomSite of this.atomSites) {
          const generator = atomSite.lattFractCoordGenerator;
          for (let i = 0, n = atomSite.numEqvPositions; i < n; i += 1) {
            if (generator) {
              const siteFractCoord = atomSite.eqvPosFractCoords[i];
              const v = lnum.sub(siteFractCoord, oFract);
              const arr = [];
              for (const lattFractCoord of generator(v)) {
                for (let j = 0; j < dim; j += 1) {
                  embed[j] = lattFractCoord[j];
                }
                arr.push(...embed);
              }
              atomSite.lattFractCoordCache[i] = arr;
            } else {
              atomSite.lattFractCoordCache[i] = [];
            }
          }
        }
        return this.requestId
      }
    );
    const detectUIUpdate = () =>
      this.ui.dragX ||
      this.ui.dragY ||
      this.ui.shiftDragX ||
      this.ui.shiftDragY ||
      this.ui.wheelDeltaY ||
      this.ui.shiftWheelDeltaY ||
      this.ui.ctrlWheelDeltaY ||
      // this.ui.doubleClicked ||
      this.ui.shiftDoubleClicked ||
      this.ui.ctrlShiftDoubleClicked ||
      this.ui.ctrlDoubleClicked
        ? this.requestId
        : false;
    const updateUI = createSelector(
      [
        selectWidth,
        selectHeight,
        selectViewports,
        selectCurrentPosition,
        selectDragStartPosition,
        selectDimPar,
        selectDimPerp,
        selectAParCartn,
        selectAPerpCartn,
        selectBCartn,
        selectOFract,
        detectUIUpdate
      ],
      (
        width,
        height,
        viewports,
        currentPosition,
        dragStartPosition = currentPosition,
        dimPar,
        dimPerp,
        aParCartn,
        aPerpCartn,
        bCartn,
        oFract,
        uiUpdate
      ) => {
        if (
          this.lastUpdateFailed ||
          dimPar === false ||
          dimPerp === false ||
          !aParCartn ||
          !aPerpCartn ||
          !bCartn ||
          !oFract ||
          !uiUpdate
        ) {
          return NOT_READY
        }
        const dim = dimPar + dimPerp;
        const currentViewport = viewports.filter(
          viewport =>
            currentPosition.x >= viewport.x &&
            currentPosition.x < viewport.x + viewport.width &&
            currentPosition.y >= viewport.y &&
            currentPosition.y < viewport.y + viewport.height
        )[0];
        const dragStartViewport = viewports.filter(
          viewport =>
            dragStartPosition.x >= viewport.x &&
            dragStartPosition.x < viewport.x + viewport.width &&
            dragStartPosition.y >= viewport.y &&
            dragStartPosition.y < viewport.y + viewport.height
        )[0];
        if (!currentViewport || !dragStartViewport) {
          return NOT_READY
        }
        const currentIsPerpendicular =
          ((currentViewport.data || {}).target || {}).isPerpendicular;
        const currentCamera = currentIsPerpendicular
          ? this.cameraPerp
          : this.cameraPar;
        const dragStartIsPerpendicular =
          ((dragStartViewport.data || {}).target || {}).isPerpendicular;
        const dragStartCamera = dragStartIsPerpendicular
          ? this.cameraPerp
          : this.cameraPar;
        if (currentViewport !== dragStartViewport) {
          this.ui.dragging = false;
        }
        if (this.ui.dragX !== 0 || this.ui.dragY !== 0) {
          const movement = [this.ui.dragX, -this.ui.dragY, 0];
          const th = dragStartCamera.rotFactor * Math.hypot(...movement);
          const viewTrans = lnum.transpose(dragStartCamera.viewMat());
          const normal = lnum.$(...inormalise$1(cross3$1([0, 0, 1], movement)), 0);
          const ax = lnum.$(...lnum.mmul(viewTrans, normal).slice(0, 3));
          const v1 = lnum.sub(dragStartCamera.position, dragStartCamera.lookAt);
          const rot = rotateV3$1(-th, ax);
          const v2 = lnum.mmul(rot, v1);
          dragStartCamera.position = lnum.add(dragStartCamera.lookAt, v2);
          dragStartCamera.upDir = lnum.mmul(rot, dragStartCamera.upDir);
        }
        if (this.ui.wheelDeltaY !== 0) {
          const deltaY = this.ui.wheelDeltaY;
          let v = lnum.sub(currentCamera.position, currentCamera.lookAt);
          const factor = Math.exp(currentCamera.zoomFactor * deltaY);
          const norm = Math.hypot(...v);
          const dist = Math.min(Math.max(norm * factor, currentCamera.distMin),
            currentCamera.distMax);
          v = lnum.ismul(inormalise$1(v), dist);
          currentCamera.position = lnum.add(currentCamera.lookAt, v);
        }
        if (
          this.ui.shiftDragX !== 0 ||
          this.ui.shiftDragY !== 0 ||
          this.ui.shiftWheelDeltaY !== 0
        ) {
          const factor = dragStartCamera.distance * dragStartCamera.moveFactor;
          const movement = lnum.ismul([
            this.ui.shiftDragX,
            -this.ui.shiftDragY,
            this.ui.shiftWheelDeltaY,
            0
          ], factor);
          const viewTrans = lnum.transpose(dragStartCamera.viewMat());
          const v = lnum.mmul(viewTrans, movement).slice(0, 3);
          if (currentIsPerpendicular) {
            const vFract = lnum.mmul(
              bCartn,
              Array.from({ length: dimPar }, () => 0).concat(
                v.slice(0, dimPerp)
              )
            );
            if (!this.deltaOFract || this.deltaOFract.length !== dim) {
              this.deltaOFract = lnum.$(...Array.from({ length: dim }, () => 0));
              this.deltaOFractOffset =
                lnum.$(...Array.from({ length: dim }, () => 0));
            }
            const next = lnum.add(this.deltaOFract, vFract);
            const offset = next.map(x => Math.floor(x));
            this.deltaOFract = lnum.sub(next, offset);
            this.deltaOFractOffset = lnum.$(
              ...lnum.add(this.deltaOFractOffset, offset).map(x => x & ~0)
            ).setDim(dim);
          } else {
            const vFract = lnum.mmul(
              bCartn,
              v.slice(0, dimPar).concat(
                Array.from({ length: dimPerp }, () => 0)
              )
            );
            if (!this.deltaOFract || this.deltaOFract.length !== dim) {
              this.deltaOFract = lnum.$(...Array.from({ length: dim }, () => 0));
              this.deltaOFractOffset =
                lnum.$(...Array.from({ length: dim }, () => 0));
            }
            const next = lnum.sub(this.deltaOFract, vFract);
            const offset = next.map(x => Math.floor(x));
            this.deltaOFract = lnum.sub(next, offset);
            this.deltaOFractOffset = lnum.$(
              ...lnum.add(this.deltaOFractOffset, offset).map(x => x & ~0)
            ).setDim(dim);
          }
        }
        if (this.ui.ctrlWheelDeltaY !== 0) {
          const factor = Math.exp(
            -currentCamera.zoomFactor * this.ui.ctrlWheelDeltaY
          );
          this.rCutParCartn = Math.max(
            this.rCutParCartnMin,
            Math.min(this.rCutParCartnMax, this.rCutParCartn * factor)
          );
        }
        if (
          this.ui.shiftDoubleClicked ||
          this.ui.ctrlShiftDoubleClicked ||
          this.ui.ctrlDoubleClicked
        ) {
          this.readBackInfo(true);
        }
        if (this.lastInfo) {
          if (this.ui.shiftDoubleClicked) {
            if (this.lastInfo.typeId === TYPEID_NONE) {
              const vFract = Array.from(
                { length: dim }, () => (Math.random() - 0.5) * 1e-3
              );
              if (!this.deltaOFract || this.deltaOFract.length !== dim) {
                this.deltaOFract =
                  lnum.$(...Array.from({ length: dim }, () => 0));
                this.deltaOFractOffset =
                  lnum.$(...Array.from({ length: dim }, () => 0));
              }
              const next = lnum.add(this.deltaOFract, vFract);
              const offset = next.map(x => Math.floor(x));
              this.deltaOFract = lnum.sub(next, offset);
              this.deltaOFractOffset = lnum.$(
                ...lnum.add(this.deltaOFractOffset, offset).map(x => x & ~0)
              ).setDim(dim);
            } else if (
              this.lastInfo.typeId === TYPEID_ATOM &&
              this.lastInfo.odLabel &&
              Number.isInteger(this.mapODIdToAtomSiteId[this.lastInfo.odId]) &&
              this.mapODIdToAtomSiteId[this.lastInfo.odId] >= 0
            ) {
              const atomSiteId = this.mapODIdToAtomSiteId[this.lastInfo.odId];
              const atomSite = this.atomSites[atomSiteId];
              const eqvPosId =
                atomSite.mapSSGInternalIdToEqvPosId[this.lastInfo.ssgInternalId];
              const siteFractCoord = atomSite.eqvPosFractCoords[eqvPosId];
              const lattFractCoord = this.lastInfo.lattFractCoord;
              if (!this.deltaOFract || this.deltaOFract.length !== dim) {
                this.deltaOFract =
                  lnum.$(...Array.from({ length: dim }, () => 0));
                this.deltaOFractOffset =
                  lnum.$(...Array.from({ length: dim }, () => 0));
              }
              const v = lnum.isub(
                lnum.add(lattFractCoord.slice(0, dim), siteFractCoord),
                lnum.add(
                  lnum.add(oFract, this.deltaOFract), this.deltaOFractOffset
                )
              );
              let vFract;
              if (currentIsPerpendicular) {
                const vPerpCartn = lnum.mmul(aPerpCartn, v);
                vFract = lnum.mmul(
                  bCartn,
                  Array.from({ length: dimPar }, () => 0).concat(vPerpCartn)
                );
              } else {
                const vParCartn = lnum.mmul(aParCartn, v);
                vFract = lnum.mmul(
                  bCartn,
                  vParCartn.concat(Array.from({ length: dimPerp }, () => 0))
                );
              }
              const next = lnum.add(this.deltaOFract, vFract);
              const offset = next.map(x => Math.floor(x));
              this.deltaOFract = lnum.sub(next, offset);
              this.deltaOFractOffset = lnum.$(
                ...lnum.add(this.deltaOFractOffset, offset).map(x => x & ~0)
              ).setDim(dim);
            }
          }
          if (this.ui.ctrlShiftDoubleClicked) {
            switch (this.lastInfo.typeId) {
              case TYPEID_NONE: {
                this.highlightMask = {
                  type: false,
                  od: false,
                  ssg: false,
                  latt: false
                };
                break
              }
              case TYPEID_OD: {
                this.highlightMask = {
                  ...this.highlightMask,
                  type: true,
                  od: true,
                  ssg: true
                };
                this.highlightRef = {
                  typeId: this.lastInfo.typeId,
                  type: this.lastInfo.type,
                  odId: this.lastInfo.odId,
                  odLabel: this.lastInfo.odLabel,
                  ssgId: this.lastInfo.ssgId,
                  lattFractCoord: this.lastInfo.lattFractCoord
                };
                break
              }
              case TYPEID_ATOM: {
                this.highlightMask = {
                  ...this.highlightMask,
                  type: true,
                  od: true,
                  ssg: true,
                  latt: true
                };
                this.highlightRef = {
                  typeId: this.lastInfo.typeId,
                  type: this.lastInfo.type,
                  odId: this.lastInfo.odId,
                  odLabel: this.lastInfo.odLabel,
                  ssgId: this.lastInfo.ssgId,
                  lattFractCoord: this.lastInfo.lattFractCoord
                };
                break
              }
            }
          }
          if (this.ui.ctrlDoubleClicked) {
            const setAt = [
              (currentViewport.x + currentViewport.width / 2) / width,
              1 - (currentViewport.y + currentViewport.height / 2) / height
            ];
            if (currentIsPerpendicular) {
              const data = { target: { isPerpendicular: false } };
              this.store.dispatch(this.overlayPanelSetData(setAt, data));
            } else {
              switch (this.lastInfo.typeId) {
                case TYPEID_ATOM: {
                  const atomSiteId =
                    this.mapODIdToAtomSiteId[this.lastInfo.odId];
                  const atomSite = this.atomSites[atomSiteId];
                  const eqvPosId = atomSite
                    .mapSSGInternalIdToEqvPosId[this.lastInfo.ssgInternalId];
                  const data = {
                    target: {
                      isPerpendicular: true,
                      atomSiteId,
                      eqvPosId
                    }
                  };
                  this.store.dispatch(this.overlayPanelSetData(setAt, data));
                }
              }
            }
          }
        }
        return this.requestId
      }
    );
    const updateCanvas = createSelector(
      [
        selectViewports,
        selectCurrentPosition,
        selectDimPerp,
        selectODLabels,
        () => this.ui.showAtoms,
        () => this.ui.showAsymBonds,
        () => this.ui.showBonds,
        () => this.ui.showVertices,
        () => this.ui.showEdges,
        () => this.ui.showFaces,
        () => this.ui.showODs,
        detectUIUpdate,
        updateEnvironmentUniform,
        updateHighlightUniform,
        updateCartnTransformUniform,
        updateSSGTexture,
        updateODColourRadiusTexture,
        updateAtomSites,
        updateDisplacements,
        updateODData,
        updateVaoCut,
        updateLattFractCoord,
        () => this.cameraPar.orthographic
      ],
      (
        viewports,
        currentPosition,
        dimPerp,
        odLabels,
        showAtoms,
        showAsymBonds,
        showBonds,
        showVertices,
        showEdges,
        showFaces,
        showODs,
        uiUpdate,
        ...updates
      ) => {
        if (
          dimPerp === false ||
          !odLabels ||
          updates.some(x => x === NOT_READY)
        ) {
          return NOT_READY
        }
        // console.warn('bbb', odLabels.length, updates)
        const gl = this.gl;
        this.clearMainFramebuffer();
        this.clearInfoFramebuffer();

        const viewportsPar = viewports.filter(
          viewport => !((viewport.data || {}).target || {}).isPerpendicular
        );
        for (const [atomSiteId, atomSite] of this.atomSites.entries()) {
          for (
            let eqvPosId = 0; eqvPosId < atomSite.numEqvPositions; eqvPosId += 1
          ) {
            const numAtoms = atomSite.lattFractCoordCache[eqvPosId].length / 6;
            const numODFrags = atomSite.odFragsAsym.num * atomSite.siteSymOrder;
            const viewportsPerp = viewports.filter(
              viewport => {
                const target = (viewport.data || {}).target || {};
                return target.atomSiteId === atomSiteId &&
                  target.eqvPosId === eqvPosId
              }
            );
            if (showODs) {
              this.genODInstances(dimPerp, atomSiteId, eqvPosId);
            }
            if (viewportsPar.length > 0 || viewportsPerp.length > 0) {
              if (
                showAtoms ||
                showAsymBonds ||
                showBonds ||
                showVertices ||
                showEdges ||
                showFaces
              ) {
                this.projAndCut(dimPerp, atomSiteId, eqvPosId);
              }
              for (const viewport of viewportsPar) {
                // draw external space
                if (showAtoms) {
                  this.drawAtoms(
                    viewport, false, this.vao.drawAtomsPar, numAtoms
                  );
                  this.drawAtomsInfo(
                    viewport,
                    currentPosition,
                    false,
                    this.vao.drawAtomsInfoPar,
                    numAtoms
                  );
                }
              }
              if (
                showAsymBonds ||
                showBonds ||
                showVertices ||
                showEdges ||
                showFaces
              ) {
                this.prepareDisplacements(dimPerp, atomSiteId, eqvPosId);
              }
              if (showAsymBonds) {
                const bondData = atomSite.eqvPositionsAsymBondData[eqvPosId];
                for (let i = bondData.start; i < bondData.end; i += 1) {
                  this.maskAsymBonds(dimPerp, atomSiteId, eqvPosId, i);
                  for (const viewport of viewportsPar) {
                    this.drawHalfBonds(
                      viewport, this.vao.drawHalfBonds, numAtoms
                    );
                    this.drawHalfBondsInfo(
                      viewport,
                      currentPosition,
                      this.vao.drawHalfBondsInfo,
                      numAtoms
                    );
                  }
                }
              }
              if (showBonds) {
                const bondData = atomSite.eqvPositionsBondData[eqvPosId];
                for (let i = bondData.start; i < bondData.end; i += 1) {
                  this.maskBonds(dimPerp, atomSiteId, eqvPosId, i);
                  for (const viewport of viewportsPar) {
                    this.drawHalfBonds(
                      viewport, this.vao.drawHalfBonds, numAtoms
                    );
                    this.drawHalfBondsInfo(
                      viewport,
                      currentPosition,
                      this.vao.drawHalfBondsInfo,
                      numAtoms
                    );
                  }
                }
              }
              if (showVertices) {
                const vertexData = atomSite.eqvPositionsVertexData[eqvPosId];
                for (let i = vertexData.start; i < vertexData.end; i += 1) {
                  this.maskVertices(dimPerp, atomSiteId, eqvPosId, i);
                  for (const viewport of viewportsPar) {
                    this.drawVertices(viewport, this.vao.drawVertices, numAtoms);
                    this.drawVerticesInfo(
                      viewport,
                      currentPosition,
                      this.vao.drawVerticesInfo,
                      numAtoms
                    );
                  }
                }
              }
              if (showEdges) {
                const edgeData = atomSite.eqvPositionsEdgeData[eqvPosId];
                for (let i = edgeData.start; i < edgeData.end; i += 1) {
                  this.maskEdges(dimPerp, atomSiteId, eqvPosId, i);
                  for (const viewport of viewportsPar) {
                    this.drawEdges(viewport, this.vao.drawEdges, numAtoms);
                    this.drawEdgesInfo(
                      viewport,
                      currentPosition,
                      this.vao.drawEdgesInfo,
                      numAtoms
                    );
                  }
                }
              }
              if (showFaces) {
                const faceData = atomSite.eqvPositionsFaceData[eqvPosId];
                for (let i = faceData.start; i < faceData.end; i += 1) {
                  this.maskFaces(dimPerp, atomSiteId, eqvPosId, i);
                  for (const viewport of viewportsPar) {
                    this.drawFaces(viewport, this.vao.drawFaces, numAtoms);
                    this.drawFacesInfo(
                      viewport,
                      currentPosition,
                      this.vao.drawFacesInfo,
                      numAtoms
                    );
                  }
                }
              }
              for (const viewport of viewportsPerp) {
                // draw internal space
                if (showAtoms) {
                  this.drawAtoms(
                    viewport, true, this.vao.drawAtomsPerp, numAtoms
                  );
                  this.drawAtomsInfo(
                    viewport,
                    currentPosition,
                    true,
                    this.vao.drawAtomsInfoPerp,
                    numAtoms
                  );
                }
                if (showODs) {
                  this.drawODFrags(
                    dimPerp,
                    viewport,
                    this.vao.drawODFrags,
                    numODFrags
                  );
                  this.drawODFragsInfo(
                    dimPerp,
                    viewport,
                    currentPosition,
                    this.vao.drawODFragsInfo,
                    numODFrags
                  );
                }
              }
            }
            if (showAsymBonds && showODs) {
              const bondData = atomSite.eqvPositionsAsymBondData[eqvPosId];
              const dispIdOffset = bondData.dispIdOffset;
              for (
                const { displacementId, targetAtomSiteId, targetEqvPosId }
                of bondData.eqvPosBonds
              ) {
                const dispId = displacementId + dispIdOffset;
                const targetViewports = viewports.filter(
                  viewport => {
                    const target = (viewport.data || {}).target || {};
                    return target.atomSiteId === targetAtomSiteId &&
                      target.eqvPosId === targetEqvPosId
                  }
                );
                for (const viewport of targetViewports) {
                  this.drawODFrags(
                    dimPerp,
                    viewport,
                    this.vao.drawODFrags,
                    numODFrags,
                    dispId
                  );
                  this.drawODFragsInfo(
                    dimPerp,
                    viewport,
                    currentPosition,
                    this.vao.drawODFragsInfo,
                    numODFrags,
                    dispId
                  );
                }
              }
            }
          }
        }
        // copy info
        if (!this.sync.info) {
          gl.readPixels(0, 0, 1, 1, gl.RGBA_INTEGER, gl.UNSIGNED_INT, 0);
          this.sync.info = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          this.infoODLabels = odLabels;
        }
        // require if gl.SAMPLE_ALPHA_TO_COVERAGE is used
        this.resetAlpha();
        return this.requestId
      }
    );
    this.update = () => {
      const gl = this.gl;
      if (
        !this.sync.info ||
        gl.clientWaitSync(this.sync.info, 0, 0) === gl.ALREADY_SIGNALED
      ) {
        this.readBackInfo();
        if (this.lastContext) {
          updateUI({ ...this.lastContext });
        }
        this.lastContext = { state: this.store.getState() };
        this.lastUpdateFailed = updateCanvas(this.lastContext) === NOT_READY;
        this.resetTemporaryUIInfo();
        this.requestId = window.requestAnimationFrame(this.update);
        const prev = this.prev;
        const now = window.performance.now();
        const diff = (now - prev) / 1000;
        this.frameCount += 1;
        if (diff >= 1) {
          const fps = Math.floor(this.frameCount / diff);
          this.prev = now;
          this.frameCount = 0;
          if (this.subscribers.fps) {
            this.subscribers.fps(fps);
          }
        }
      } else {
        this.requestId = window.requestAnimationFrame(this.update);
      }
    };
  }

  finaliseUpdater () {
    const gl = this.gl;
    this.update = null;
    for (const atomSite of this.atomSites) {
      for (const vao of atomSite.vaoGenODInstance) {
        if (vao) {
          gl.deleteVertexArray(vao);
        }
      }
      for (const vao of atomSite.vaoProj) {
        if (vao) {
          gl.deleteVertexArray(vao);
        }
      }
      for (const eqvPosVaoCut of atomSite.eqvPositionsVaoCut) {
        for (const vao of eqvPosVaoCut) {
          if (vao) {
            gl.deleteVertexArray(vao);
          }
        }
      }
    }
  }

  clearMainFramebuffer () {
    const gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  clearInfoFramebuffer () {
    const gl = this.gl;
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo.info);
    gl.clearBufferuiv(gl.COLOR, 0, CLEAR_INFO);
    gl.clearBufferfv(gl.DEPTH, 0, [1.0]);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
  }

  resetAlpha () {
    const gl = this.gl;
    const width = gl.drawingBufferWidth;
    const height = gl.drawingBufferHeight;
    gl.useProgram(this.prg.fillBGWhite);
    gl.viewport(0, 0, width, height);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.GREATER);
    gl.colorMask(false, false, false, true);
    gl.depthMask(false);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.depthMask(true);
    gl.colorMask(true, true, true, true);
    gl.depthFunc(gl.LESS);
    gl.disable(gl.DEPTH_TEST);
    gl.useProgram(null);
  }

  readBackInfo (sync = false) {
    const gl = this.gl;
    if (
      this.sync.info &&
      (
        sync ||
        gl.clientWaitSync(this.sync.info, 0, 0) === gl.ALREADY_SIGNALED
      )
    ) {
      gl.deleteSync(this.sync.info);
      this.sync.info = null;
      const info = new Uint32Array(4);
      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, info);
      const odLabels = this.infoODLabels;
      const typeId = info[0];
      const type = TYPE_TEXT[info[0]];
      const odId = info[1] >>> SSGID_BIT_LENGTH;
      const odLabel = odId !== INVALID_ODID ? odLabels[odId] : '';
      const ssgInternalId = info[1] % MAX_SSG_COUNT;
      const ssgId = ssgInternalId + 1;
      const lattFractCoordId = [info[2], info[3]];
      const offset = this.deltaOFractOffset
        ? [0, 0, 0, 0, 0, 0].map(
          (x, i) => i < this.deltaOFractOffset.length
            ? this.deltaOFractOffset[i]
            : x
        )
        : [0, 0, 0, 0, 0, 0];
      let lattFractCoord = [
        (info[2] >>> 24 & 255) - 128,
        (info[2] >>> 16 & 255) - 128,
        (info[2] >>> 8 & 255) - 128,
        (info[2] & 255) - 128,
        (info[3] >>> 24 & 255) - 128,
        (info[3] >>> 16 & 255) - 128
      ];
      if (lattFractCoord[0] === -128) {
        lattFractCoord = null;
      } else {
        lattFractCoord = lattFractCoord.map((x, i) => x + offset[i]);
      }
      this.lastInfo = {
        typeId,
        odId,
        ssgInternalId,
        lattFractCoordId,
        type,
        odLabel,
        ssgId,
        lattFractCoord
      };
      if (this.subscribers.infoString) {
        this.subscribers.infoString({
          type,
          odLabel: odLabel || '.',
          ssgId: ssgId.toString(),
          lattFractCoord: lattFractCoord === null
            ? '.'
            : lnum.$(...lattFractCoord).toString()
        });
      }
    }
  }

  genODInstances (dimPerp, atomSiteId, eqvPosId) {
    const atomSite = this.atomSites[atomSiteId];
    const numODFrags = atomSite.odFragsAsym.num * atomSite.siteSymOrder;
    if (numODFrags <= 0) {
      return
    }
    const vao = atomSite.vaoGenODInstance[eqvPosId];
    const vbo = this.vbo.odInstance;
    const gl = this.gl;
    const prg = this.prg.genODInstances[dimPerp];
    gl.useProgram(prg);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(vao);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, vbo);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArraysInstanced(
      gl.POINTS, ODFRAG_VID_START[dimPerp], NUM_ODFRAG_VIDS[dimPerp], numODFrags
    );
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.bindVertexArray(null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.useProgram(null);
  }

  projAndCut (dimPerp, atomSiteId, eqvPosId) {
    const atomSite = this.atomSites[atomSiteId];
    const numODFrags = atomSite.odFragsAsym.num * atomSite.siteSymOrder;
    if (numODFrags <= 0) {
      return
    }
    const numLattFractCoords = atomSite.lattFractCoordCache[eqvPosId].length / 6;
    if (numLattFractCoords <= 0) {
      return
    }
    const gl = this.gl;
    // proj
    updateBuffer(
      gl, gl.ARRAY_BUFFER, this.vbo.lattFractCoord, 0,
      new Int8Array(atomSite.lattFractCoordCache[eqvPosId])
    );
    gl.useProgram(this.prg.proj);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(atomSite.vaoProj[eqvPosId]);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.proj);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArraysInstanced(gl.POINTS, 0, numLattFractCoords, 1);
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    // cut
    gl.useProgram(this.prg.cut[dimPerp]);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbTex.cut);
    gl.framebufferTextureLayer(
      gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.tex.cut, 0, 0
    );
    gl.viewport(0, 0, CUT_TEXTURE_WIDTH, CUT_TEXTURE_WIDTH);
    gl.clearBufferuiv(gl.COLOR, 0, [INVALID_ODID << SSGID_BIT_LENGTH, 0, 0, 0]);
    gl.bindVertexArray(atomSite.eqvPositionsVaoCut[eqvPosId][0]);
    gl.drawArraysInstanced(gl.POINTS, 0, numLattFractCoords, numODFrags);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    // colour atoms
    gl.useProgram(this.prg.colourAtoms);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(this.vao.colourAtoms);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.atom);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, numLattFractCoords);
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  prepareDisplacements (dimPerp, atomSiteId, eqvPosId) {
    const gl = this.gl;
    const atomSite = this.atomSites[atomSiteId];
    const numLattFractCoords = atomSite.lattFractCoordCache[eqvPosId].length / 6;
    if (numLattFractCoords <= 0) {
      return
    }
    gl.useProgram(this.prg.cut[dimPerp]);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbTex.cut);
    gl.viewport(0, 0, CUT_TEXTURE_WIDTH, CUT_TEXTURE_WIDTH);
    for (
      const [dispId, targetAtomSiteId]
      of atomSite.eqvPositionsDisplacementData[eqvPosId]
        .targetAtomSiteIds.entries()
    ) {
      if (dispId === 0) {
        // dispId === 0 is for 'no displacement'
        continue
      }
      const targetAtomSite = this.atomSites[targetAtomSiteId];
      const numODFrags = targetAtomSite.odFragsAsym.num *
        targetAtomSite.siteSymOrder;
      gl.framebufferTextureLayer(
        gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.tex.cut, 0, dispId
      );
      gl.clearBufferuiv(
        gl.COLOR, 0, [INVALID_ODID << SSGID_BIT_LENGTH, 0, 0, 0]
      );
      if (numODFrags > 0) {
        gl.bindVertexArray(atomSite.eqvPositionsVaoCut[eqvPosId][dispId]);
        gl.drawArraysInstanced(gl.POINTS, 0, numLattFractCoords, numODFrags);
      }
    }
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.useProgram(null);
  }

  // only perp
  drawODFrags (dimPerp, viewport, vao, numODFrags, dispId = 0) {
    if (numODFrags <= 0) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawODFrags[dimPerp];
    // ad hoc ...
    const camera = this.cameraPerp;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat = camera.projectionMat(...clientSize);
    // ... ad hoc
    gl.useProgram(prg);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.displacement);
    gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 12, dispId * 12);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    // ad hoc ...
    gl.uniform1f(gl.getUniformLocation(prg, 'reflectivity'), 0.8);
    // ... ad hoc
    if (dimPerp === 3) {
      gl.enable(gl.CULL_FACE);
    } else if (dimPerp === 1) {
      gl.lineWidth(5.0);
    }
    gl.drawArraysInstanced(
      gl[DRAW_ODFRAG_MODE[dimPerp]], 0, NUM_ODFRAG_VIDS[dimPerp] * numODFrags, 1
    );
    if (dimPerp === 3) {
      gl.disable(gl.CULL_FACE);
    }
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only perp
  drawODFragsInfo (
    dimPerp, viewport, infoPosition, vao, numODFrags, dispId = 0
  ) {
    if (
      numODFrags <= 0 ||
      infoPosition.x < viewport.x ||
      infoPosition.x >= viewport.x + viewport.width ||
      infoPosition.y < viewport.y ||
      infoPosition.y >= viewport.y + viewport.height
    ) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawODFragsInfo;
    // ad hoc ...
    const camera = this.cameraPerp;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat0 = camera.projectionMat(...clientSize);
    const pmat = lnum.mmul(
      lnum.$(
        viewport.width, 0, 0,
        (viewport.width - 2 * (infoPosition.x - viewport.x) - 1),
        0, viewport.height, 0,
        (viewport.height - 2 * (infoPosition.y - viewport.y) - 1),
        0, 0, 1, 0,
        0, 0, 0, 1
      ).setDim(4, 4),
      pmat0
    );
    // ... ad hoc
    gl.useProgram(prg);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo.info);
    gl.viewport(0, 0, 1, 1);
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.displacement);
    gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 12, dispId * 12);
    gl.enable(gl.DEPTH_TEST);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    if (dimPerp === 3) {
      gl.enable(gl.CULL_FACE);
    } else if (dimPerp === 1) {
      gl.lineWidth(5.0);
    }
    gl.drawArraysInstanced(
      gl[DRAW_ODFRAG_MODE[dimPerp]], 0, NUM_ODFRAG_VIDS[dimPerp] * numODFrags, 1
    );
    if (dimPerp === 3) {
      gl.disable(gl.CULL_FACE);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.useProgram(null);
  }

  drawAtoms (viewport, isPerpendicular, vao, numAtoms) {
    if (numAtoms <= 0) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawAtoms;
    // ad hoc ...
    const camera = isPerpendicular ? this.cameraPerp : this.cameraPar;
    const vmat = camera.viewMat();
    const vmatPerp = isPerpendicular ? vmat : this.cameraPerp.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat = camera.projectionMat(...clientSize);
    // ... ad hoc
    gl.useProgram(prg);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmatPerp'), false, new Float32Array(vmatPerp)
    );
    // ad hoc ...
    gl.uniform1f(gl.getUniformLocation(prg, 'reflectivity'), 0.5);
    // ... ad hoc
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountSphere, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  drawAtomsInfo (viewport, infoPosition, isPerpendicular, vao, numAtoms) {
    if (
      numAtoms <= 0 ||
      infoPosition.x < viewport.x ||
      infoPosition.x >= viewport.x + viewport.width ||
      infoPosition.y < viewport.y ||
      infoPosition.y >= viewport.y + viewport.height
    ) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawAtomsInfo;
    // ad hoc ...
    const camera = isPerpendicular ? this.cameraPerp : this.cameraPar;
    const vmat = camera.viewMat();
    const vmatPerp = isPerpendicular ? vmat : this.cameraPerp.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat0 = camera.projectionMat(...clientSize);
    const pmat = lnum.mmul(
      lnum.$(
        viewport.width, 0, 0,
        (viewport.width - 2 * (infoPosition.x - viewport.x) - 1),
        0, viewport.height, 0,
        (viewport.height - 2 * (infoPosition.y - viewport.y) - 1),
        0, 0, 1, 0,
        0, 0, 0, 1
      ).setDim(4, 4),
      pmat0
    );
    // ... ad hoc
    gl.useProgram(prg);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo.info);
    gl.viewport(0, 0, 1, 1);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmatPerp'), false, new Float32Array(vmatPerp)
    );
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountSphere, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.useProgram(null);
  }

  maskAsymBonds (dimPerp, atomSiteId, eqvPosId, first) {
    const atomSite = this.atomSites[atomSiteId];
    const numLattFractCoords = atomSite.lattFractCoordCache[eqvPosId].length / 6;
    const gl = this.gl;
    gl.useProgram(this.prg.maskDisplacements);
    gl.bindVertexArray(this.vao.maskAsymBonds);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.bondetc);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArraysInstanced(gl.POINTS, first, 1, numLattFractCoords);
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  maskBonds (dimPerp, atomSiteId, eqvPosId, first) {
    const atomSite = this.atomSites[atomSiteId];
    const numLattFractCoords = atomSite.lattFractCoordCache[eqvPosId].length / 6;
    const gl = this.gl;
    gl.useProgram(this.prg.maskDisplacements);
    gl.bindVertexArray(this.vao.maskBonds);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.bondetc);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArraysInstanced(gl.POINTS, first, 1, numLattFractCoords);
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawHalfBonds (viewport, vao, numAtoms) {
    if (numAtoms <= 0) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawHalfBonds;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat = camera.projectionMat(...clientSize);
    // ... ad hoc
    gl.useProgram(prg);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    // ad hoc ...
    gl.uniform1f(gl.getUniformLocation(prg, 'reflectivity'), 0.5);
    // ... ad hoc
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountCylinder, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawHalfBondsInfo (viewport, infoPosition, vao, numAtoms) {
    if (
      numAtoms <= 0 ||
      infoPosition.x < viewport.x ||
      infoPosition.x >= viewport.x + viewport.width ||
      infoPosition.y < viewport.y ||
      infoPosition.y >= viewport.y + viewport.height
    ) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawHalfBondsInfo;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat0 = camera.projectionMat(...clientSize);
    const pmat = lnum.mmul(
      lnum.$(
        viewport.width, 0, 0,
        (viewport.width - 2 * (infoPosition.x - viewport.x) - 1),
        0, viewport.height, 0,
        (viewport.height - 2 * (infoPosition.y - viewport.y) - 1),
        0, 0, 1, 0,
        0, 0, 0, 1
      ).setDim(4, 4),
      pmat0
    );
    // ... ad hoc
    gl.useProgram(prg);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo.info);
    gl.viewport(0, 0, 1, 1);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountCylinder, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.useProgram(null);
  }

  maskVertices (dimPerp, atomSiteId, eqvPosId, first) {
    const atomSite = this.atomSites[atomSiteId];
    const numLattFractCoords = atomSite.lattFractCoordCache[eqvPosId].length / 6;
    const gl = this.gl;
    gl.useProgram(this.prg.maskDisplacements);
    gl.bindVertexArray(this.vao.maskVertices);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.bondetc);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArraysInstanced(gl.POINTS, first, 1, numLattFractCoords);
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawVertices (viewport, vao, numAtoms) {
    if (numAtoms <= 0) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawVertices;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat = camera.projectionMat(...clientSize);
    // ... ad hoc
    gl.useProgram(prg);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    // ad hoc ...
    gl.uniform1f(gl.getUniformLocation(prg, 'reflectivity'), 0.5);
    // ... ad hoc
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountSphere, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawVerticesInfo (viewport, infoPosition, vao, numAtoms) {
    if (
      numAtoms <= 0 ||
      infoPosition.x < viewport.x ||
      infoPosition.x >= viewport.x + viewport.width ||
      infoPosition.y < viewport.y ||
      infoPosition.y >= viewport.y + viewport.height
    ) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawVerticesInfo;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat0 = camera.projectionMat(...clientSize);
    const pmat = lnum.mmul(
      lnum.$(
        viewport.width, 0, 0,
        (viewport.width - 2 * (infoPosition.x - viewport.x) - 1),
        0, viewport.height, 0,
        (viewport.height - 2 * (infoPosition.y - viewport.y) - 1),
        0, 0, 1, 0,
        0, 0, 0, 1
      ).setDim(4, 4),
      pmat0
    );
    // ... ad hoc
    gl.useProgram(prg);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo.info);
    gl.viewport(0, 0, 1, 1);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountCylinder, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.useProgram(null);
  }

  maskEdges (dimPerp, atomSiteId, eqvPosId, first) {
    const atomSite = this.atomSites[atomSiteId];
    const numLattFractCoords = atomSite.lattFractCoordCache[eqvPosId].length / 6;
    const gl = this.gl;
    gl.useProgram(this.prg.maskDisplacements);
    gl.bindVertexArray(this.vao.maskEdges);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.bondetc);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArraysInstanced(gl.POINTS, 2 * first, 2, numLattFractCoords);
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawEdges (viewport, vao, numAtoms) {
    if (numAtoms <= 0) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawEdges;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat = camera.projectionMat(...clientSize);
    // ... ad hoc
    gl.useProgram(prg);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    // ad hoc ...
    gl.uniform1f(gl.getUniformLocation(prg, 'reflectivity'), 0.5);
    // ... ad hoc
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountCylinder, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawEdgesInfo (viewport, infoPosition, vao, numAtoms) {
    if (
      numAtoms <= 0 ||
      infoPosition.x < viewport.x ||
      infoPosition.x >= viewport.x + viewport.width ||
      infoPosition.y < viewport.y ||
      infoPosition.y >= viewport.y + viewport.height
    ) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawEdgesInfo;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat0 = camera.projectionMat(...clientSize);
    const pmat = lnum.mmul(
      lnum.$(
        viewport.width, 0, 0,
        (viewport.width - 2 * (infoPosition.x - viewport.x) - 1),
        0, viewport.height, 0,
        (viewport.height - 2 * (infoPosition.y - viewport.y) - 1),
        0, 0, 1, 0,
        0, 0, 0, 1
      ).setDim(4, 4),
      pmat0
    );
    // ... ad hoc
    gl.useProgram(prg);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo.info);
    gl.viewport(0, 0, 1, 1);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    gl.drawElementsInstanced(
      gl.TRIANGLE_STRIP, this.vCountCylinder, gl.UNSIGNED_INT, 0, numAtoms
    );
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.useProgram(null);
  }

  maskFaces (dimPerp, atomSiteId, eqvPosId, first) {
    const atomSite = this.atomSites[atomSiteId];
    const numLattFractCoords = atomSite.lattFractCoordCache[eqvPosId].length / 6;
    const gl = this.gl;
    gl.useProgram(this.prg.maskDisplacements);
    gl.bindVertexArray(this.vao.maskFaces);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.vbo.bondetc);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArraysInstanced(gl.POINTS, 3 * first, 3, numLattFractCoords);
    gl.endTransformFeedback();
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawFaces (viewport, vao, numAtoms) {
    if (numAtoms <= 0) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawFaces;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat = camera.projectionMat(...clientSize);
    // ... ad hoc
    gl.useProgram(prg);
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    // ad hoc ...
    gl.uniform1f(gl.getUniformLocation(prg, 'reflectivity'), 0.5);
    // ... ad hoc
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, numAtoms);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.useProgram(null);
  }

  // only parallel
  drawFacesInfo (viewport, infoPosition, vao, numAtoms) {
    if (
      numAtoms <= 0 ||
      infoPosition.x < viewport.x ||
      infoPosition.x >= viewport.x + viewport.width ||
      infoPosition.y < viewport.y ||
      infoPosition.y >= viewport.y + viewport.height
    ) {
      return
    }
    const gl = this.gl;
    const prg = this.prg.drawFacesInfo;
    // ad hoc ...
    const camera = this.cameraPar;
    const vmat = camera.viewMat();
    const clientSize = clientSizeOf(gl, viewport);
    const pmat0 = camera.projectionMat(...clientSize);
    const pmat = lnum.mmul(
      lnum.$(
        viewport.width, 0, 0,
        (viewport.width - 2 * (infoPosition.x - viewport.x) - 1),
        0, viewport.height, 0,
        (viewport.height - 2 * (infoPosition.y - viewport.y) - 1),
        0, 0, 1, 0,
        0, 0, 0, 1
      ).setDim(4, 4),
      pmat0
    );
    // ... ad hoc
    gl.useProgram(prg);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo.info);
    gl.viewport(0, 0, 1, 1);
    gl.bindVertexArray(vao);
    gl.enable(gl.DEPTH_TEST);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'vmat'), false, new Float32Array(vmat)
    );
    gl.uniformMatrix4fv(
      gl.getUniformLocation(prg, 'pmat'), false, new Float32Array(pmat)
    );
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, numAtoms);
    gl.disable(gl.DEPTH_TEST);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.useProgram(null);
  }

  initialiseUI () {
    this.ui = {};
    this.ui.showAtoms = true;
    if (this.subscribers.showAtoms) {
      this.subscribers.showAtoms(this.ui.showAtoms);
    }
    this.ui.showAsymBonds = true;
    if (this.subscribers.showAsymBonds) {
      this.subscribers.showAsymBonds(this.ui.showAsymBonds);
    }
    this.ui.showBonds = true;
    if (this.subscribers.showBonds) {
      this.subscribers.showBonds(this.ui.showBonds);
    }
    this.ui.showVertices = true;
    if (this.subscribers.showVertices) {
      this.subscribers.showVertices(this.ui.showVertices);
    }
    this.ui.showEdges = true;
    if (this.subscribers.showEdges) {
      this.subscribers.showEdges(this.ui.showEdges);
    }
    this.ui.showFaces = true;
    if (this.subscribers.showFaces) {
      this.subscribers.showFaces(this.ui.showFaces);
    }
    this.ui.showODs = true;
    if (this.subscribers.showODs) {
      this.subscribers.showODs(this.ui.showODs);
    }
    this.ui.clientMousePosition = [0, 0];
    this.ui.clientDragStartPosition = null;
    this.ui.dragging = false;
    this.resetTemporaryUIInfo();
  }

  resetTemporaryUIInfo () {
    if (this.ui.clientDragStartPosition && !this.ui.dragging) {
      this.ui.clientDragStartPosition = null;
    }
    this.ui.dragX = 0;
    this.ui.dragY = 0;
    this.ui.shiftDragX = 0;
    this.ui.shiftDragY = 0;
    this.ui.wheelDeltaY = 0;
    this.ui.shiftWheelDeltaY = 0;
    this.ui.ctrlWheelDeltaY = 0;
    // this.ui.doubleClicked = false
    this.ui.shiftDoubleClicked = false;
    this.ui.ctrlShiftDoubleClicked = false;
    this.ui.ctrlDoubleClicked = false;
  }

  onMouseDown (e) {
    if (!this.ui.clientDragStartPosition) {
      this.ui.clientDragStartPosition = [e.clientX, e.clientY];
      this.ui.dragging = true;
    }
    e.preventDefault();
  }

  onMouseUp (e) {
    if (this.ui.dragging) {
      this.ui.dragging = false;
    }
  }

  onMouseMove (e) {
    this.ui.clientMousePosition = [e.clientX, e.clientY];
    if (this.ui.dragging) {
      if (e.shiftKey) {
        this.ui.shiftDragX += e.movementX;
        this.ui.shiftDragY += e.movementY;
      } else {
        this.ui.dragX += e.movementX;
        this.ui.dragY += e.movementY;
      }
    }
  }

  onMouseEnter (e) {
    this.ui.clientMousePosition = [e.clientX, e.clientY];
  }

  onMouseLeave (e) {
    this.ui.clientMousePosition = [e.clientX, e.clientY];
    if (this.ui.dragging) {
      if (e.shiftKey) {
        this.ui.shiftDragX += e.movementX;
        this.ui.shiftDragY += e.movementY;
      } else {
        this.ui.dragX += e.movementX;
        this.ui.dragY += e.movementY;
      }
      this.ui.dragging = false;
    }
  }

  onDoubleClick (e) {
    if (e.ctrlKey && !e.altKey && e.shiftKey) {
      this.ui.ctrlShiftDoubleClicked = true;
    } else if (!e.ctrlKey && !e.altKey && e.shiftKey) {
      this.ui.shiftDoubleClicked = true;
    } else if (e.ctrlKey && !e.altKey && !e.shiftKey) {
      this.ui.ctrlDoubleClicked = true;
    }
    e.preventDefault();
  }

  onWheel (e) {
    if (e.shiftKey) {
      this.ui.shiftWheelDeltaY += e.deltaY;
    } else if (e.ctrlKey) {
      this.ui.ctrlWheelDeltaY += e.deltaY;
    } else {
      this.ui.wheelDeltaY += e.deltaY;
    }
    e.preventDefault();
  }

  toggleShowAtoms () {
    this.ui.showAtoms = !this.ui.showAtoms;
    if (this.subscribers.showAtoms) {
      this.subscribers.showAtoms(this.ui.showAtoms);
    }
  }

  toggleShowAsymBonds () {
    this.ui.showAsymBonds = !this.ui.showAsymBonds;
    if (this.subscribers.showAsymBonds) {
      this.subscribers.showAsymBonds(this.ui.showAsymBonds);
    }
  }

  toggleShowBonds () {
    this.ui.showBonds = !this.ui.showBonds;
    if (this.subscribers.showBonds) {
      this.subscribers.showBonds(this.ui.showBonds);
    }
  }

  toggleShowVertices () {
    this.ui.showVertices = !this.ui.showVertices;
    if (this.subscribers.showVertices) {
      this.subscribers.showVertices(this.ui.showVertices);
    }
  }

  toggleShowEdges () {
    this.ui.showEdges = !this.ui.showEdges;
    if (this.subscribers.showEdges) {
      this.subscribers.showEdges(this.ui.showEdges);
    }
  }

  toggleShowFaces () {
    this.ui.showFaces = !this.ui.showFaces;
    if (this.subscribers.showFaces) {
      this.subscribers.showFaces(this.ui.showFaces);
    }
  }

  toggleShowODs () {
    this.ui.showODs = !this.ui.showODs;
    if (this.subscribers.showODs) {
      this.subscribers.showODs(this.ui.showODs);
    }
  }

  toggleCameraProjectionMode () {
    this.cameraPar.orthographic = !this.cameraPar.orthographic;
    this.cameraPerp.orthographic = this.cameraPar.orthographic;
    if (this.subscribers.cameraOrthographic) {
      this.subscribers.cameraOrthographic(this.cameraPar.orthographic);
    }
  }

  toggleHighlightMaskType () {
    this.highlightMask = {
      ...this.highlightMask,
      type: !this.highlightMask.type
    };
  }

  toggleHighlightMaskOD () {
    this.highlightMask = {
      ...this.highlightMask,
      od: !this.highlightMask.od
    };
  }

  toggleHighlightMaskSSG () {
    this.highlightMask = {
      ...this.highlightMask,
      ssg: !this.highlightMask.ssg
    };
  }

  toggleHighlightMaskLatt () {
    this.highlightMask = {
      ...this.highlightMask,
      latt: !this.highlightMask.latt
    };
  }

  resetOrigin () {
    this.deltaOFract = null;
    this.deltaOFractOffset = null;
  }

  setCameraPar () {
    const str = window.prompt(
      'Please input position and updir of the parallel camera',
      JSON.stringify({
        position: this.cameraPar.position.slice(),
        upDir: this.cameraPar.upDir.slice()
      })
    );
    const cameraPar = JSON.parse(str || '{}');
    if (cameraPar) {
      this.cameraPar.position = cameraPar.position;
      this.cameraPar.upDir = cameraPar.upDir;
    }
  }

  setCameraPerp () {
    const str = window.prompt(
      'Please input position and updir of the perpendicular camera',
      JSON.stringify({
        position: this.cameraPerp.position.slice(),
        upDir: this.cameraPerp.upDir.slice()
      })
    );
    const cameraPerp = JSON.parse(str || '{}');
    if (cameraPerp) {
      this.cameraPerp.position = cameraPerp.position;
      this.cameraPerp.upDir = cameraPerp.upDir;
    }
  }

  setODBaseOpacity () {
    const str = window.prompt(
      'Please input base opacity of ODs',
      this.odBaseOpacity.toString()
    );
    const odBaseOpacity = parseFloat(str);
    if (Number.isFinite(odBaseOpacity)) {
      this.odBaseOpacity = odBaseOpacity;
    }
  }

  showHelp () {
    let str = '';
    str += 'Drag: rotate\n';
    str += 'Wheel: zoom\n';
    str += 'Shift + Drag: move\n';
    str += 'Shift + Wheel: move along the view direction\n';
    str += 'Shift + Double-click an atom: move such that the selected atom is at the centre\n';
    str += 'Shift + Double-click background: move slightly in a random direction in both parallel and perpendicular spaces\n';
    str += 'Ctrl + Wheel: change the range of displaying the model\n';
    str += 'Ctrl + Double-click an atom in parallel space: switch to the perpendicular space that contains the selected atom\n';
    str += 'Ctrl + Double-click in perpendicular space: switch to the parallel space\n';
    str += 'Ctrl + Shift + Double-click an atom: highlight the selected atom\n';
    str += 'Ctrl + Shift + Double-click background: stop highlighting';
    window.alert(str);
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const context = new WeakMap();

class QCWeb2CoreHandler {
  constructor (
    canvas,
    store,
    overlayPanelSelector,
    quasicrystalSelector,
    overlayPanelSetData,
    subscribers
  ) {
    const ctx = new QCWeb2Core(
      canvas,
      store,
      overlayPanelSelector,
      quasicrystalSelector,
      overlayPanelSetData,
      subscribers
    );
    context.set(this, ctx);
    this.onMouseDown = e => ctx.onMouseDown(e);
    this.onMouseUp = e => ctx.onMouseUp(e);
    this.onMouseMove = e => ctx.onMouseMove(e);
    this.onMouseLeave = e => ctx.onMouseLeave(e);
    this.onMouseEnter = e => ctx.onMouseEnter(e);
    this.onDoubleClick = e => ctx.onDoubleClick(e);
    this.onWheel = e => ctx.onWheel(e);
  }

  destructor () {
    const ctx = context.get(this);
    ctx.destructor();
    context.delete(this);
  }

  toggleShowAtoms () {
    const ctx = context.get(this);
    ctx.toggleShowAtoms();
  }

  toggleShowAsymBonds () {
    const ctx = context.get(this);
    ctx.toggleShowAsymBonds();
  }

  toggleShowBonds () {
    const ctx = context.get(this);
    ctx.toggleShowBonds();
  }

  toggleShowVertices () {
    const ctx = context.get(this);
    ctx.toggleShowVertices();
  }

  toggleShowEdges () {
    const ctx = context.get(this);
    ctx.toggleShowEdges();
  }

  toggleShowFaces () {
    const ctx = context.get(this);
    ctx.toggleShowFaces();
  }

  toggleShowODs () {
    const ctx = context.get(this);
    ctx.toggleShowODs();
  }

  toggleCameraProjectionMode () {
    const ctx = context.get(this);
    ctx.toggleCameraProjectionMode();
  }

  toggleHighlightMaskType () {
    const ctx = context.get(this);
    ctx.toggleHighlightMaskType();
  }

  toggleHighlightMaskOD () {
    const ctx = context.get(this);
    ctx.toggleHighlightMaskOD();
  }

  toggleHighlightMaskSSG () {
    const ctx = context.get(this);
    ctx.toggleHighlightMaskSSG();
  }

  toggleHighlightMaskLatt () {
    const ctx = context.get(this);
    ctx.toggleHighlightMaskLatt();
  }

  resetOrigin () {
    const ctx = context.get(this);
    ctx.resetOrigin();
  }

  setCameraPar () {
    const ctx = context.get(this);
    ctx.setCameraPar();
  }

  setCameraPerp () {
    const ctx = context.get(this);
    ctx.setCameraPerp();
  }

  setODBaseOpacity () {
    const ctx = context.get(this);
    ctx.setODBaseOpacity();
  }

  showHelp () {
    const ctx = context.get(this);
    ctx.showHelp();
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

// class names
const VIEWER_CLASS_NAME = 'viewer';
const VIEWER_CONTROL_CLASS_NAME = 'viewer-control';
const CANVAS_CLASS_NAME = 'canvas';
const ON_CLASS_NAME = 'on';
const FPS_CLASS_NAME = 'fps';
const CAMERA_IS_ORTHOGRAPHIC_CLASS_NAME = 'camera-is-orthographic';

const SwitchBox = ({
  className,
  title,
  on,
  value,
  onValue,
  onClick
}) => react_13(
  () => react.createElement(
    'div',
    {
      className: [
        className,
        on ? ON_CLASS_NAME : ''
      ].join(' '),
      title,
      onClick
    },
    on ? onValue : value
  ),
  [className, on, value, onValue, onClick]
);

const QCWeb2ViewerCreator = (
  overlayPanelSelector,
  overlayPanelActionPrefix,
  quasicrystalSelector
) => {
  const OverlayPanel = SplittablePanelRootCreator(
    overlayPanelSelector, overlayPanelActionPrefix
  );
  const overlayPanelSetData = setDataCreator(overlayPanelActionPrefix);
  const QCWeb2Viewer = () => {
    const store = useStore();
    const qcweb2CoreHandler = react_16(null);
    const [fps, setFps] = react_8(0);
    const [cameraIsOrthographic, setCameraIsOrthographic] = react_8(false);
    const [info, setInfo] = react_8('');
    const [highlightRef, setHighlightRef] = react_8('');
    const [highlightMask, setHighlightMask] = react_8(false);
    const [showAtoms, setShowAtoms] = react_8(true);
    const [showAsymBonds, setShowAsymBonds] = react_8(true);
    const [showBonds, setShowBonds] = react_8(true);
    const [showVertices, setShowVertices] = react_8(true);
    const [showEdges, setShowEdges] = react_8(true);
    const [showFaces, setShowFaces] = react_8(true);
    const [showODs, setShowODs] = react_8(true);
    const refCanvas = react_9(
      canvas => {
        if (canvas !== null) {
          qcweb2CoreHandler.current = new QCWeb2CoreHandler(
            canvas,
            store,
            overlayPanelSelector,
            quasicrystalSelector,
            overlayPanelSetData,
            {
              fps: fps => setFps(fps),
              showAtoms: showAtoms => setShowAtoms(showAtoms),
              showAsymBonds: showAsymBonds => setShowAsymBonds(showAsymBonds),
              showBonds: showBonds => setShowBonds(showBonds),
              showVertices: showVertices => setShowVertices(showVertices),
              showEdges: showEdges => setShowEdges(showEdges),
              showFaces: showFaces => setShowFaces(showFaces),
              showODs: showODs => setShowODs(showODs),
              cameraOrthographic:
                orthographic => setCameraIsOrthographic(orthographic),
              infoString: info => setInfo(info),
              highlightRefString: highlightRef => setHighlightRef(highlightRef),
              highlightMask: highlightMask => setHighlightMask(highlightMask)
            }
          );
        } else if (qcweb2CoreHandler.current) {
          qcweb2CoreHandler.current.destructor();
          qcweb2CoreHandler.current = null;
        }
      },
      []
    );
    const qcweb2Canvas = react_13(
      () => react.createElement(
        'canvas',
        {
          ref: refCanvas,
          className: CANVAS_CLASS_NAME,
          onMouseDown: e =>
            qcweb2CoreHandler.current &&
            qcweb2CoreHandler.current.onMouseDown(e),
          onMouseUp: e =>
            qcweb2CoreHandler.current &&
            qcweb2CoreHandler.current.onMouseUp(e),
          onMouseMove: e =>
            qcweb2CoreHandler.current &&
            qcweb2CoreHandler.current.onMouseMove(e),
          onMouseLeave: e =>
            qcweb2CoreHandler.current &&
            qcweb2CoreHandler.current.onMouseLeave(e),
          onMouseEnter: e =>
            qcweb2CoreHandler.current &&
            qcweb2CoreHandler.current.onMouseEnter(e),
          onDoubleClick: e =>
            qcweb2CoreHandler.current &&
            qcweb2CoreHandler.current.onDoubleClick(e),
          onWheel: e =>
            qcweb2CoreHandler.current &&
            qcweb2CoreHandler.current.onWheel(e)
        },
        'The HTML <canvas> element is not supported.'
      ),
      []
    );
    const main = react_13(
      () => react.createElement(OverlayPanel, null, qcweb2Canvas),
      []
    );
    const control = react_13(
      () => react.createElement(
        'div',
        { className: VIEWER_CONTROL_CLASS_NAME },
        react.createElement(VSplitButton),
        react.createElement(HSplitButton),
        react.createElement(
          SwitchBox,
          {
            className: 'show-atoms',
            title: 'show atoms',
            on: showAtoms,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleShowAtoms()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'show-asym-bonds',
            title: 'show asym bonds',
            on: showAsymBonds,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleShowAsymBonds()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'show-bonds',
            title: 'show bonds',
            on: showBonds,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleShowBonds()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'show-vertices',
            title: 'show cluster vertices',
            on: showVertices,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleShowVertices()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'show-edges',
            title: 'show cluster edges',
            on: showEdges,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleShowEdges()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'show-faces',
            title: 'show cluster faces',
            on: showFaces,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleShowFaces()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'show-ods',
            title: 'show occupation domains',
            on: showODs,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleShowODs()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: CAMERA_IS_ORTHOGRAPHIC_CLASS_NAME,
            title: 'toggle projection mode',
            on: cameraIsOrthographic,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleCameraProjectionMode()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'reset-origin',
            title: 'reset origin',
            on: true,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.resetOrigin()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'camera-par',
            title: 'set parallel camera',
            on: true,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.setCameraPar()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'camera-perp',
            title: 'set perpendicular camera',
            on: true,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.setCameraPerp()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'od-base-opacity',
            title: 'set od base opacity',
            on: true,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.setODBaseOpacity()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'info-type',
            title: 'info: type',
            on: highlightMask.type,
            value: info.type,
            onValue: highlightRef.type,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleHighlightMaskType()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'info-od',
            title: 'info: od',
            on: highlightMask.od,
            value: info.odLabel,
            onValue: highlightRef.odLabel,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleHighlightMaskOD()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'info-ssg',
            title: 'info: ssg',
            on: highlightMask.ssg,
            value: info.ssgId,
            onValue: highlightRef.ssgId,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleHighlightMaskSSG()
          }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'info-latt',
            title: 'info: lattice',
            on: highlightMask.latt,
            value: info.lattFractCoord,
            onValue: highlightRef.lattFractCoord,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.toggleHighlightMaskLatt()
          }
        ),
        react.createElement(
          SwitchBox, { className: FPS_CLASS_NAME, value: fps }
        ),
        react.createElement(
          SwitchBox,
          {
            className: 'show-help',
            title: 'show help',
            on: true,
            onClick: () =>
              qcweb2CoreHandler.current &&
              qcweb2CoreHandler.current.showHelp()
          }
        )
      ),
      [
        fps,
        cameraIsOrthographic,
        info,
        highlightRef,
        highlightMask,
        showAtoms,
        showAsymBonds,
        showBonds,
        showVertices,
        showEdges,
        showFaces,
        showODs
      ]
    );
    return react_13(
      () => react.createElement(
        'div',
        { className: VIEWER_CLASS_NAME },
        main,
        control
      ),
      [control]
    )
  };
  return QCWeb2Viewer
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// actions
const SET_CATEGORY_DATA = 'SET_CATEGORY_DATA';
const RESET_QC_DATA = 'RESET_QC_DATA';

// action creator creators

// If packet is null and index is a valid index,
// then the packet at index is removed from the category.
// If an invalid index is supplied, then the packet is treated as a new packet.
const setCategoryDataCreator = (
  prefix = ''
) => (
  categoryId, packet, index
) => ({
  type: prefix + SET_CATEGORY_DATA,
  payload: {
    categoryId: categoryId.toLowerCase(),
    packet,
    index
  }
});

const resetQCDataCreator = (
  prefix = ''
) => (
  data
) => ({
  type: prefix + RESET_QC_DATA,
  payload: { data }
});

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const rnum$5 = new RealAlgebra(1e-10);
const lnum$5 = new LinearAlgebra(rnum$5);

const newMatrix = (dimension, array = null) => {
  if (!dimension) {
    return false
  }
  const len = dimension.reduce((n, dim) => n * dim, 1);
  if (!Array.isArray(array)) {
    const mat = lnum$5.$();
    for (let i = 0; i < len; i += 1) {
      mat.push(NaN);
    }
    mat.setDim(...dimension);
    return mat
  }
  if (
    array.length !== len ||
    array.some(elem => elem === false)
  ) {
    return false
  }
  {
    const mat = lnum$5.$();
    for (const elm of array) {
      mat.push(typeof elm === 'number' ? elm : NaN);
    }
    mat.setDim(...dimension);
    return mat
  }
};

const identity = n => lnum$5.$(
  ...Array.from(
    { length: n * n },
    (x, i) => {
      const iCol = i % n;
      const iRow = (i - iCol) / n;
      return iCol === iRow ? 1 : 0
    }
  )
).setDim(n, n);

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const newDimension = (...dimItems) => {
  if (
    dimItems.length === 0 ||
    dimItems.some(dim =>
      dim.alert ||
      !Number.isInteger(dim.value) ||
      dim.value < 0
    )
  ) {
    return false
  } else {
    return dimItems.map(dim => dim.value)
  }
};

const currentRow = (loopCat, packet) => {
  const index = loopCat.indexOf(packet);
  return index === -1 ? false : index
};

const qcDict = new MultiKeyMap([
  [
    ['Categories'],
    new Set([
      'cell',
      // 'superspace_group',
      'superspace_group_symop',
      'atom_site',
      // 'model_site',
      'asym_bond',
      'geom_bond',
      'cluster_vertex',
      'cluster_edge',
      'cluster_face',
      'occupation_domain'
    ])
  ], [
    ['cell', false],
    new MultiKeyMap([
      [['definition', 'class'], 'set'],
      [
        ['Items'],
        new Set([
          'parallel_space_dimension',
          'perpendicular_space_dimension',
          'superspace_dimension',
          'basis_parallel_no_strain',
          'basis_perpendicular_no_strain',
          'origin_fract',
          'linear_phason_strain_matrix',
          'basis_no_strain',
          'reciprocal_basis_no_strain',
          'reciprocal_basis_perpendicular_no_strain',
          'basis_parallel',
          'basis_perpendicular',
          'basis',
          'reciprocal_basis'
        ])
      ]
    ])
  ], [
    ['superspace_group', false],
    new MultiKeyMap([
      [['definition', 'class'], 'set'],
      [
        ['Items'],
        new Set([
          'multiplicity',
          'multiplication_table_symop_id'
        ])
      ]
    ])
  ], [
    ['superspace_group_symop', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'id',
          'r',
          't',
          'r_perpendicular_no_strain',
          't_perpendicular_no_strain'
        ])
      ]
    ])
  ], [
    ['atom_site', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'label',
          'fract_coord'
        ])
      ], [
        ['method', 'Validation'],
        {
          function: (target, def, deps, dict, data) => {
            if (target.value === null) {
              return ''
            }
            const set = new Set();
            for (const packet of target.value) {
              const label = selectDataItem(
                dict, data, 'occupation_domain', 'label', packet
              );
              const folded = toCanonicalCaseFold(label.value);
              if (set.has(folded)) {
                const str = folded === null
                  ? '?'
                  : folded === false
                    ? '.'
                    : folded;
                return `Alert A: labels are not unique (e.g. ${str}).`
              } else {
                set.add(folded);
              }
            }
            return ''
          },
          dependencies: [] // should be ['atom_site', 'label'], but will cause infinite loop
        }
      ]
    ])
  ], [
    ['model_site', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'label',
          'symop_id',
          'fract_coord'
        ])
      ], [
        ['method', 'Evaluation'],
        {
          function: (deps, def, dict, data) => {
            const [
              { alert },
              { value: labels },
              { value: fractCoords },
              { value: r },
              { value: t },
              { value: ssgId }
            ] = deps;
            const ssgOrder = r.length;
            if (alert || ssgOrder === 0) {
              return evaluatedItem([])
            }
            const modelSite = [];
            for (let i = 0, n = labels.length; i < n; i += 1) {
              const label = labels[i].value;
              const p = fractCoords[i].value;
              const eqvPos = [];
              for (let j = 0; j < ssgOrder; j += 1) {
                const rj = r[j].value;
                const tj = t[j].value;
                const idj = ssgId[j].value;
                const pj = p && rj && tj
                  ? lnum$5.iadd(lnum$5.mmul(rj, p), tj)
                  : false;
                if (eqvPos.every(({ p: pk }, k) => {
                  if ((!pj && !pk) || lnum$5.isInteger(lnum$5.sub(pj, pk))) {
                    eqvPos[k].symop.push(idj);
                    return false
                  }
                  return true
                })) {
                  eqvPos.push({ p: pj, symop: [idj] });
                }
              }
              modelSite.push(
                ...eqvPos.map(
                  eqvPosI => {
                    return new Map([
                      ['label', evaluatedItem(label)],
                      ['symop_id', evaluatedItem(eqvPosI.symop)],
                      ['fract_coord', evaluatedItem(eqvPosI.p)]
                    ])
                  }
                )
              );
            }
            return evaluatedItem(modelSite)
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label'],
            ['atom_site', 'fract_coord'],
            ['superspace_group_symop', 'r'],
            ['superspace_group_symop', 't'],
            ['superspace_group_symop', 'id']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: model_site may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['asym_bond', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'atom_site_label_1',
          'symop_id_1',
          'cell_translation_1',
          'atom_site_label_2',
          'symop_id_2',
          'cell_translation_2'
        ])
      ]
    ])
  ], [
    ['geom_bond', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'atom_site_label_1',
          'symop_id_1',
          'cell_translation_1',
          'atom_site_label_2',
          'symop_id_2',
          'cell_translation_2'
        ])
      ]
    ])
  ], [
    ['cluster_vertex', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'atom_site_label',
          'symop_id',
          'cell_translation',
          'atom_site_label_1',
          'symop_id_1',
          'cell_translation_1'
        ])
      ]
    ])
  ], [
    ['cluster_edge', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'atom_site_label',
          'symop_id',
          'cell_translation',
          'atom_site_label_1',
          'symop_id_1',
          'cell_translation_1',
          'atom_site_label_2',
          'symop_id_2',
          'cell_translation_2'
        ])
      ]
    ])
  ], [
    ['cluster_face', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'atom_site_label',
          'symop_id',
          'cell_translation',
          'atom_site_label_1',
          'symop_id_1',
          'cell_translation_1',
          'atom_site_label_2',
          'symop_id_2',
          'cell_translation_2',
          'atom_site_label_3',
          'symop_id_3',
          'cell_translation_3'
        ])
      ]
    ])
  ], [
    ['occupation_domain', false],
    new MultiKeyMap([
      [['definition', 'class'], 'loop'],
      [
        ['Items'],
        new Set([
          'label',
          'atom_site_label',
          // 'polytope_asymmetric_unit',
          'display_colour',
          'display_opacity',
          'display_radius'
        ])
      ], [
        ['method', 'Validation'],
        {
          function: (target, def, deps, dict, data) => {
            if (target.value === null) {
              return ''
            }
            const set = new Set();
            for (const packet of target.value) {
              const label = selectDataItem(
                dict, data, 'occupation_domain', 'label', packet
              );
              const folded = toCanonicalCaseFold(label.value);
              if (set.has(folded)) {
                const str =
                  folded === null
                    ? '?'
                    : folded === false
                      ? '.'
                      : folded;
                return `Alert A: labels are not unique (e.g. ${str}).`
              } else {
                set.add(folded);
              }
            }
            return ''
          },
          dependencies: [] // should be ['occupation_domain', 'label'], but will cause infinite loop
        }
      ]
    ])
  ], [
    ['cell', 'parallel_space_dimension'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [['enumeration', 'range'], [1, 3]],
      [['enumeration', 'default'], defaultItem(3)]
    ])
  ], [
    ['cell', 'perpendicular_space_dimension'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [['enumeration', 'range'], [0, 3]],
      [['enumeration', 'default'], defaultItem(0)]
    ])
  ], [
    ['cell', 'superspace_dimension'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Evaluation'],
        {
          function: deps => {
            const [{ value: dimPar }, { value: dimPerp }] = deps;
            return evaluatedItem(dimPar + dimPerp)
          },
          dependencies: [
            ['cell', 'parallel_space_dimension'],
            ['cell', 'perpendicular_space_dimension']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: superspace_dimension may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['cell', 'basis_parallel_no_strain'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dimPar, dim] = deps;
            const dimension = newDimension(dimPar, dim);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'parallel_space_dimension'],
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cell', 'basis_perpendicular_no_strain'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dimPerp, dim] = deps;
            const dimension = newDimension(dimPerp, dim);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'perpendicular_space_dimension'],
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cell', 'basis_no_strain'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension = newDimension(dim, dim);
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: (deps, def) => {
            const [
              { value: aParNoStrain },
              { value: aPerpNoStrain }
            ] = deps;
            const dimension = def.get(['type', 'dimension']);
            const a = newMatrix(dimension, aParNoStrain.concat(aPerpNoStrain));
            return evaluatedItem(a)
          },
          dependencies: [
            ['cell', 'basis_parallel_no_strain'],
            ['cell', 'basis_perpendicular_no_strain']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: basis_no_strain may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['cell', 'reciprocal_basis_no_strain'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension = newDimension(dim, dim);
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: (deps, def) => {
            const [
              { value: aNoStrain }
            ] = deps;
            const dimension = def.get(['type', 'dimension']);
            const aLU = lnum$5.lup(aNoStrain);
            let bNoStrain;
            if (aLU.length > 0 && aLU[0] === 0) {
              // singular
              bNoStrain = newMatrix(dimension);
            } else {
              bNoStrain = lnum$5.isolve(aLU, identity(dimension[0]));
            }
            return evaluatedItem(bNoStrain)
          },
          dependencies: [
            ['cell', 'basis_no_strain']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: reciprocal_basis_no_strain may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['cell', 'reciprocal_basis_perpendicular_no_strain'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim, dimPerp] = deps;
            const dimension = newDimension(dim, dimPerp);
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension'],
            ['cell', 'perpendicular_space_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: (deps, def) => {
            const [
              { value: bNoStrain }
            ] = deps;
            const dimension = def.get(['type', 'dimension']);
            const colStart = dimension[0] - dimension[1];
            const bPerpNoStrain = newMatrix(
              dimension,
              bNoStrain.filter((x, i) => i % dimension[0] >= colStart)
            );
            return evaluatedItem(bPerpNoStrain)
          },
          dependencies: [
            ['cell', 'reciprocal_basis_no_strain']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: reciprocal_basis_perpendicular_no_strain may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['cell', 'origin_fract'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension = newDimension(dim);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cell', 'linear_phason_strain_matrix'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dimPerp, dimPar] = deps;
            const dimension = newDimension(dimPerp, dimPar);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'perpendicular_space_dimension'],
            ['cell', 'parallel_space_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cell', 'basis_parallel'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dimPar, dim] = deps;
            const dimension = newDimension(dimPar, dim);
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension]
            ])
          },
          dependencies: [
            ['cell', 'parallel_space_dimension'],
            ['cell', 'superspace_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: deps => {
            const [{ value: aParNoStrain }] = deps;
            return evaluatedItem(aParNoStrain)
          },
          dependencies: [
            ['cell', 'basis_parallel_no_strain']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: basis_parallel may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['cell', 'basis_perpendicular'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dimPerp, dim] = deps;
            const dimension = newDimension(dimPerp, dim);
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension]
            ])
          },
          dependencies: [
            ['cell', 'perpendicular_space_dimension'],
            ['cell', 'superspace_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: deps => {
            const [
              { value: aParNoStrain },
              { value: aPerpNoStrain },
              { value: phsMat }
            ] = deps;
            const aPerp = lnum$5.iadd(
              lnum$5.mmul(phsMat, aParNoStrain), aPerpNoStrain
            );
            return evaluatedItem(aPerp)
          },
          dependencies: [
            ['cell', 'basis_parallel_no_strain'],
            ['cell', 'basis_perpendicular_no_strain'],
            ['cell', 'linear_phason_strain_matrix']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: basis_perpendicular may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['cell', 'basis'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension = newDimension(dim, dim);
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: (deps, def) => {
            const [
              { value: aPar },
              { value: aPerp }
            ] = deps;
            const dimension = def.get(['type', 'dimension']);
            const a = newMatrix(dimension, aPar.concat(aPerp));
            return evaluatedItem(a)
          },
          dependencies: [
            ['cell', 'basis_parallel'],
            ['cell', 'basis_perpendicular']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: basis may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['cell', 'reciprocal_basis'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension = newDimension(dim, dim);
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: (deps, def) => {
            const [
              { value: a }
            ] = deps;
            const dimension = def.get(['type', 'dimension']);
            const aLU = lnum$5.lup(a);
            let b;
            if (aLU.length > 0 && aLU[0] === 0) {
              // singular
              b = newMatrix(dimension);
            } else {
              b = lnum$5.isolve(aLU, identity(dimension[0]));
            }
            return evaluatedItem(b)
          },
          dependencies: [
            ['cell', 'basis']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: reciprocal_basis may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['superspace_group', 'multiplicity'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Evaluation'],
        {
          function: (deps, def) => {
            const [
              { value: symops }
            ] = deps;
            return evaluatedItem(symops.length)
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      // ], [
      //   ['method', 'Validation'],
      //   {
      //     function: () => 'Throw: multiplicity may not be assigned.',
      //     dependencies: []
      //   }
      ]
    ])
  ], [
    ['superspace_group', 'multiplication_table_symop_id'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [mult] = deps;
            const dimension = newDimension(mult, mult);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['superspace_group', 'multiplicity']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: (deps, def) => {
            const [
              { value: r },
              { value: t },
              { value: ssgId }
            ] = deps;
            const dimension = def.get(['type', 'dimension']);
            const mult = dimension[0];
            const arr = [];
            for (let i = 0; i < mult; i += 1) {
              for (let j = 0; j < mult; j += 1) {
                const rij = lnum$5.mmul(r[i].value, r[j].value);
                const tij =
                  lnum$5.add(lnum$5.mmul(r[i].value, t[j].value), t[i].value);
                let found = false;
                for (let k = 0; k < mult; k += 1) {
                  if (
                    lnum$5.eq(rij, r[k].value) &&
                    lnum$5.isInteger(lnum$5.sub(tij, t[k].value))
                  ) {
                    found = true;
                    arr.push(ssgId[k].value);
                    break
                  }
                }
                if (!found) {
                  return evaluatedItem(false)
                }
              }
            }
            return evaluatedItem(newMatrix(dimension, arr))
          },
          dependencies: [
            ['superspace_group_symop', 'r'],
            ['superspace_group_symop', 't'],
            ['superspace_group_symop', 'id']
          ]
        }
      // ], [
      //   ['method', 'Validation'],
      //   {
      //     function: () => 'Throw: multiplication_table_symop_id may not be assigned.',
      //     dependencies: []
      //   }
      ]
    ])
  ], [
    ['superspace_group_symop', 'id'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [['enumeration', 'range'], [1, Infinity]],
      [
        ['method', 'Evaluation'],
        {
          function: (deps, def, dict, data, currentPacket) => {
            const [{ value: ssgSymop }] = deps;
            const index = currentRow(ssgSymop, currentPacket);
            if (index === false) {
              return evaluatedItem(false)
            } else {
              return evaluatedItem(index + 1)
            }
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: id may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['superspace_group_symop', 'r'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension = newDimension(dim, dim);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['superspace_group_symop', 't'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension = newDimension(dim);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['superspace_group_symop', 'r_perpendicular_no_strain'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dimPerp] = deps;
            const dimension = newDimension(dimPerp, dimPerp);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'perpendicular_space_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: deps => {
            const [
              { value: r },
              { value: aPerpNoStrain },
              { value: bPerpNoStrain }
            ] = deps;
            const rPerpNoStrain = lnum$5.mmul(
              lnum$5.mmul(aPerpNoStrain, r), bPerpNoStrain
            );
            return evaluatedItem(rPerpNoStrain)
          },
          dependencies: [
            ['superspace_group_symop', 'r'],
            ['cell', 'basis_perpendicular_no_strain'],
            ['cell', 'reciprocal_basis_perpendicular_no_strain']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: r_perpendicular_no_strain may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['superspace_group_symop', 't_perpendicular_no_strain'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dimPerp] = deps;
            const dimension = newDimension(dimPerp);
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'perpendicular_space_dimension']
          ]
        }
      ], [
        ['method', 'Evaluation'],
        {
          function: deps => {
            const [
              { value: t },
              { value: aPerpNoStrain }
            ] = deps;
            const tPerpNoStrain = lnum$5.mmul(aPerpNoStrain, t);
            return evaluatedItem(tPerpNoStrain)
          },
          dependencies: [
            ['superspace_group_symop', 't'],
            ['cell', 'basis_perpendicular_no_strain']
          ]
        }
      ], [
        ['method', 'Validation'],
        {
          function: () => 'Throw: t_perpendicular_no_strain may not be assigned.',
          dependencies: []
        }
      ]
    ])
  ], [
    ['atom_site', 'label'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code']
    ])
  ], [
    ['atom_site', 'fract_coord'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['model_site', 'label'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code']
    ])
  ], [
    ['model_site', 'symop_id'],
    new MultiKeyMap([
      [['type', 'container'], 'list'],
      [['type', 'contents'], 'integer'],
      [['type', 'dimension'], []]
    ])
  ], [
    ['model_site', 'fract_coord'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'real'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['asym_bond', 'atom_site_label_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['asym_bond', 'symop_id_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['asym_bond', 'cell_translation_1'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['asym_bond', 'atom_site_label_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['asym_bond', 'symop_id_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['asym_bond', 'cell_translation_2'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['geom_bond', 'atom_site_label_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['geom_bond', 'symop_id_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['geom_bond', 'cell_translation_1'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['geom_bond', 'atom_site_label_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['geom_bond', 'symop_id_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['geom_bond', 'cell_translation_2'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_vertex', 'atom_site_label'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_vertex', 'symop_id'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_vertex', 'cell_translation'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_vertex', 'atom_site_label_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_vertex', 'symop_id_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_vertex', 'cell_translation_1'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'atom_site_label'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'symop_id'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'cell_translation'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'atom_site_label_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'symop_id_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'cell_translation_1'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'atom_site_label_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'symop_id_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_edge', 'cell_translation_2'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'atom_site_label'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'symop_id'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'cell_translation'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'atom_site_label_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'symop_id_1'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'cell_translation_1'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'atom_site_label_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'symop_id_2'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'cell_translation_2'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'atom_site_label_3'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false],
            ['atom_site', 'label']
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'symop_id_3'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: ssgSymops }] = deps;
            const enumSetState = [];
            if (ssgSymops) {
              enumSetState.push(
                ...ssgSymops.map(
                  packet => selectDataItem(
                    dict, data, 'superspace_group_symop', 'id', packet
                  ).value
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['superspace_group_symop', false]
          ]
        }
      ]
    ])
  ], [
    ['cluster_face', 'cell_translation_3'],
    new MultiKeyMap([
      [['type', 'container'], 'matrix'],
      [['type', 'contents'], 'integer'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr) => {
            const [dim] = deps;
            const dimension =
              (!dim.alert && Number.isFinite(dim.value))
                ? [dim.value]
                : false;
            const enumDefault = defaultItem(newMatrix(dimension));
            return new MultiKeyMap([
              ...attr,
              [['type', 'dimension'], dimension],
              [['enumeration', 'default'], enumDefault]
            ])
          },
          dependencies: [
            ['cell', 'superspace_dimension']
          ]
        }
      ]
    ])
  ], [
    ['occupation_domain', 'label'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code']
    ])
  ], [
    ['occupation_domain', 'atom_site_label'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'code'],
      [
        ['method', 'Definition'],
        {
          function: (deps, attr, dict, data) => {
            const [{ value: atomSites }] = deps;
            const enumSetState = [];
            if (atomSites) {
              enumSetState.push(
                ...atomSites.map(
                  packet => toCanonicalCaseFold(selectDataItem(
                    dict, data, 'atom_site', 'label', packet
                  ).value)
                )
              );
            }
            return new MultiKeyMap([
              ...attr,
              [['enumeration_set', 'state'], enumSetState]
            ])
          },
          dependencies: [
            ['atom_site', false]
          ]
        }
      ]
    ])
  ], [
    ['occupation_domain', 'polytope_asymmetric_unit'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'polytope']
    ])
  ], [
    ['occupation_domain', 'simplices_asymmetric_unit'],
    new MultiKeyMap([
      [['type', 'container'], 'list'],
      [['type', 'contents'], 'array']
    ])
  ], [
    ['occupation_domain', 'display_colour'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'colour'],
      [['enumeration', 'default'], defaultItem('#000000')]
    ])
  ], [
    ['occupation_domain', 'display_opacity'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'real'],
      [['enumeration', 'default'], defaultItem(1.0)]
    ])
  ], [
    ['occupation_domain', 'display_radius'],
    new MultiKeyMap([
      [['type', 'container'], 'single'],
      [['type', 'contents'], 'real'],
      [['enumeration', 'default'], defaultItem(1.0)]
    ])
  ]
]);

const qcEmptyData = new Map();

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const initialState$1 = {
  dictionary: qcDict,
  data: qcEmptyData
};

const quasicrystal = (state = initialState$1, action = {}) => {
  switch (action.type) {
    case RESET_QC_DATA: {
      return {
        ...state,
        data: action.payload.data
      }
    }
    case SET_CATEGORY_DATA: {
      const dict = state.dictionary;
      if (!dict) {
        return state
      }
      const data = state.data;
      const payload = action.payload;
      const catId = payload.categoryId;
      const packet = payload.packet;
      const catDef = selectDefinition(dict, data, catId);
      const catClass = catDef.get(['definition', 'class']);
      switch (catClass) {
        case 'loop': {
          const index = payload.index;
          const cat = selectDataItem(dict, data, catId).value;
          let nextCat;
          if (Number.isInteger(index) && index >= 0 && index < cat.length) {
            if (packet === null) {
              // remove a packet
              nextCat = cat.filter((x, i) => i !== index);
            } else {
              // update a packet
              nextCat = cat.map(
                (x, i) => i === index ? new Map([...x, ...packet]) : x
              );
            }
          } else {
            // treated as a new packet
            if (packet === null) {
              // remove the new packet?, ignore
              return state
            } else {
              // add a packet
              nextCat = cat.concat(packet);
            }
          }
          return {
            ...state,
            data: new Map([...data, [catId, nextCat]])
          }
        }
        case 'set': {
          const cat = selectDataItem(dict, data, catId).value;
          const nextCat = new Map([...cat, ...packet]);
          return {
            ...state,
            data: new Map([...data, [catId, nextCat]])
          }
        }
        default: {
          // ignore categories other than 'set' and 'loop'
          return state
        }
      }
    }
    default: {
      return state
    }
  }
};

/* @license-end */

function makeTypeChecker(tabsRole) {
  return function (element) {
    return !!element.type && element.type.tabsRole === tabsRole;
  };
}

var isTab = makeTypeChecker('Tab');
var isTabList = makeTypeChecker('TabList');
var isTabPanel = makeTypeChecker('TabPanel');

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function isTabChild(child) {
  return isTab(child) || isTabList(child) || isTabPanel(child);
}

function deepMap(children, callback) {
  return react_4.map(children, function (child) {
    // null happens when conditionally rendering TabPanel/Tab
    // see https://github.com/reactjs/react-tabs/issues/37
    if (child === null) return null;

    if (isTabChild(child)) {
      return callback(child);
    }

    if (child.props && child.props.children && typeof child.props.children === 'object') {
      // Clone the child that has children and map them too
      return /*#__PURE__*/react_5(child, _extends({}, child.props, {
        children: deepMap(child.props.children, callback)
      }));
    }

    return child;
  });
}
function deepForEach(children, callback) {
  return react_4.forEach(children, function (child) {
    // null happens when conditionally rendering TabPanel/Tab
    // see https://github.com/reactjs/react-tabs/issues/37
    if (child === null) return;

    if (isTab(child) || isTabPanel(child)) {
      callback(child);
    } else if (child.props && child.props.children && typeof child.props.children === 'object') {
      if (isTabList(child)) callback(child);
      deepForEach(child.props.children, callback);
    }
  });
}

function toVal(mix) {
	var k, y, str='';

	if (typeof mix === 'string' || typeof mix === 'number') {
		str += mix;
	} else if (typeof mix === 'object') {
		if (Array.isArray(mix)) {
			for (k=0; k < mix.length; k++) {
				if (mix[k]) {
					if (y = toVal(mix[k])) {
						str && (str += ' ');
						str += y;
					}
				}
			}
		} else {
			for (k in mix) {
				if (mix[k]) {
					str && (str += ' ');
					str += k;
				}
			}
		}
	}

	return str;
}

function cx () {
	var i=0, tmp, x, str='';
	while (i < arguments.length) {
		if (tmp = arguments[i++]) {
			if (x = toVal(tmp)) {
				str && (str += ' ');
				str += x;
			}
		}
	}
	return str;
}

// Get a universally unique identifier
var count = 0;
function uuid() {
  return "react-tabs-" + count++;
}

function getTabsCount(children) {
  var tabCount = 0;
  deepForEach(children, function (child) {
    if (isTab(child)) tabCount++;
  });
  return tabCount;
}
function getPanelsCount(children) {
  var panelCount = 0;
  deepForEach(children, function (child) {
    if (isTabPanel(child)) panelCount++;
  });
  return panelCount;
}

var _excluded = ["children", "className", "disabledTabClassName", "domRef", "focus", "forceRenderTabPanel", "onSelect", "selectedIndex", "selectedTabClassName", "selectedTabPanelClassName", "environment", "disableUpDownKeys"];

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function isNode(node) {
  return node && 'getAttribute' in node;
} // Determine if a node from event.target is a Tab element


function isTabNode(node) {
  return isNode(node) && node.getAttribute('data-rttab');
} // Determine if a tab node is disabled


function isTabDisabled(node) {
  return isNode(node) && node.getAttribute('aria-disabled') === 'true';
}

var canUseActiveElement;

function determineCanUseActiveElement(environment) {
  var env = environment || (typeof window !== 'undefined' ? window : undefined);

  try {
    canUseActiveElement = !!(typeof env !== 'undefined' && env.document && env.document.activeElement);
  } catch (e) {
    // Work around for IE bug when accessing document.activeElement in an iframe
    // Refer to the following resources:
    // http://stackoverflow.com/a/10982960/369687
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12733599
    canUseActiveElement = false;
  }
}

var UncontrolledTabs = /*#__PURE__*/function (_Component) {
  _inheritsLoose(UncontrolledTabs, _Component);

  function UncontrolledTabs() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.tabNodes = [];

    _this.handleKeyDown = function (e) {
      var _this$props = _this.props,
          direction = _this$props.direction,
          disableUpDownKeys = _this$props.disableUpDownKeys;

      if (_this.isTabFromContainer(e.target)) {
        var index = _this.props.selectedIndex;
        var preventDefault = false;
        var useSelectedIndex = false;

        if (e.keyCode === 32 || e.keyCode === 13) {
          preventDefault = true;
          useSelectedIndex = false;

          _this.handleClick(e);
        }

        if (e.keyCode === 37 || !disableUpDownKeys && e.keyCode === 38) {
          // Select next tab to the left, validate if up arrow is not disabled
          if (direction === 'rtl') {
            index = _this.getNextTab(index);
          } else {
            index = _this.getPrevTab(index);
          }

          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 39 || !disableUpDownKeys && e.keyCode === 40) {
          // Select next tab to the right, validate if down arrow is not disabled
          if (direction === 'rtl') {
            index = _this.getPrevTab(index);
          } else {
            index = _this.getNextTab(index);
          }

          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 35) {
          // Select last tab (End key)
          index = _this.getLastTab();
          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 36) {
          // Select first tab (Home key)
          index = _this.getFirstTab();
          preventDefault = true;
          useSelectedIndex = true;
        } // This prevents scrollbars from moving around


        if (preventDefault) {
          e.preventDefault();
        } // Only use the selected index in the state if we're not using the tabbed index


        if (useSelectedIndex) {
          _this.setSelected(index, e);
        }
      }
    };

    _this.handleClick = function (e) {
      var node = e.target;

      do {
        if (_this.isTabFromContainer(node)) {
          if (isTabDisabled(node)) {
            return;
          }

          var index = [].slice.call(node.parentNode.children).filter(isTabNode).indexOf(node);

          _this.setSelected(index, e);

          return;
        }
      } while ((node = node.parentNode) != null);
    };

    return _this;
  }

  var _proto = UncontrolledTabs.prototype;

  _proto.setSelected = function setSelected(index, event) {
    // Check index boundary
    if (index < 0 || index >= this.getTabsCount()) return;
    var _this$props2 = this.props,
        onSelect = _this$props2.onSelect,
        selectedIndex = _this$props2.selectedIndex; // Call change event handler

    onSelect(index, selectedIndex, event);
  };

  _proto.getNextTab = function getNextTab(index) {
    var count = this.getTabsCount(); // Look for non-disabled tab from index to the last tab on the right

    for (var i = index + 1; i < count; i++) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // If no tab found, continue searching from first on left to index


    for (var _i = 0; _i < index; _i++) {
      if (!isTabDisabled(this.getTab(_i))) {
        return _i;
      }
    } // No tabs are disabled, return index


    return index;
  };

  _proto.getPrevTab = function getPrevTab(index) {
    var i = index; // Look for non-disabled tab from index to first tab on the left

    while (i--) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // If no tab found, continue searching from last tab on right to index


    i = this.getTabsCount();

    while (i-- > index) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // No tabs are disabled, return index


    return index;
  };

  _proto.getFirstTab = function getFirstTab() {
    var count = this.getTabsCount(); // Look for non disabled tab from the first tab

    for (var i = 0; i < count; i++) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    }

    return null;
  };

  _proto.getLastTab = function getLastTab() {
    var i = this.getTabsCount(); // Look for non disabled tab from the last tab

    while (i--) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    }

    return null;
  };

  _proto.getTabsCount = function getTabsCount$1() {
    var children = this.props.children;
    return getTabsCount(children);
  };

  _proto.getPanelsCount = function getPanelsCount$1() {
    var children = this.props.children;
    return getPanelsCount(children);
  };

  _proto.getTab = function getTab(index) {
    return this.tabNodes["tabs-" + index];
  };

  _proto.getChildren = function getChildren() {
    var _this2 = this;

    var index = 0;
    var _this$props3 = this.props,
        children = _this$props3.children,
        disabledTabClassName = _this$props3.disabledTabClassName,
        focus = _this$props3.focus,
        forceRenderTabPanel = _this$props3.forceRenderTabPanel,
        selectedIndex = _this$props3.selectedIndex,
        selectedTabClassName = _this$props3.selectedTabClassName,
        selectedTabPanelClassName = _this$props3.selectedTabPanelClassName,
        environment = _this$props3.environment;
    this.tabIds = this.tabIds || [];
    this.panelIds = this.panelIds || [];
    var diff = this.tabIds.length - this.getTabsCount(); // Add ids if new tabs have been added
    // Don't bother removing ids, just keep them in case they are added again
    // This is more efficient, and keeps the uuid counter under control

    while (diff++ < 0) {
      this.tabIds.push(uuid());
      this.panelIds.push(uuid());
    } // Map children to dynamically setup refs


    return deepMap(children, function (child) {
      var result = child; // Clone TabList and Tab components to have refs

      if (isTabList(child)) {
        var listIndex = 0; // Figure out if the current focus in the DOM is set on a Tab
        // If it is we should keep the focus on the next selected tab

        var wasTabFocused = false;

        if (canUseActiveElement == null) {
          determineCanUseActiveElement(environment);
        }

        if (canUseActiveElement) {
          wasTabFocused = react.Children.toArray(child.props.children).filter(isTab).some(function (tab, i) {
            var env = environment || (typeof window !== 'undefined' ? window : undefined);
            return env && env.document.activeElement === _this2.getTab(i);
          });
        }

        result = /*#__PURE__*/react_5(child, {
          children: deepMap(child.props.children, function (tab) {
            var key = "tabs-" + listIndex;
            var selected = selectedIndex === listIndex;
            var props = {
              tabRef: function tabRef(node) {
                _this2.tabNodes[key] = node;
              },
              id: _this2.tabIds[listIndex],
              panelId: _this2.panelIds[listIndex],
              selected: selected,
              focus: selected && (focus || wasTabFocused)
            };
            if (selectedTabClassName) props.selectedClassName = selectedTabClassName;
            if (disabledTabClassName) props.disabledClassName = disabledTabClassName;
            listIndex++;
            return /*#__PURE__*/react_5(tab, props);
          })
        });
      } else if (isTabPanel(child)) {
        var props = {
          id: _this2.panelIds[index],
          tabId: _this2.tabIds[index],
          selected: selectedIndex === index
        };
        if (forceRenderTabPanel) props.forceRender = forceRenderTabPanel;
        if (selectedTabPanelClassName) props.selectedClassName = selectedTabPanelClassName;
        index++;
        result = /*#__PURE__*/react_5(child, props);
      }

      return result;
    });
  };

  /**
   * Determine if a node from event.target is a Tab element for the current Tabs container.
   * If the clicked element is not a Tab, it returns false.
   * If it finds another Tabs container between the Tab and `this`, it returns false.
   */
  _proto.isTabFromContainer = function isTabFromContainer(node) {
    // return immediately if the clicked element is not a Tab.
    if (!isTabNode(node)) {
      return false;
    } // Check if the first occurrence of a Tabs container is `this` one.


    var nodeAncestor = node.parentElement;

    do {
      if (nodeAncestor === this.node) return true;
      if (nodeAncestor.getAttribute('data-rttabs')) break;
      nodeAncestor = nodeAncestor.parentElement;
    } while (nodeAncestor);

    return false;
  };

  _proto.render = function render() {
    var _this3 = this;

    // Delete all known props, so they don't get added to DOM
    var _this$props4 = this.props,
        children = _this$props4.children,
        className = _this$props4.className,
        disabledTabClassName = _this$props4.disabledTabClassName,
        domRef = _this$props4.domRef,
        focus = _this$props4.focus,
        forceRenderTabPanel = _this$props4.forceRenderTabPanel,
        onSelect = _this$props4.onSelect,
        selectedIndex = _this$props4.selectedIndex,
        selectedTabClassName = _this$props4.selectedTabClassName,
        selectedTabPanelClassName = _this$props4.selectedTabPanelClassName,
        environment = _this$props4.environment,
        disableUpDownKeys = _this$props4.disableUpDownKeys,
        attributes = _objectWithoutPropertiesLoose(_this$props4, _excluded);

    return /*#__PURE__*/react.createElement("div", _extends$1({}, attributes, {
      className: cx(className),
      onClick: this.handleClick,
      onKeyDown: this.handleKeyDown,
      ref: function ref(node) {
        _this3.node = node;
        if (domRef) domRef(node);
      },
      "data-rttabs": true
    }), this.getChildren());
  };

  return UncontrolledTabs;
}(react_1);

UncontrolledTabs.defaultProps = {
  className: 'react-tabs',
  focus: false
};
UncontrolledTabs.propTypes =  {};

var _excluded$1 = ["children", "defaultIndex", "defaultFocus"];

function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$1(subClass, superClass); }

function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }
var MODE_CONTROLLED = 0;
var MODE_UNCONTROLLED = 1;

var Tabs = /*#__PURE__*/function (_Component) {
  _inheritsLoose$1(Tabs, _Component);

  function Tabs(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handleSelected = function (index, last, event) {
      var onSelect = _this.props.onSelect;
      var mode = _this.state.mode; // Call change event handler

      if (typeof onSelect === 'function') {
        // Check if the change event handler cancels the tab change
        if (onSelect(index, last, event) === false) return;
      }

      var state = {
        // Set focus if the change was triggered from the keyboard
        focus: event.type === 'keydown'
      };

      if (mode === MODE_UNCONTROLLED) {
        // Update selected index
        state.selectedIndex = index;
      }

      _this.setState(state);
    };

    _this.state = Tabs.copyPropsToState(_this.props, {}, props.defaultFocus);
    return _this;
  }

  Tabs.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    return Tabs.copyPropsToState(props, state);
  };

  Tabs.getModeFromProps = function getModeFromProps(props) {
    return props.selectedIndex === null ? MODE_UNCONTROLLED : MODE_CONTROLLED;
  };

  // preserve the existing selectedIndex from state.
  // If the state has not selectedIndex, default to the defaultIndex or 0
  Tabs.copyPropsToState = function copyPropsToState(props, state, focus) {
    if (focus === void 0) {
      focus = false;
    }

    var newState = {
      focus: focus,
      mode: Tabs.getModeFromProps(props)
    };

    if (newState.mode === MODE_UNCONTROLLED) {
      var maxTabIndex = Math.max(0, getTabsCount(props.children) - 1);
      var selectedIndex = null;

      if (state.selectedIndex != null) {
        selectedIndex = Math.min(state.selectedIndex, maxTabIndex);
      } else {
        selectedIndex = props.defaultIndex || 0;
      }

      newState.selectedIndex = selectedIndex;
    }

    return newState;
  };

  var _proto = Tabs.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        defaultIndex = _this$props.defaultIndex,
        defaultFocus = _this$props.defaultFocus,
        props = _objectWithoutPropertiesLoose$1(_this$props, _excluded$1);

    var _this$state = this.state,
        focus = _this$state.focus,
        selectedIndex = _this$state.selectedIndex;
    props.focus = focus;
    props.onSelect = this.handleSelected;

    if (selectedIndex != null) {
      props.selectedIndex = selectedIndex;
    }

    return /*#__PURE__*/react.createElement(UncontrolledTabs, props, children);
  };

  return Tabs;
}(react_1);

Tabs.defaultProps = {
  defaultFocus: false,
  forceRenderTabPanel: false,
  selectedIndex: null,
  defaultIndex: null,
  environment: null,
  disableUpDownKeys: false
};
Tabs.propTypes =  {};
Tabs.tabsRole = 'Tabs';

var _excluded$2 = ["children", "className"];

function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

function _objectWithoutPropertiesLoose$2(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$2(subClass, superClass); }

function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }

var TabList = /*#__PURE__*/function (_Component) {
  _inheritsLoose$2(TabList, _Component);

  function TabList() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = TabList.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        className = _this$props.className,
        attributes = _objectWithoutPropertiesLoose$2(_this$props, _excluded$2);

    return /*#__PURE__*/react.createElement("ul", _extends$2({}, attributes, {
      className: cx(className),
      role: "tablist"
    }), children);
  };

  return TabList;
}(react_1);

TabList.defaultProps = {
  className: 'react-tabs__tab-list'
};
TabList.propTypes =  {};
TabList.tabsRole = 'TabList';

var _excluded$3 = ["children", "className", "disabled", "disabledClassName", "focus", "id", "panelId", "selected", "selectedClassName", "tabIndex", "tabRef"];

function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }

function _objectWithoutPropertiesLoose$3(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$3(subClass, superClass); }

function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }
var DEFAULT_CLASS = 'react-tabs__tab';

var Tab = /*#__PURE__*/function (_Component) {
  _inheritsLoose$3(Tab, _Component);

  function Tab() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Tab.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.checkFocus();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.checkFocus();
  };

  _proto.checkFocus = function checkFocus() {
    var _this$props = this.props,
        selected = _this$props.selected,
        focus = _this$props.focus;

    if (selected && focus) {
      this.node.focus();
    }
  };

  _proto.render = function render() {
    var _cx,
        _this = this;

    var _this$props2 = this.props,
        children = _this$props2.children,
        className = _this$props2.className,
        disabled = _this$props2.disabled,
        disabledClassName = _this$props2.disabledClassName,
        focus = _this$props2.focus,
        id = _this$props2.id,
        panelId = _this$props2.panelId,
        selected = _this$props2.selected,
        selectedClassName = _this$props2.selectedClassName,
        tabIndex = _this$props2.tabIndex,
        tabRef = _this$props2.tabRef,
        attributes = _objectWithoutPropertiesLoose$3(_this$props2, _excluded$3);

    return /*#__PURE__*/react.createElement("li", _extends$3({}, attributes, {
      className: cx(className, (_cx = {}, _cx[selectedClassName] = selected, _cx[disabledClassName] = disabled, _cx)),
      ref: function ref(node) {
        _this.node = node;
        if (tabRef) tabRef(node);
      },
      role: "tab",
      id: id,
      "aria-selected": selected ? 'true' : 'false',
      "aria-disabled": disabled ? 'true' : 'false',
      "aria-controls": panelId,
      tabIndex: tabIndex || (selected ? '0' : null),
      "data-rttab": true
    }), children);
  };

  return Tab;
}(react_1);

Tab.defaultProps = {
  className: DEFAULT_CLASS,
  disabledClassName: DEFAULT_CLASS + "--disabled",
  focus: false,
  id: null,
  panelId: null,
  selected: false,
  selectedClassName: DEFAULT_CLASS + "--selected"
};
Tab.propTypes =  {};
Tab.tabsRole = 'Tab';

var _excluded$4 = ["children", "className", "forceRender", "id", "selected", "selectedClassName", "tabId"];

function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }

function _objectWithoutPropertiesLoose$4(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf$4(subClass, superClass); }

function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }
var DEFAULT_CLASS$1 = 'react-tabs__tab-panel';

var TabPanel = /*#__PURE__*/function (_Component) {
  _inheritsLoose$4(TabPanel, _Component);

  function TabPanel() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = TabPanel.prototype;

  _proto.render = function render() {
    var _cx;

    var _this$props = this.props,
        children = _this$props.children,
        className = _this$props.className,
        forceRender = _this$props.forceRender,
        id = _this$props.id,
        selected = _this$props.selected,
        selectedClassName = _this$props.selectedClassName,
        tabId = _this$props.tabId,
        attributes = _objectWithoutPropertiesLoose$4(_this$props, _excluded$4);

    return /*#__PURE__*/react.createElement("div", _extends$4({}, attributes, {
      className: cx(className, (_cx = {}, _cx[selectedClassName] = selected, _cx)),
      role: "tabpanel",
      id: id,
      "aria-labelledby": tabId
    }), forceRender || selected ? children : null);
  };

  return TabPanel;
}(react_1);

TabPanel.defaultProps = {
  className: DEFAULT_CLASS$1,
  forceRender: false,
  selectedClassName: DEFAULT_CLASS$1 + "--selected"
};
TabPanel.propTypes =  {};
TabPanel.tabsRole = 'TabPanel';

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const ALERT_TEXT_CLASS_NAME = 'alert-text';

const DeferredInput = (props) => {
  const { value, valueToString, stringToValue, onChange, options } = props;
  const [isFocused, setIsFocused] = react_8(false);
  const str = react_13(
    () => valueToString ? valueToString(value) : value,
    [value, valueToString]
  );
  const onFocus = react_9(
    e => {
      e.currentTarget.select();
      setIsFocused(true);
    },
    []
  );
  const onBlur = react_9(
    e => {
      setIsFocused(false);
      const nextValue = stringToValue
        ? stringToValue(e.currentTarget.value)
        : e.currentTarget.value;
      const nextStr = valueToString ? valueToString(nextValue) : nextValue;
      if (nextStr !== str) {
        onChange && onChange(nextValue);
      }
    },
    [str, stringToValue, valueToString, onChange]
  );
  const onKeyDown = react_9(
    e => {
      if (e.key === 'Enter') {
        const nextValue = stringToValue
          ? stringToValue(e.currentTarget.value)
          : e.currentTarget.value;
        const nextStr = valueToString ? valueToString(nextValue) : nextValue;
        if (nextStr === str) {
          onChange && onChange(nextValue);
        }
        e.currentTarget.blur();
      }
    },
    [str, stringToValue, valueToString, onChange]
  );
  return react_13(
    () => react.createElement(
      'input',
      {
        ...options,
        onFocus,
        onBlur,
        onKeyDown,
        onChange: null,
        value: isFocused ? null : str
      }
    ),
    [str, isFocused, onBlur, options]
  )
};

const MatrixRowInput = (props) => {
  const { value, valueToString, stringToValue, onChange, options } = props;
  return react_13(
    () => react.createElement(
      'tr',
      null,
      value.map(
        (element, j) => react.createElement(
          'td',
          null,
          react.createElement(
            DeferredInput,
            {
              value: element,
              valueToString,
              stringToValue,
              onChange: nextValue => {
                const next = value.slice();
                next[j] = nextValue;
                onChange(next);
              },
              options
            }
          )
        )
      )
    ),
    [value, valueToString, stringToValue, onChange, options]
  )
};

const VectorInput = (props) => {
  const { value, valueToString, stringToValue, onChange, options } = props;
  const dim = [value.getDim()[0]];
  return react_13(
    () => react.createElement(
      'table',
      null,
      value.map(
        (element, i) => react.createElement(
          'tr',
          null,
          react.createElement(
            'td',
            null,
            react.createElement(
              DeferredInput,
              {
                value: element,
                valueToString,
                stringToValue,
                onChange: nextValue => {
                  const next = value.slice();
                  next[i] = nextValue;
                  onChange(newMatrix(dim, next));
                },
                options
              }
            )
          )
        )
      )
    ),
    [value, valueToString, stringToValue, onChange, options]
  )
};

// onChange: ([e, j]) => ...
const MatrixInput = (props) => {
  const { value, valueToString, stringToValue, onChange, options } = props;
  const [dim0, dim1] = value.getDim();
  return react_13(
    () => react.createElement(
      'table',
      null,
      Array(dim0).fill(null).map(
        (row, i) => {
          const start = i * dim1;
          return react.createElement(
            MatrixRowInput,
            {
              value: value.slice(start, start + dim1),
              valueToString,
              stringToValue,
              onChange: nextRow => {
                const next = value.slice();
                for (let j = 0; j < dim1; j += 1) {
                  next[start + j] = nextRow[j];
                }
                onChange(newMatrix([dim0, dim1], next));
              },
              options
            }
          )
        }
      )
    ),
    [value, valueToString, stringToValue, onChange, options]
  )
};

const ColourInput = (props) => {
  const { value, valueToString, stringToValue, onChange, options } = props;
  const _onChange = react_9(
    e => {
      const value = stringToValue
        ? stringToValue(e.currentTarget.value)
        : e.currentTarget.value;
      onChange && onChange(value);
    },
    [stringToValue, onChange]
  );
  const str = react_13(
    () => valueToString(value),
    [value, valueToString]
  );
  return react_13(
    () => react.createElement(
      'input',
      {
        ...options,
        type: 'color',
        onChange: _onChange,
        value: str
      }
    ),
    [str, _onChange, options]
  )
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const ITEM_EDITOR_CLASS_NAME_PREFIX = 'item-editor-';
const InapplicableItem = () => react.createElement('span', null, '.');

const ItemEditor = ({
  dict,
  data,
  categoryId,
  index = -1,
  objectId,
  packet = false,
  setCategoryData
}) => {
  const dispatch = useDispatch();
  const def = selectDefinition(dict, data, categoryId, objectId, packet);
  const { value, source, alert } =
    selectDataItem(dict, data, categoryId, objectId, packet);
  const container = def.get(['type', 'container']);
  const dimension = def.get(['type', 'dimension']);
  const contents = def.get(['type', 'contents']);
  const Component = react_13(
    () => {
      switch (container) {
        case 'matrix': {
          if (dimension === false) {
            return InapplicableItem
          }
          switch (dimension.length) {
            case 1: {
              return VectorInput
            }
            case 2: {
              return MatrixInput
            }
            default: {
              return DeferredInput
            }
          }
        }
        case 'single': {
          switch (contents) {
            case 'colour': {
              return ColourInput
            }
            default: {
              return DeferredInput
            }
          }
        }
        default: {
          return DeferredInput
        }
      }
    },
    [container, dimension, contents]
  );
  const options = react_13(
    () => {
      switch (contents) {
        case 'count':
        case 'index':
        case 'integer':
        case 'real': {
          return { type: 'text' }
        }
        case 'text': {
          return { type: 'text' }
        }
        default: {
          return {}
        }
      }
    }
  );
  const valueToString = react_13(
    () => {
      switch (contents) {
        case 'integer':
        case 'real': {
          return value =>
            value === null
              ? '?'
              : value === false
                ? '.'
                : value.toString()
        }
        case 'colour': {
          return value =>
            (value === null || value === false)
              ? '#000000'
              : value
        }
        case 'text':
        case 'code': {
          return value => value === null ? '?' : value === false ? '.' : value
        }
        default: {
          return value => value === null ? '?' : value === false ? '.' : value
        }
      }
    },
    [contents]
  );
  const stringToValue = react_13(
    () => {
      switch (contents) {
        case 'integer': {
          return str =>
            str === '?'
              ? null
              : str === '.'
                ? false
                : parseInt(str, 10)
        }
        case 'real': {
          return str =>
            str === '?'
              ? null
              : str === '.'
                ? false
                : parseFloat(str)
        }
        case 'colour': {
          return str => str
        }
        case 'code': {
          return str =>
            str === '?'
              ? null
              : str === '.'
                ? false
                : toCanonicalCaseFold(str)
        }
        case 'text': {
          return str =>
            str === '?'
              ? null
              : str === '.'
                ? false
                : str
        }
        default: {
          return str =>
            str === '?'
              ? null
              : str === '.'
                ? false
                : str
        }
      }
    },
    [contents]
  );
  const onChange = react_13(
    () => nextValue => {
      const next = selectValidatedDataItem(
        storedItem(nextValue), dict, data, categoryId, objectId, packet
      );
      if (!/^Throw: /.test(next.alert)) {
        const nextPacket = new Map([...(packet || []), [objectId, next]]);
        dispatch(setCategoryData(categoryId, nextPacket, index));
      }
    },
    [
      value,
      dispatch,
      setCategoryData,
      dict,
      data,
      categoryId,
      index,
      objectId,
      packet
    ]
  );
  return react_13(
    () => react.createElement(
      'span',
      {
        className:
          ITEM_EDITOR_CLASS_NAME_PREFIX + source + (alert ? '-alert' : ''),
        title: source
      },
      react.createElement(
        Component,
        {
          options,
          value,
          source,
          valueToString,
          stringToValue,
          onChange
        }
      ),
      react.createElement(
        'span',
        { className: ALERT_TEXT_CLASS_NAME },
        alert
      )
    ),
    [
      Component,
      options,
      value,
      source,
      alert,
      valueToString,
      stringToValue,
      onChange
    ]
  )
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const LoopCategoryEditorCreator = (
  quasicrystalSelector = state => state,
  actionPrefix = '',
  catId
) => {
  const dictSelector =
    state => quasicrystalSelector(state).dictionary;
  const dataSelector =
    state => quasicrystalSelector(state).data;
  const setCategoryData = setCategoryDataCreator(actionPrefix);
  const LoopCategoryEditor = () => {
    const dispatch = useDispatch();
    const dict = useSelector(dictSelector);
    const data = useSelector(dataSelector);
    const dictCatItems = dict.get([catId, false]).get(['Items']);
    const { value: catData, alert } = react_13(
      () => selectDataItem(dict, data, catId),
      [dict, data, catId]
    );
    const Header = react_13(
      () => react.createElement(
        'tr',
        null,
        Array.from(dictCatItems,
          objId => react.createElement(
            'th',
            { key: objId },
            objId
          )
        ),
        react.createElement('td', null, '')
      ),
      [dictCatItems]
    );
    const trPackets = react_13(
      () => catData.map(
        (packet, index) => react.createElement(
          'tr',
          { key: packet },
          Array.from(dictCatItems,
            objId => react.createElement(
              'td',
              { key: objId },
              react.createElement(
                ItemEditor,
                {
                  dict,
                  data,
                  categoryId: catId,
                  index,
                  objectId: objId,
                  packet,
                  setCategoryData
                }
              )
            )
          ),
          react.createElement(
            'td',
            null,
            react.createElement(
              'button',
              {
                onClick: () => {
                  dispatch(setCategoryData(catId, null, index));
                }
              },
              '\u{2212}'
            )
          )
        )
      ),
      [dispatch, dict, data, catId, dictCatItems, catData]
    );
    const Footer = react_13(
      () => react.createElement(
        'button',
        {
          onClick: () => {
            const packet = new Map();
            dispatch(setCategoryData(catId, packet));
          }
        },
        '+'
      ),
      [dispatch, dict, data, catId]
    );
    return react_13(
      () => react.createElement(
        'div',
        null,
        react.createElement(
          'span',
          { className: ALERT_TEXT_CLASS_NAME },
          alert
        ),
        react.createElement(
          'table',
          null,
          Header,
          trPackets
        ),
        Footer
      ),
      [alert, Header, trPackets, Footer]
    )
  };
  return LoopCategoryEditor
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const SetCategoryEditorCreator = (
  quasicrystalSelector = state => state,
  actionPrefix = '',
  catId
) => {
  const dictSelector =
    state => quasicrystalSelector(state).dictionary;
  const dataSelector =
    state => quasicrystalSelector(state).data;
  const setCategoryData = setCategoryDataCreator(actionPrefix);
  const SetCategoryEditor = () => {
    const dict = useSelector(dictSelector);
    const data = useSelector(dataSelector);
    const dictCatItems = dict.get([catId, false]).get(['Items']);
    const itemDivs = react_13(
      () => Array.from(dictCatItems,
        objId => react.createElement(
          'div',
          { key: objId },
          objId + ': ',
          react.createElement(
            ItemEditor,
            {
              dict,
              data,
              categoryId: catId,
              objectId: objId,
              setCategoryData
            }
          )
        )
      ),
      [dict, data, catId, dictCatItems]
    );
    return react_13(
      () => react.createElement('div', null, itemDivs),
      [itemDivs]
    )
  };
  return SetCategoryEditor
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

const CategoryEditor = ({
  quasicrystalSelector,
  actionPrefix,
  categoryId,
  dict,
  data
}) => {
  const catDef = react_13(
    () => selectDefinition(dict, data, categoryId),
    [dict, data, categoryId]
  );
  const categoryClass = catDef.get(['definition', 'class']);
  return react_13(
    () => {
      switch (categoryClass) {
        case 'loop': {
          return react.createElement(
            LoopCategoryEditorCreator(
              quasicrystalSelector,
              actionPrefix,
              categoryId
            )
          )
        }
        case 'set': {
          return react.createElement(
            SetCategoryEditorCreator(
              quasicrystalSelector,
              actionPrefix,
              categoryId
            )
          )
        }
        default: {
          return null
        }
      }
    },
    [quasicrystalSelector, actionPrefix, categoryId, categoryClass]
  )
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/complex-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @typedef {number|Polynomial} RealAlgebraicElement
 *
 * @desc
 * A RealAlgebraicElement denotes a {@link number}
 * or a {@link Polynomial} as follows.
 * * A {@link number} for the numerical algebra.
 * * A {@link Polynomial} for the exact algebra.
 *
 * See the documents of @kkitahara/real-algebra for details.
 */

/**
 * @desc
 * The ComplexAlgebraicElement class is a class for complex algebraic elements.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class ComplexAlgebraicElement {
  /**
   * @desc
   * The constructor function of the {@link ComplexAlgebraicElement} class.
   *
   * CAUTION: this constructor function does not check if `a` and `b`
   * are valid {@link RealAlgebraicElement}s.
   *
   * @param {RealAlgebraicElement} a
   * a {@link RealAlgebraicElement}.
   *
   * @param {RealAlgebraicElement} b
   * a {@link RealAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ComplexAlgebraicElement as C } from '@kkitahara/complex-algebra'
   *
   * let a = new C(1, 2)
   * a.re === 1 // true
   * a.im === 2 // true
   */
  constructor (a, b) {
    /**
     * @desc
     * The ComplexAlgebraicElement#re
     * is the real part of the {@link ComplexAlgebraicElement}.
     *
     * @type {RealAlgebraicElement}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.re = a;
    /**
     * @desc
     * The ComplexAlgebraicElement#im
     * is the imaginary part of the {@link ComplexAlgebraicElement}.
     *
     * @type {RealAlgebraicElement}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.im = b;
  }

  /**
   * @desc
   * The ComplexAlgebraicElement#toString method converts
   * `this` to a human-readable {@link string}.
   *
   * @param {number} [radix]
   * the base to use for representing numeric values.
   *
   * @return {string}
   * a human-readable {@link string} representation of `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   *
   * new C(1, 0).toString() // '1'
   * new C(0, -1).toString() // 'i(-1)'
   * new C(-1, -1).toString() // '-1 + i(-1)'
   *
   * let a = ralg.iadd(ralg.num(-1, 2), ralg.num(-1, 2, 5))
   * let b = ralg.iadd(ralg.num(-1), a)
   * let z = new C(a, b)
   * z.toString() // '-1 / 2 - (1 / 2)sqrt(5) + i(-3 / 2 - (1 / 2)sqrt(5))'
   *
   * new C(-3, -5).toString(2) // '-11 + i(-101)'
   *
   * new C(0, 0).toString(2) // '0'
   */
  toString (radix) {
    let s = '';
    if (typeof this.re === 'number') {
      if (this.re !== 0) {
        s += this.re.toString(radix);
      }
    } else if (!this.re.isZero()) {
      s += this.re.toString(radix);
    }
    if (typeof this.im === 'number') {
      if (this.im !== 0) {
        if (s.length === 0) {
          s += 'i(' + this.im.toString(radix) + ')';
        } else {
          s += ' + i(' + this.im.toString(radix) + ')';
        }
      }
    } else if (!this.im.isZero()) {
      if (s.length === 0) {
        s += 'i(' + this.im.toString(radix) + ')';
      } else {
        s += ' + i(' + this.im.toString(radix) + ')';
      }
    }
    if (s.length === 0) {
      s = '0';
    }
    return s
  }

  /**
   * @desc
   * The ComplexAlgebraicElement#toFixed method returns
   * the fixed-point representation of `this`.
   *
   * @param {number} [digits]
   * the number of digits appear after the decimal point.
   *
   * @return {string}
   * the fixed-point representation of `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.iadd(ralg.num(-1, 2), ralg.num(-1, 2, 5))
   * let b = ralg.iadd(ralg.num(-1), a)
   * let z = new C(a, b)
   * z.toFixed(3) // '-1.618 + i(-2.618)'
   *
   * z = new C(0, b)
   * z.toFixed(3) // 'i(-2.618)'
   *
   * z = new C(ralg.num(0), b)
   * z.toFixed(3) // 'i(-2.618)'
   *
   * z = new C(b, ralg.num(0))
   * z.toFixed(3) // '-2.618'
   *
   * z = new C(1.3, 3.2)
   * z.toFixed(3) // '1.300 + i(3.200)'
   *
   * z = new C(0, 3.2)
   * z.toFixed(3) // 'i(3.200)'
   *
   * z = new C(0, 0)
   * z.toFixed(3) // '0.000'
   */
  toFixed (digits) {
    let s = '';
    if (typeof this.re === 'number') {
      if (this.re !== 0) {
        s = s + this.re.toFixed(digits);
      }
    } else if (!this.re.isZero()) {
      s = s + this.re.toFixed(digits);
    }
    if (typeof this.im === 'number') {
      if (this.im !== 0) {
        if (s.length === 0) {
          s = s + 'i(' + this.im.toFixed(digits) + ')';
        } else {
          s = s + ' + i(' + this.im.toFixed(digits) + ')';
        }
      }
    } else if (!this.im.isZero()) {
      if (s.length === 0) {
        s = s + 'i(' + this.im.toFixed(digits) + ')';
      } else {
        s = s + ' + i(' + this.im.toFixed(digits) + ')';
      }
    }
    if (s.length === 0) {
      s = this.re.toFixed(digits);
    }
    return s
  }

  /**
   * @desc
   * The ComplexAlgebraicElement#toJSON method converts
   * `this` to an object serialisable by `JSON.stringify`.
   *
   * @return {object}
   * a serialisable object for `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   *
   * let a = ralg.iadd(ralg.num(-1, 2), ralg.num(-1, 2, 5))
   * let b = ralg.iadd(ralg.num(-1), a)
   * let z = new C(a, b)
   *
   * // toJSON method is called by JSON.stringify
   * let s = JSON.stringify(z)
   *
   * typeof s // 'string'
   */
  toJSON () {
    const obj = {};
    obj.reviver = 'Complex';
    obj.version = '1.0.0';
    obj.re = this.re;
    obj.im = this.im;
    return obj
  }

  /**
   * @desc
   * The ComplexAlgebraicElement.reviver function converts
   * the data produced by {@link ComplexAlgebraicElement#toJSON}
   * to a {@link ComplexAlgebraicElement}.
   *
   * @param {object} key
   *
   * @param {object} value
   *
   * @return {ComplexAlgebraicElement|object}
   * a {@link ComplexAlgebraicElement} or `value`.
   *
   * @throws {Error}
   * if the given object is invalid.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ComplexAlgebraicElement as C } from '@kkitahara/complex-algebra'
   *
   * let a = 1 / 2 * Math.sqrt(5)
   * let b = a - 1
   * let z = new C(a, b)
   * let s = JSON.stringify(z)
   *
   * let w = JSON.parse(s, C.reviver)
   *
   * typeof s // 'string'
   * w instanceof C // true
   * w !== z // true
   * z.re === w.re // true
   * z.im === w.im // true
   *
   * let s2 = s.replace('1.0.0', '0.0.0')
   * JSON.parse(s2, C.reviver) // Error
   */
  static reviver (key, value) {
    if (value !== null && typeof value === 'object' &&
        value.reviver === 'Complex') {
      if (value.version === '1.0.0') {
        return new ComplexAlgebraicElement(value.re, value.im)
      } else {
        throw Error('invalid version.')
      }
    } else {
      return value
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/complex-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The ComplexAlgebra class is a class for complex algebra.
 *
 * @version 1.0.0
 * @since 1.0.0
 *
 * @example
 * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
 * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
 * let ralg = new RealAlgebra()
 * let calg = new ComplexAlgebra(ralg)
 * let z, w, v
 *
 * // Generate a new real number
 * z = calg.num(1, 2, 5)
 * z.toString() // '(1 / 2)sqrt(5)'
 *
 * z = calg.num(1, 2)
 * z.toString() // '1 / 2'
 *
 * z = calg.num(3)
 * z.toString() // '3'
 *
 * // Generate a new imaginary number
 * z = calg.inum(1, 2, 5)
 * z.toString() // 'i((1 / 2)sqrt(5))'
 *
 * z = calg.inum(1, 2)
 * z.toString() // 'i(1 / 2)'
 *
 * z = calg.inum(3)
 * z.toString() // 'i(3)'
 *
 * // Real and imaginary parts
 * z = calg.num(1, 2, 5)
 * z.re.toString() // '(1 / 2)sqrt(5)'
 * z.im.toString() // '0'
 *
 * z = calg.inum(1, 2, 5)
 * z.re.toString() // '0'
 * z.im.toString() // '(1 / 2)sqrt(5)'
 *
 * // Generate from two real numbers (since v1.2.0)
 * let a = ralg.$(1, 2, 3)
 * let b = ralg.$(1, 2, 5)
 * z = calg.$(a, b)
 * z.toString() // '(1 / 2)sqrt(3) + i((1 / 2)sqrt(5))'
 *
 * // Copy (create a new object)
 * z = calg.inum(1, 2, 5)
 * w = calg.copy(z)
 * w.toString() // 'i((1 / 2)sqrt(5))'
 *
 * // Equality
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2, 5)
 * calg.eq(z, w) // false
 *
 * w = calg.num(1, 2, 5)
 * calg.eq(z, w) // true
 *
 * // Inequality
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2, 5)
 * calg.ne(z, w) // true
 *
 * w = calg.num(1, 2, 5)
 * calg.ne(z, w) // false
 *
 * // isZero
 * calg.isZero(calg.num(0)) // true
 * calg.isZero(calg.inum(0)) // true
 * calg.isZero(calg.num(1, 2, 5)) // false
 * calg.isZero(calg.inum(1, 2, 5)) // false
 * calg.isZero(calg.num(-1, 2, 5)) // false
 * calg.isZero(calg.inum(-1, 2, 5)) // false
 *
 * // isInteger (since v1.1.0)
 * calg.isInteger(calg.num(0)) // true
 * calg.isInteger(calg.inum(0)) // true
 * calg.isInteger(calg.num(1, 2)) // false
 * calg.isInteger(calg.inum(1, 2)) // false
 * calg.isInteger(calg.num(6, 3)) // true
 * calg.isInteger(calg.inum(6, 3)) // true
 * calg.isInteger(calg.num(6, 3, 2)) // false
 * calg.isInteger(calg.inum(6, 3, 2)) // false
 *
 * // Addition
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is generated
 * v = calg.add(z, w)
 * v.toString() // '(1 / 2)sqrt(5) + i(1 / 2)'
 *
 * // In-place addition
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is not generated
 * z = calg.iadd(z, w)
 * z.toString() // '(1 / 2)sqrt(5) + i(1 / 2)'
 *
 * // Subtraction
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is generated
 * v = calg.sub(z, w)
 * v.toString() // '(1 / 2)sqrt(5) + i(-1 / 2)'
 *
 * // In-place subtraction
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is not generated
 * z = calg.isub(z, w)
 * z.toString() // '(1 / 2)sqrt(5) + i(-1 / 2)'
 *
 * // Maltiplication
 * z = calg.inum(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is generated
 * v = calg.mul(z, w)
 * v.toString() // '-(1 / 4)sqrt(5)'
 *
 * // In-place multiplication
 * z = calg.inum(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is not generated
 * z = calg.imul(z, w)
 * z.toString() // '-(1 / 4)sqrt(5)'
 *
 * // Division
 * z = calg.inum(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is generated
 * v = calg.div(z, w)
 * v.toString() // 'sqrt(5)'
 *
 * // In-place division
 * z = calg.inum(1, 2, 5)
 * w = calg.inum(1, 2)
 * // new object is not generated
 * z = calg.idiv(z, w)
 * z.toString() // 'sqrt(5)'
 *
 * // Multiplication by -1
 * z = calg.inum(1, 2, 5)
 * // new object is generated
 * w = calg.neg(z)
 * w.toString() // 'i(-(1 / 2)sqrt(5))'
 *
 * // In-place multiplication by -1
 * z = calg.inum(1, 2, 5)
 * // new object is not generated
 * z = calg.ineg(z)
 * z.toString() // 'i(-(1 / 2)sqrt(5))'
 *
 * // Complex conjugate
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2, 5)
 * // new object is generated
 * v = calg.cjg(z)
 * v.toString() // '(1 / 2)sqrt(5)'
 * v = calg.cjg(w)
 * v.toString() // 'i(-(1 / 2)sqrt(5))'
 *
 * // In-place evaluation of the complex conjugate
 * z = calg.num(1, 2, 5)
 * w = calg.inum(1, 2, 5)
 * // new object is not generated
 * z = calg.icjg(z)
 * z.toString() // '(1 / 2)sqrt(5)'
 * w = calg.icjg(w)
 * w.toString() // 'i(-(1 / 2)sqrt(5))'
 *
 * // Square of the absolute value
 * z = calg.iadd(calg.num(3), calg.inum(4))
 * a = calg.abs2(z)
 * a.toString() // '25'
 * // return value is not a complex number (but a real number)
 * a.re // undefined
 * a.im // undefined
 *
 * // JSON (stringify and parse)
 * z = calg.iadd(calg.num(1, 2, 5), calg.inum(-1, 2, 7))
 * let str = JSON.stringify(z)
 * w = JSON.parse(str, calg.reviver)
 * calg.eq(z, w) // true
 */
class ComplexAlgebra {
  /**
   * @desc
   * The constructor of the {@link ComplexAlgebra} class.
   *
   * CAUTION: this function does not check if `ralg` is a valid implementation
   * of {@link RealAlgebra}.
   *
   * @param {RealAlgebra} ralg
   * an instance of {@link RealAlgebra}.
   *
   * @version 1.2.2
   * @since 1.0.0
   */
  constructor (ralg) {
    /**
     * @desc
     * The ComplexAlgebra#ralg is used
     * to manipurate real or imaginary part of
     * {@link ComplexAlgebraicElement}s.
     *
     * @type {RealAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.ralg = ralg;
  }

  /**
   * @desc
   * The ComplexAlgebra#$ method returns a new instance of
   * {@link ComplexAlgebraicElement} representing `a + bj`.
   * It uses copies of `a` and `b`.
   *
   * @param {RealAlgebraicElement} [a = 0]
   * real part.
   *
   * @param {RealAlgebraicElement} [b = 0]
   * imaginary part.
   *
   * @return {ComplexAlgebraicElement}
   * a {@link ComplexAlgebraicElement} representing
   * `a + bj`
   *
   * @version 1.2.0
   * @since 1.2.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.$(1, 2)
   * z instanceof C // true
   * ralg.eq(z.re, 1) // true
   * ralg.eq(z.im, 2) // true
   *
   * z = calg.$()
   * z instanceof C // true
   * ralg.eq(z.re, 0) // true
   * ralg.eq(z.im, 0) // true
   */
  $ (a = 0, b = 0) {
    const ralg = this.ralg;
    a = ralg.copy(a);
    b = ralg.copy(b);
    return new ComplexAlgebraicElement(a, b)
  }

  /**
   * @desc
   * The ComplexAlgebra#num method returns
   * a {@link ComplexAlgebraicElement} representing
   * (*p* / *q*)sqrt(*b*) if the 3rd parameter is positive (or zero)
   * and i(*p* / *q*)sqrt(-*b*) otherwise,
   * where *p* is an integer, *q* is a non-zero integer,
   * and the absolute value of *b* is a square-free integer.
   *
   * CAUTION: this method does not check if the absolute value of `b`
   * is square-free.
   *
   * @param {number|bigInt} [p = 0]
   * an integer.
   *
   * @param {number|bigInt} [q = 1]
   * a non-zero integer (can be negative).
   *
   * @param {number|bigInt} [b = 1]
   * a square-free integer.
   *
   * @return {ComplexAlgebraicElement}
   * a {@link ComplexAlgebraicElement} representing
   * `(p / q)sqrt(b)` if `b` is positive (or zero)
   * and `i(p / q)sqrt(-b)` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * import bigInt from 'big-integer'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let a = ralg.num(1, 2, 5)
   * let b = ralg.num(0, 2, 5)
   * let z = calg.num(1, 2, 5)
   * let w = calg.num(1, 2, -5)
   *
   * z instanceof C // true
   * ralg.eq(z.re, a) // true
   * ralg.eq(z.im, b) // true
   *
   * w instanceof C // true
   * ralg.eq(w.re, b) // true
   * ralg.eq(w.im, a) // true
   *
   * w = calg.num(1, 2, bigInt(-5))
   * w instanceof C // true
   * ralg.eq(w.re, b) // true
   * ralg.eq(w.im, a) // true
   *
   * w = calg.num()
   * w instanceof C // true
   * ralg.eq(w.re, 0) // true
   * ralg.eq(w.im, 0) // true
   */
  num (p = 0, q = 1, b = 1) {
    const ralg = this.ralg;
    if (ralg.isZero(b) || ralg.isPositive(b)) {
      return new ComplexAlgebraicElement(ralg.num(p, q, b), ralg.num(0))
    } else {
      if (BigInteger.isInstance(b)) {
        b = b.times(-1);
      } else {
        b = -b;
      }
      return new ComplexAlgebraicElement(ralg.num(0), ralg.num(p, q, b))
    }
  }

  /**
   * @desc
   * The ComplexAlgebra#inum method returns
   * a {@link ComplexAlgebraicElement} representing
   * i(*p* / *q*)sqrt(*b*) if the 3rd parameter is positive (or zero)
   * and -(*p* / *q*)sqrt(-*b*) otherwise,
   * where *p* is an integer, *q* is a non-zero integer,
   * and the absolute value of *b* is a square-free integer.
   *
   * CAUTION: this method does not check if the absolute value of `b`
   * is square-free.
   *
   * @param {number} [p = 0]
   * an integer.
   *
   * @param {number} [q = 1]
   * a non-zero integer (can be negative).
   *
   * @param {number} [b = 1]
   * a square-free integer.
   *
   * @return {ComplexAlgebraicElement}
   * a {@link ComplexAlgebraicElement} representing
   * `i(p / q)sqrt(b)` if `b` is positive (or zero)
   * and `-(p / q)sqrt(-b)` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * import bigInt from 'big-integer'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let a = ralg.num(1, 2, 5)
   * let b = ralg.num(-1, 2, 5)
   * let c = ralg.num(0, 2, 5)
   * let z = calg.inum(1, 2, 5)
   * let w = calg.inum(1, 2, -5)
   *
   * z instanceof C // true
   * ralg.eq(z.re, c) // true
   * ralg.eq(z.im, a) // true
   *
   * w instanceof C // true
   * ralg.eq(w.re, b) // true
   * ralg.eq(w.im, c) // true
   *
   * w = calg.inum(bigInt(1), 2, bigInt(-5))
   * w instanceof C // true
   * ralg.eq(w.re, b) // true
   * ralg.eq(w.im, c) // true
   *
   * w = calg.inum()
   * w instanceof C // true
   * ralg.eq(w.re, 0) // true
   * ralg.eq(w.im, 0) // true
   */
  inum (p = 0, q = 1, b = 1) {
    const ralg = this.ralg;
    if (ralg.isZero(b) || ralg.isPositive(b)) {
      return new ComplexAlgebraicElement(ralg.num(0), ralg.num(p, q, b))
    } else {
      if (BigInteger.isInstance(b)) {
        b = b.times(-1);
      } else {
        b = -b;
      }
      if (BigInteger.isInstance(p)) {
        p = p.times(-1);
      } else {
        p = -p;
      }
      return new ComplexAlgebraicElement(ralg.num(p, q, b), ralg.num(0))
    }
  }

  /**
   * @desc
   * The ComplexAlgebra#cast method just returns
   * `z` if `z` is a {@link ComplexAlgebraicElement}
   * and both `z.re` and `z.im` are valid instances of
   * {@link RealAlgebraicElement},
   * and otherwise casts `z` to a {@link ComplexAlgebraicElement}.
   *
   * @param {object} z
   * an object.
   *
   * @return {ComplexAlgebraicElement}
   * `z` or a new {@link ComplexAlgebraicElement}.
   *
   * @version 1.2.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1)
   * let w = z
   *
   * w === calg.cast(z) // true
   * calg.cast(1) instanceof C // true
   * w === calg.cast(1) // false
   * calg.eq(z, calg.cast(1)) // true
   *
   * calg.eq(calg.cast({re: 2, im: 1}), new C(2, 1)) // true
   *
   * z = new C(1, 2)
   * ralg.cast(z.re) === z.re // false
   * w = calg.cast(z)
   * w === z // false
   * ralg.cast(w.re) === w.re // true
   */
  cast (z) {
    if (!(z instanceof ComplexAlgebraicElement)) {
      const ralg = this.ralg;
      const re = z.re;
      const im = z.im;
      if (re !== undefined || im !== undefined) {
        z = new ComplexAlgebraicElement(ralg.cast(re), ralg.cast(im));
      } else {
        z = new ComplexAlgebraicElement(ralg.cast(z), ralg.$(0));
      }
    } else {
      const ralg = this.ralg;
      const re = ralg.cast(z.re);
      const im = ralg.cast(z.im);
      if (re !== z.re || im !== z.im) {
        z = new z.constructor(re, im);
      }
    }
    return z
  }

  /**
   * @desc
   * The ComplexAlgebra#copy method returns a copy of `z`.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * a copy of `z`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1)
   * let w = calg.copy(z)
   *
   * z instanceof C // true
   * w instanceof C // true
   * ralg.eq(z.re, w.re) // true
   * ralg.eq(z.im, w.im) // true
   * z !== w // true
   * z.re !== w.re // true
   * z.im !== w.im // true
   */
  copy (z) {
    z = this.cast(z);
    const ralg = this.ralg;
    return new z.constructor(ralg.copy(z.re), ralg.copy(z.im))
  }

  /**
   * @desc
   * The ComplexAlgebra#eq method checks if `z` is equal to `w`.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `z` is equal to `w` and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1, 2, -5)
   *
   * calg.eq(z, calg.num(1, 2, -5)) // true
   * calg.eq(z, calg.num(1, 2, 5)) // false
   * calg.eq(z, calg.num(-1, 2, -5)) // false
   */
  eq (z, w) {
    z = this.cast(z);
    w = this.cast(w);
    const ralg = this.ralg;
    return ralg.eq(z.re, w.re) && ralg.eq(z.im, w.im)
  }

  /**
   * @desc
   * The ComplexAlgebra#ne method checks if `z` is not equal to `w`.
   *
   * `calg.ne(z, w)` is an alias for `!calg.eq(z, w)`,
   * where `calg` is an instance of {@link ComplexAlgebra}.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `z` is not equal to `w` and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1, 2, -5)
   *
   * calg.ne(z, calg.num(1, 2, -5)) // false
   * calg.ne(z, calg.num(1, 2, 5)) // true
   * calg.ne(z, calg.num(-1, 2, -5)) // true
   */
  ne (z, w) {
    return !this.eq(z, w)
  }

  /**
   * @desc
   * The ComplexAlgebra#isZero method checks if `z` is zero.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `z` is zero and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * calg.isZero(calg.num(0, 2, 5)) // true
   * calg.isZero(calg.num(1, 2, 5)) // false
   * calg.isZero(calg.num(1, 2, -5)) // false
   */
  isZero (z) {
    z = this.cast(z);
    const ralg = this.ralg;
    return ralg.isZero(z.re) && ralg.isZero(z.im)
  }

  /**
   * @desc
   * The ComplexAlgebra#isInteger method checks if both
   * the real and imaginary parts of `z` are integers.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if both the real and imaginary parts of `z` are integers
   * and `false` otherwise.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * calg.isInteger(calg.num(0, 2, 5)) // true
   * calg.isInteger(calg.num(1, 2, 5)) // false
   * calg.isInteger(calg.inum(1, 2, 5)) // false
   * calg.isInteger(calg.num(4, 2, 1)) // true
   * calg.isInteger(calg.inum(4, 2, 1)) // true
   */
  isInteger (z) {
    z = this.cast(z);
    const ralg = this.ralg;
    return ralg.isInteger(z.re) && ralg.isInteger(z.im)
  }

  /**
   * @desc
   * The ComplexAlgebra#isFinite method checks if `z` is finite.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {boolean}
   * `true` if `z` is finite and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * import bigInt from 'big-integer'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let a = bigInt('1e999')
   * calg.isFinite(calg.num(a, 2, 5)) // true
   * calg.isFinite(calg.num(a, 2, -5)) // true
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let a = 1e999
   * calg.isFinite(calg.num(1, 2, 5)) // true
   * calg.isFinite(calg.num(a, 2, -5)) // false
   */
  isFinite (z) {
    z = this.cast(z);
    const ralg = this.ralg;
    return ralg.isFinite(z.re) && ralg.isFinite(z.im)
  }

  /**
   * @desc
   * The ComplexAlgebra#isExact method checks
   * if `this` is an implementation of exact algebra.
   *
   * @return {boolean}
   * `true` if `this` is an exact algebra and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * calg.isExact() // true
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * calg.isExact() // false
   */
  isExact () {
    return this.ralg.isExact()
  }

  /**
   * @desc
   * The ComplexAlgebra#isReal method checks
   * if `this` is an implementation of real algebra.
   *
   * @return {boolean}
   * `false`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * ralg.isReal() // true
   * calg.isReal() // false
   */
  isReal () {
    return false
  }

  /**
   * @desc
   * The ComplexAlgebra#add method returns the result of
   * the addition `z` plus `w`.
   *
   * `calg.add(z, w)` is an alias for `calg.iadd(calg.copy(z), w)`,
   * where `calg` is an instance of {@link ComplexAlgebra}.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * a new {@link ComplexAlgebraicElement}
   * representing the result of the addition `z` plus `w`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1)
   * let w = calg.num(-1, 1, -1)
   *
   * let v = calg.add(z, w)
   * v instanceof C // true
   * v !== z // true
   * calg.eq(z, new C(1, 0)) // true
   * calg.eq(v, new C(1, -1)) // true
   */
  add (z, w) {
    return this.iadd(this.copy(z), w)
  }

  /**
   * @desc
   * The ComplexAlgebra#iadd method adds `w` to `z` *in place*.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * `z`, or a new {@link ComplexAlgebraicElement} if `z` is not a
   * {@link ComplexAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1)
   * let w = calg.num(-1, 1, -1)
   * let v = z
   *
   * // GOOD-PRACTICE!
   * z = calg.iadd(z, w)
   * z === v // true
   * z instanceof C // true
   * calg.eq(z, new C(1, -1)) // true
   */
  iadd (z, w) {
    z = this.cast(z);
    w = this.cast(w);
    const ralg = this.ralg;
    z.re = ralg.iadd(z.re, w.re);
    z.im = ralg.iadd(z.im, w.im);
    return z
  }

  /**
   * @desc
   * The ComplexAlgebra#sub method returns the result of
   * the subtraction `z` minus `w`.
   *
   * `calg.sub(z, w)` is an alias for `calg.isub(calg.copy(z), w)`,
   * where `calg` is an instance of {@link ComplexAlgebra}.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * a new {@link ComplexAlgebraicElement}
   * representing the result of the subtraction `z` minus `w`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1)
   * let w = calg.num(-1, 1, -1)
   *
   * let v = calg.sub(z, w)
   * v instanceof C // true
   * v !== z // true
   * calg.eq(z, new C(1, 0)) // true
   * calg.eq(v, new C(1, 1)) // true
   */
  sub (z, w) {
    return this.isub(this.copy(z), w)
  }

  /**
   * @desc
   * The ComplexAlgebra#isub method subtracts `w` from `z` *in place*.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * `z`, or a new {@link ComplexAlgebraicElement} if `z` is not a
   * {@link ComplexAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1)
   * let w = calg.num(-1, 1, -1)
   * let v = z
   *
   * // GOOD-PRACTICE!
   * z = calg.isub(z, w)
   * z === v // true
   * z instanceof C // true
   * calg.eq(z, new C(1, 1)) // true
   */
  isub (z, w) {
    z = this.cast(z);
    w = this.cast(w);
    const ralg = this.ralg;
    z.re = ralg.isub(z.re, w.re);
    z.im = ralg.isub(z.im, w.im);
    return z
  }

  /**
   * @desc
   * The ComplexAlgebra#mul method returns the result of
   * the multiplication `z` times `w`.
   *
   * `calg.mul(z, w)` is an alias for `calg.imul(calg.copy(z), w)`,
   * where `calg` is an instance of {@link ComplexAlgebra}.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * a new {@link ComplexAlgebraicElement}
   * representing the result of the multiplication `z` times `w`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1, 2, 5)
   * let w = calg.num(-1, 2, -5)
   *
   * let v = calg.mul(z, w)
   * v instanceof C // true
   * v !== z // true
   * calg.eq(z, new C(ralg.num(1, 2, 5), 0)) // true
   * calg.eq(v, new C(0, ralg.num(-5, 4))) // true
   */
  mul (z, w) {
    return this.imul(this.copy(z), w)
  }

  /**
   * @desc
   * The ComplexAlgebra#imul method multiplies `z` by `w` *in place*.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * `z`, or a new {@link ComplexAlgebraicElement} if `z` is not a
   * {@link ComplexAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.num(1, 2, 5)
   * let w = calg.num(-1, 2, -5)
   * let v = z
   *
   * // GOOD-PRACTICE!
   * z = calg.imul(z, w)
   * z === v // true
   * z instanceof C // true
   * calg.eq(z, new C(0, ralg.num(-5, 4))) // true
   */
  imul (z, w) {
    z = this.cast(z);
    w = this.cast(w);
    const ralg = this.ralg;
    const d = w.im;
    const c = w.re;
    const bd = ralg.mul(z.im, d);
    const ad = ralg.mul(z.re, d);
    z.re = ralg.imul(z.re, c);
    z.re = ralg.isub(z.re, bd);
    z.im = ralg.imul(z.im, c);
    z.im = ralg.iadd(z.im, ad);
    return z
  }

  /**
   * @desc
   * The ComplexAlgebra#div method returns the result of
   * the division `z` over `w`.
   *
   * `calg.div(z, w)` is an alias for `calg.idiv(calg.copy(z), w)`,
   * where `calg` is an instance of {@link ComplexAlgebra}.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * a new {@link ComplexAlgebraicElement}
   * representing the result of the division `z` over `w`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   * let w = calg.iadd(calg.num(1), calg.inum(-1))
   *
   * let v = calg.div(z, w)
   * v instanceof C // true
   * v !== z // true
   * calg.eq(z, new C(1, -1)) // true
   * calg.eq(v, new C(1, 0)) // true
   */
  div (z, w) {
    return this.idiv(this.copy(z), w)
  }

  /**
   * @desc
   * The ComplexAlgebra#idiv method divides `z` by `w` *in place*.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @param {ComplexAlgebraicElement} w
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * `z`, or a new {@link ComplexAlgebraicElement} if `z` is not a
   * {@link ComplexAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   * let w = calg.iadd(calg.num(1), calg.inum(-1))
   * let v = z
   *
   * // GOOD-PRACTICE!
   * z = calg.idiv(z, w)
   * z === v // true
   * z instanceof C // true
   * calg.eq(z, new C(1, 0)) // true
   */
  idiv (z, w) {
    z = this.cast(z);
    w = this.cast(w);
    const abs2w = this.abs2(w);
    const ralg = this.ralg;
    const d = w.im;
    const c = w.re;
    const bd = ralg.mul(z.im, d);
    const ad = ralg.mul(z.re, d);
    z.re = ralg.imul(z.re, c);
    z.re = ralg.iadd(z.re, bd);
    z.re = ralg.idiv(z.re, abs2w);
    z.im = ralg.imul(z.im, c);
    z.im = ralg.isub(z.im, ad);
    z.im = ralg.idiv(z.im, abs2w);
    return z
  }

  /**
   * @desc
   * The ComplexAlgebra#neg method returns the result of
   * the multiplication `z` times `-1`.
   *
   * `calg.neg(z)` is an alias for `calg.ineg(calg.copy(z))`,
   * where `calg` is an instance of {@link ComplexAlgebra}.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * a new {@link ComplexAlgebraicElement}
   * representing the result of the multiplication `z` times `-1`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   *
   * let w = calg.neg(z)
   * w instanceof C // true
   * w !== z // true
   * calg.eq(z, new C(1, -1)) // true
   * calg.eq(w, new C(-1, 1)) // true
   */
  neg (z) {
    return this.ineg(this.copy(z))
  }

  /**
   * @desc
   * The ComplexAlgebra#ineg method multiplies `z` by `-1` *in place*.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * `z`, or a new {@link ComplexAlgebraicElement} if `z` is not a
   * {@link ComplexAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   * let w = z
   *
   * // GOOD-PRACTICE!
   * z = calg.ineg(z)
   * z === w // true
   * z instanceof C // true
   * calg.eq(z, new C(-1, 1)) // true
   */
  ineg (z) {
    z = this.cast(z);
    const ralg = this.ralg;
    z.re = ralg.ineg(z.re);
    z.im = ralg.ineg(z.im);
    return z
  }

  /**
   * @desc
   * The ComplexAlgebra#cjg method returns the complex conjugate of `z`.
   *
   * `calg.cjg(z)` is an alias for `calg.icjg(calg.copy(z))`,
   * where `calg` is an instance of {@link ComplexAlgebra}.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * a new {@link ComplexAlgebraicElement}
   * representing the complex conjugate of `z`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   *
   * let w = calg.cjg(z)
   * w instanceof C // true
   * w !== z // true
   * calg.eq(z, new C(1, -1)) // true
   * calg.eq(w, new C(1, 1)) // true
   */
  cjg (z) {
    return this.icjg(this.copy(z))
  }

  /**
   * @desc
   * The ComplexAlgebra#icjg method
   * evaluates the complex conjugate of `z` and stores the result to `z`.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {ComplexAlgebraicElement}
   * `z`, or a new {@link ComplexAlgebraicElement} if `z` is not a
   * {@link ComplexAlgebraicElement}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   * let w = z
   *
   * // GOOD-PRACTICE!
   * z = calg.icjg(z)
   * z === w // true
   * z instanceof C // true
   * calg.eq(z, new C(1, 1)) // true
   */
  icjg (z) {
    z = this.cast(z);
    z.im = this.ralg.ineg(z.im);
    return z
  }

  /**
   * @desc
   * The ComplexAlgebra#abs method returns the absolute value of `z`.
   *
   * CAUTION: this method is not implemented for exact algebra.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a {@link RealAlgebraicElement}
   * representing the absolute value of `z`.
   *
   * @throws {Error}
   * if `this` is an implementation of exact algebra.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   *
   * calg.abs(z) // Error
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   *
   * let w = calg.abs(z)
   * w instanceof C // false
   * typeof w === 'number' // true
   * calg.eq(z, new C(1, -1)) // true
   * ralg.eq(w, Math.sqrt(2)) // true
   */
  abs (z) {
    if (this.isExact()) {
      throw Error('`abs` is not implemented for exact algebra.')
    } else {
      return Math.sqrt(this.abs2(z))
    }
  }

  /**
   * @desc
   * The ComplexAlgebra#abs2 method returns
   * the square of the absolute value of `z`.
   *
   * @param {ComplexAlgebraicElement} z
   * a {@link ComplexAlgebraicElement}.
   *
   * @return {RealAlgebraicElement}
   * a {@link RealAlgebraicElement}
   * representing the square of the absolute value of `z`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra, Polynomial as P }
   *   from '@kkitahara/real-algebra'
   * import { ComplexAlgebraicElement as C, ComplexAlgebra }
   *   from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1), calg.inum(-1))
   *
   * let w = calg.abs2(z)
   * w instanceof C // false
   * w instanceof P // true
   * calg.eq(z, new C(1, -1)) // true
   * ralg.eq(w, ralg.num(2)) // true
   */
  abs2 (z) {
    z = this.cast(z);
    const ralg = this.ralg;
    return ralg.iadd(ralg.abs2(z.re), ralg.abs2(z.im))
  }

  /**
   * @desc
   * The reviver function for the {@link ComplexAlgebraicElement}s.
   *
   * @type {Function}
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import {ExactRealAlgebra as RealAlgebra} from '@kkitahara/real-algebra'
   * import { ComplexAlgebra } from '@kkitahara/complex-algebra'
   * let ralg = new RealAlgebra()
   * let calg = new ComplexAlgebra(ralg)
   *
   * let z = calg.iadd(calg.num(1, 2, 5), calg.inum(-1, 2, 7))
   * let str = JSON.stringify(z)
   * let w = JSON.parse(str, calg.reviver)
   * calg.eq(z, w) // true
   */
  get reviver () {
    const ralg = this.ralg;
    return function (key, value) {
      value = ralg.reviver(key, value);
      value = ComplexAlgebraicElement.reviver(key, value);
      return value
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/polytope-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @typedef {Object|number}
 * RealAlgebraicElement
 *
 * @desc
 * A RealAlgebraicElement denotes a number supported by @kkitahara/real-algebra.
 */

/**
 * @desc
 * `OUTSIDE_OF_FACET = 1` is returned by
 * {@link Facet#position} method if a vector is outside of the facet.
 *
 * @type {number}
 *
 * @version 1.0.0
 * @since 1.0.0
 */
const OUTSIDE_OF_FACET = 1;
/**
 * @desc
 * `ON_FACET = 0` is returned by
 * {@link Facet#position} method if a vector is on the facet.
 *
 * @type {number}
 *
 * @version 1.0.0
 * @since 1.0.0
 */
const ON_FACET = 0;
/**
 * @desc
 * `INSIDE_OF_FACET = -1` is returned by
 * {@link Facet#position} method if a vector is inside of the facet.
 *
 * @type {number}
 *
 * @version 1.0.0
 * @since 1.0.0
 */
const INSIDE_OF_FACET = -1;

/**
 * @desc
 * The Facet class
 * is a class for facets of comvex polytopes.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class Facet {
  /**
   * @desc
   * The constructor function of the {@link Facet} class.
   *
   * CAUTION: this constructor function does not check if `d`
   * is a valid {@link RealAlgebraicElement}.
   *
   * @param {Matrix} nvec
   * a {@link Matrix} representing the normal vector of the new {@link Facet}.
   *
   * @param {RealAlgebraicElement} d
   * a {@link RealAlgebraicElement} which is equal to
   * the dot product of `nvec` and a vertex on the new {@link Facet}.
   * If `nvec.length === 0`, `d` is set at `0`.
   *
   * @param {boolean} faceOutside
   * `nvec` is considered to face toward outside/inside
   * of the new {@link Facet} if `faceOutside` is `true`/`false`.
   *
   * @throws {Error}
   * if `nvec` is not an adaptive {@link Matrix}.
   *
   * @version 1.1.4
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   *
   * const m = new M(1, 2, 3)
   * const d = 2
   * const f = new Facet(m, d, true)
   *
   * f instanceof Facet // true
   * f.nvec === m // true
   * f.faceOutside // true
   * f.d === d // true
   * f.vertices instanceof Array // true
   * f.vertices.length === 0 // true
   *
   * const f2 = new Facet(m, d, false)
   *
   * f2 instanceof Facet // true
   * f2.faceOutside // false
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   *
   * const m = new M(1, 2, 3, 4).setDim(1, 4)
   * const d = 2
   * // `m` is not a vector
   * new Facet(m, d, true) // Error
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   *
   * // no facet in 0-dim
   * new Facet(new M(), 1, true) // Error
   */
  constructor (nvec, d, faceOutside) {
    if (!(nvec instanceof Matrix && nvec.length > 0 && nvec.isAdaptive())) {
      throw Error('`nvec` must be an adaptive matrix of at least one element.')
    }
    /**
     * @desc
     * Facet#nvec represents the normal vector of `this`.
     * No copy is generated on construction, i.e. the reference is stored.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.nvec = nvec;
    /**
     * @desc
     * Facet#d is equal to the dot product of `nvec` and a vertex on this facet.
     * No copy is generated on construction, i.e. the reference is stored.
     *
     * @type {RealAlgebraicElement}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.d = d;
    /**
     * @desc
     * Facet#nvec is considered to face toward outside/inside
     * of this facet if `faceOutside` is `true`/`false`.
     *
     * @type {boolean}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.faceOutside = faceOutside;
    /**
     * @desc
     * Facet#vertices sotres the references to the vertices on `this` facet.
     *
     * @type {Array}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.vertices = [];
  }

  /**
   * @desc
   * The Facet#dim method returns the dimension of `this`.
   * The dimension of a facet is equal to that of the normal vector.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   *
   * const m = new M(1, 2, 3, 4)
   * const d = 2
   * const f = new Facet(m, d, true)
   *
   * f.dim // 4
   */
  get dim () {
    return this.nvec.length
  }

  /**
   * @desc
   * The Facet#copy method returns a new instance of {@link Facet}
   * which has copies of `this.d` and `this.faceOutside`,
   * a shallow copy of `this.vertices` and a reference to `this.nvec`.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Facet}
   * a new instance of {@link Facet}.
   *
   * @throws {Error}
   * if `lalg` is not an instance of `LinearAlgebra`.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m = l.$(1, 2, 3)
   * const d = 2
   * const f = new Facet(m, d, true)
   * // ANTI-PATTERN
   * // this is just for a test, vertices must be on the facet
   * const v = l.$(0, 0, 0)
   * f.vertices.push(v)
   * const f2 = f.copy(l)
   *
   * f2 instanceof Facet // true
   * f2.nvec === m // true
   * f2.faceOutside // true
   * f2.d === d // false
   * r.eq(f2.d, d) // true
   * f2.vertices instanceof Array // true
   * f2.vertices.length === 1 // true
   * f2.vertices[0] === v // true
   *
   * // invalid parameter
   * f.copy(null) // Error
   */
  copy (lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    const salg = lalg.salg;
    const f = new Facet(this.nvec, salg.copy(this.d), this.faceOutside);
    f.vertices.push(...this.vertices);
    return f
  }

  /**
   * @desc
   * The Facet#replaceVertices method
   * replaces vertices according to the given map.
   *
   * @param {WeakMap} vMap
   * a {@link WeakMap} object for replacing.
   *
   * @return {Facet}
   * `this`.
   *
   * @throws {Error}
   * if `vMap` is not a `WeakMap` object.
   *
   * @throws {Error}
   * if `vMap` does not have a vertex of `this` facet as a key.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m = l.$(1, 2, 3)
   * const d = 2
   * const f = new Facet(m, d, true)
   * // ANTI-PATTERN
   * // this is just for a test, vertices must be on the facet
   * const v = l.$(0, 0, 0)
   * const v2 = l.$(1, 0, 0)
   * f.vertices.push(v)
   * const vMap = new WeakMap()
   *
   * vMap.set(v, v2)
   * f.vertices[0] === v // true
   * f.replaceVertices(vMap)
   * f.vertices[0] === v2 // true
   *
   * f.replaceVertices(vMap) // Error
   * f.replaceVertices(null) // Error
   */
  replaceVertices (vMap) {
    if (!(vMap instanceof WeakMap)) {
      throw Error('`vMap` must be an instance of `WeakMap`.')
    }
    for (let i = this.vertices.length - 1; i >= 0; i -= 1) {
      const v = vMap.get(this.vertices[i]);
      if (v === undefined) {
        throw Error('`vMap` does not have a vertex of `this` as a key.')
      }
      this.vertices[i] = v;
    }
    return this
  }

  /**
   * @desc
   * The Facet#position method compares the position `v` to `this.d`.
   *
   * @param {Matrix} v
   * a {@link Matrix} representing a vector.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {number}
   * `-1` if `v` is inside of of `this`.
   *
   * `0` if `v` is on `this`.
   *
   * `1` if `v` is outside of `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of `LinearAlgebra`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of real algebra.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * import { Facet, OUTSIDE_OF_FACET, ON_FACET, INSIDE_OF_FACET }
   *   from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const r2 = new RealAlgebra(0.1)
   * const l = new LinearAlgebra(r)
   * const l2 = new LinearAlgebra(r2)
   *
   * const m = new M(1, 1, 1)
   * const d = 3
   * const f = new Facet(m, d, true)
   * const v1 = new M(0.99, 1, 1)
   * const v2 = new M(1, 1, 1)
   * const v3 = new M(1, 1, 1.01)
   *
   * f.position(v1, l) // INSIDE_OF_FACET
   * f.position(v2, l) // ON_FACET
   * f.position(v3, l) // OUTSIDE_OF_FACET
   *
   * f.position(v1, l2) // ON_FACET
   * f.position(v2, l2) // ON_FACET
   * f.position(v3, l2) // ON_FACET
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra, Matrix as M } from '@kkitahara/linear-algebra'
   * import { Facet, OUTSIDE_OF_FACET, ON_FACET, INSIDE_OF_FACET }
   *   from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const r2 = new RealAlgebra(0.1)
   * const l = new LinearAlgebra(r)
   * const l2 = new LinearAlgebra(r2)
   *
   * const m = new M(1, 1, 1)
   * const d = 3
   * const f = new Facet(m, d, false)
   * const v1 = new M(0.99, 1, 1)
   * const v2 = new M(1, 1, 1)
   * const v3 = new M(1, 1, 1.01)
   *
   * f.position(v1, l) // OUTSIDE_OF_FACET
   * f.position(v2, l) // ON_FACET
   * f.position(v3, l) // INSIDE_OF_FACET
   *
   * f.position(v1, l2) // ON_FACET
   * f.position(v2, l2) // ON_FACET
   * f.position(v3, l2) // ON_FACET
   *
   * l2.isReal = () => false
   * f.position(v1, l2) // Error
   * f.position(v1, null) // Error
   */
  position (v, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (!lalg.isReal()) {
      throw Error('`lalg` must be an implementation of real algebra.')
    }
    const ralg = lalg.salg;
    const dd = ralg.isub(lalg.dot(this.nvec, v), this.d);
    if (ralg.isZero(dd)) {
      return ON_FACET
    } else if (ralg.isPositive(dd) === this.faceOutside) {
      return OUTSIDE_OF_FACET
    } else {
      return INSIDE_OF_FACET
    }
  }

  /**
   * @desc
   * The Facet#irotate method
   * rotates `this` by a rotation matrix `m` *in place*.
   * A rotation matrix is a orthogonal matrix,
   * i.e. its inverse is equal to its transpose.
   *
   * CAUTION: this method does not check if `m` is an orthogonal matrix.
   *
   * CAUTION: this method does not change the vertices on `this`.
   * Use {@link Facet#replaceVertices} to replace the vertices with
   * the rotated vertices.
   *
   * @param {Matrix} m
   * an instance of {@link Matrix} representing an orthogonal matrix.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Facet}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @throws {Error}
   * if `m` is not a square matrix of the same dimension as `this`.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m = l.$(1, 1)
   * const d = 1
   * const f = new Facet(m, d, true)
   * const f2 = f.irotate(l.$(0, 1, -1, 0).setDim(2), l)
   * f2 instanceof Facet // true
   * f2 === f // true
   * f2.nvec === m // false
   * l.eq(f2.nvec, l.$(1, -1)) // true
   * f2.d // 1
   *
   * f.irotate(l.$(0, 1, -1, 0), l) // Error
   * f.irotate(l.$(0, 1, -1, 0).setDim(2, 2), null) // Error
   * f.irotate(null, l) // Error
   * f.irotate(l.$(0, 1, -1, 0).setDim(1, 4), l) // Error
   * f.irotate(l.$(1).setDim(1), l) // Error
   */
  irotate (m, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    m = lalg.cast(m);
    if (!m.isSquare() || m.getDim()[0] !== this.dim) {
      throw Error('`m` must be a square matrix of the same dimension as ' +
          '`this`.')
    }
    this.nvec = lalg.mmul(m, this.nvec);
    return this
  }

  /**
   * @desc
   * The Facet#itranslate method translates `this` by `v` *in place*.
   *
   * @param {Matrix} v
   * an instance of {@link Matrix} representing a vector.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Facet}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m = l.$(1, 1)
   * const d = 1
   * const f = new Facet(m, d, true)
   * const f2 = f.itranslate([1, 1], l)
   * f2 instanceof Facet // true
   * f2 === f // true
   * f2.nvec === m // true
   * f2.d // 3
   *
   * f.itranslate([1, 1], null) // Error
   * f.itranslate(null, l) // Error
   */
  itranslate (v, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    const salg = lalg.salg;
    this.d = salg.iadd(this.d, lalg.dot(this.nvec, v));
    return this
  }

  /**
   * @desc
   * The Facet#iscale method scales `this` by `s` *in place* around
   * the origin.
   *
   * @param {RealAlgebraicElement} s
   * a {@link RealAlgebraicElement} representing a scale factor.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Facet}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m = l.$(1, 1)
   * const d = 1
   * const f = new Facet(m, d, true)
   * const f2 = f.iscale(2, l)
   * f2 instanceof Facet // true
   * f2 === f // true
   * f2.nvec === m // true
   * f2.d // 2
   *
   * f.iscale(2, null) // Error
   */
  iscale (s, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    const salg = lalg.salg;
    this.d = salg.imul(this.d, s);
    return this
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/polytope-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The Edge class is a class for edges of convex polytopes.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class Edge {
  /**
   * @desc
   * The constructor function of the {@link Edge} class.
   *
   * @param {Matrix} v0
   * a {@link Matrix} representing a vertex of the new {@link Edge}.
   *
   * @param {Matrix} v1
   * a {@link Matrix} representing the other vertex of the new {@link Edge}.
   *
   * @throws {Error}
   * if `v0` or `v1` is not an adaptive {@link Matrix}.
   *
   * @throws {Error}
   * if the lengths (dimension) of `v0` and `v1` are not the same.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Edge } from '@kkitahara/polytope-algebra'
   *
   * const m1 = new M(1, 1, 1)
   * const m2 = new M(2, 1, 1)
   * const e = new Edge(m1, m2)
   *
   * e instanceof Edge // true
   * e.v0 === m1 // true
   * e.v1 === m2 // true
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Edge } from '@kkitahara/polytope-algebra'
   *
   * const m1 = new M(1, 1, 1)
   * const m2 = new M(2, 1, 1)
   *
   * new Edge(new M(1, 1, 1).setDim(1, 3), m2) // Error
   * new Edge(m1, new M(2, 1, 1).setDim(1, 3)) // Error
   *
   * new Edge(new M(1, 1, 1, 1), m2) // Error
   * new Edge(m1, new M(2, 1, 1, 1)) // Error
   *
   * new Edge(new M(), m2) // Error
   * new Edge(m1, new M()) // Error
   */
  constructor (v0, v1) {
    if (!(v0 instanceof Matrix && v0.length > 0 && v0.isAdaptive())) {
      throw Error('`v0` must be an adaptive matrix of at least one element.')
    }
    if (!(v1 instanceof Matrix && v1.length > 0 && v1.isAdaptive())) {
      throw Error('`v1` must be an adaptive matrix of at least one element.')
    }
    const dim = v0.length;
    if (dim !== v1.length) {
      throw Error('the lengths of `v0` and `v1` must be the same.')
    }
    /**
     * @desc
     * Edge#v0 stores the reference to the first vertex `v0`.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.v0 = v0;
    /**
     * @desc
     * Edge#v1 stores the reference to the second vertex `v1`.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.v1 = v1;
  }

  /**
   * @desc
   * The Edge#dim method returns the dimension of `this`.
   * The dimension of an edge is equal to that of the first vertex `v0`.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Edge } from '@kkitahara/polytope-algebra'
   *
   * const m1 = new M(1, 1, 1)
   * const m2 = new M(2, 1, 1)
   * const e = new Edge(m1, m2)
   *
   * e.dim // 3
   */
  get dim () {
    return this.v0.length
  }

  /**
   * @desc
   * The Edge#copy method returns a new instance of {@link Edge}
   * which has references to `this.v0` and `this.v1`.
   *
   * @return {Edge}
   * a new instance of {@link Edge}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Edge } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m1 = l.$(1, 1, 1)
   * const m2 = l.$(2, 1, 1)
   * const e = new Edge(m1, m2)
   * const e2 = e.copy()
   *
   * e2 instanceof Edge // true
   * e2.v0 === m1 // true
   * e2.v1 === m2 // true
   */
  copy () {
    return new Edge(this.v0, this.v1)
  }

  /**
   * @desc
   * The Edge#replaceVertices method
   * replaces vertices according to the given map.
   *
   * @param {WeakMap} vMap
   * a {@link WeakMap} object for replacing.
   *
   * @return {Edge}
   * `this`.
   *
   * @throws {Error}
   * if `vMap` is not a `WeakMap` object.
   *
   * @throws {Error}
   * if `vMap` does not have a vertex of `this` facet as a key.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Edge } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m1 = l.$(1, 1, 1)
   * const m2 = l.$(2, 1, 1)
   * const m3 = l.$(3, 1, 1)
   * const m4 = l.$(4, 1, 1)
   * const e = new Edge(m1, m2)
   * const vMap = new WeakMap()
   * vMap.set(m1, m3)
   * vMap.set(m2, m4)
   * e.replaceVertices(vMap)
   * e.v0 === m3 // true
   * e.v1 === m4 // true
   *
   * e.replaceVertices(vMap) // Error
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Edge } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const m1 = l.$(1, 1, 1)
   * const m2 = l.$(2, 1, 1)
   * const m3 = l.$(3, 1, 1)
   * const e = new Edge(m1, m2)
   * const vMap = new WeakMap()
   * e.replaceVertices(vMap) // Error
   * vMap.set(m1, m3)
   * e.replaceVertices(vMap) // Error
   * e.replaceVertices(null) // Error
   */
  replaceVertices (vMap) {
    if (!(vMap instanceof WeakMap)) {
      throw Error('`vMap` must be an instance of `WeakMap`.')
    }
    let v = vMap.get(this.v0);
    if (v === undefined) {
      throw Error('`vMap` does not have a vertex of `this` as a key.')
    }
    this.v0 = v;
    v = vMap.get(this.v1);
    if (v === undefined) {
      throw Error('`vMap` does not have a vertex of `this` as a key.')
    }
    this.v1 = v;
    return this
  }

  /**
   * @desc
   * The Edge#isIdentical method checks if
   * `this` is identical to `another`.
   * Two edges are identical if the two associated
   * vectors are the same objects irrespective of the order.
   *
   * @param {Edge} another
   * another {@link Edge}.
   *
   * @return {boolean}
   * `true` if `this` is identical to `another`.
   *
   * @throws {Error}
   * if `another` is not an {@link Edge}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Edge } from '@kkitahara/polytope-algebra'
   *
   * const m1 = new M(1, 1, 1)
   * const m2 = new M(2, 1, 1)
   * const e1 = new Edge(m1, m2)
   * const e2 = new Edge(m1, m2)
   * const e3 = new Edge(m2, m1)
   * const e4 = new Edge(m1, new M(2, 1, 1))
   * const e5 = new Edge(m2, new M(1, 1, 1))
   *
   * e1.isIdentical(e1) // true
   * e1.isIdentical(e2) // true
   * e1.isIdentical(e3) // true
   * e1.isIdentical(e4) // false
   * e1.isIdentical(e5) // false
   * e1.isIdentical(null) // Error
   */
  isIdentical (another) {
    if (!(another instanceof Edge)) {
      throw Error('`another` must be an `Edge`.')
    }
    return (this.v0 === another.v0 && this.v1 === another.v1) ||
        (this.v0 === another.v1 && this.v1 === another.v0)
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/polytope-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The ConvexPolytope class is a class for convex polytopes.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class ConvexPolytope {
  /**
   * @desc
   * The constructor function of the {@link ConvexPolytope} class.
   *
   * CAUTION: this constructor function does not check if
   * the elements of the parameters are valid.
   *
   * CAUTION: if two facets share a same normal vector
   * (irrespective of the direction), that vector must be the same object.
   *
   * @param {Array} [facets = []]
   * an {@link Array} containing the facets of the new {@link ConvexPolytope}.
   *
   * @param {Array} [vertices = []]
   * an {@link Array} containing the vertices
   * of the new {@link ConvexPolytope}.
   *
   * @param {Array} [edges = []]
   * an {@link Array} containing the edges
   * of the new {@link ConvexPolytope}.
   *
   * @param {boolean} [weight = true]
   * this is used by {@link AnotherPolytopeAlgebra}.
   *
   * @throws {Error}
   * if a parameter is not an {@link Array}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ConvexPolytope } from '@kkitahara/polytope-algebra'
   *
   * const facets = []
   * const vertices = []
   * const edges = []
   * const a = new ConvexPolytope(facets, vertices, edges)
   *
   * a instanceof ConvexPolytope // true
   * a.facets === facets // true
   * a.vertices === vertices // true
   * a.edges === edges // true
   *
   * const b = new ConvexPolytope()
   * b instanceof ConvexPolytope // true
   * b.facets instanceof Array // true
   * b.facets.length === 0 // true
   * b.vertices instanceof Array // true
   * b.vertices.length === 0 // true
   * b.edges instanceof Array // true
   * b.edges.length === 0 // true
   * b.weight // true
   *
   * new ConvexPolytope(null, vertices, edges) // Error
   * new ConvexPolytope(facets, null, edges) // Error
   * new ConvexPolytope(facets, vertices, null) // Error
   * new ConvexPolytope(facets, vertices, edges, null) // Error
   */
  constructor (facets = [], vertices = [], edges = [], weight = true) {
    if (!(facets instanceof Array)) {
      throw Error('`facets` must be an array.')
    }
    if (!(vertices instanceof Array)) {
      throw Error('`vertices` must be an array.')
    }
    if (!(edges instanceof Array)) {
      throw Error('`edges` must be an array.')
    }
    if (typeof weight !== 'boolean') {
      throw Error('`weight` must be a boolean.')
    }
    this.facets = facets;
    this.vertices = vertices;
    this.edges = edges;
    this.weight = weight;
  }

  /**
   * @desc
   * The ConvexPolytope#dim method returns the dimension of `this`.
   * The dimension of a convex polytope is equal to that of the first facet.
   *
   * @type {number}
   *
   * @throws {Error}
   * if `this` has no facet.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { ConvexPolytope } from '@kkitahara/polytope-algebra'
   *
   * // ANTI-PATTERN
   * // This is just for a test.
   * // In practice, facets, vertices and edges must be consistently given.
   * let a = new ConvexPolytope([], [new M(1, 2), new M(1, 2, 3)])
   * a.dim // 2
   *
   * a = new ConvexPolytope([], [new M()])
   * a.dim // 0
   *
   * // throws an Error if there is no vertex
   * new ConvexPolytope().dim // Error
   */
  get dim () {
    if (this.isNull()) {
      throw Error('the dimension of a null polytope cannot be ditermined.')
    }
    return this.vertices[0].length
  }

  /**
   * @desc
   * The ConvexPolytope#copy method returns a new instance of
   * {@link ConvexPolytope}
   * which has copies of facets (as generated by Facet#copy),
   * vertices (deep copy) and edges (as generated by Edge#copy).
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {ConvexPolytope}
   * a new instance of {@link ConvexPolytope}.
   *
   * @throws {Error}
   * if `lalg` is not an instance of `LinearAlgebra`.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.copy(l)
   * cp2.facets.length // 4
   * cp2.vertices.length // 4
   * cp2.edges.length // 4
   * cp.facets !== cp2.facets // true
   * cp.facets[0] !== cp2.facets[0] // true
   * cp.facets[0].nvec === cp2.facets[0].nvec // true
   * cp.facets[0].d !== cp2.facets[0].d // true
   * cp.facets[0].vertices !== cp2.facets[0].vertices // true
   * cp.facets[0].vertices[0] === cp2.facets[0].vertices[0] // false
   * cp.vertices !== cp2.vertices // true
   * cp.vertices[0] === cp2.vertices[0] // false
   * cp.edges !== cp2.edges // true
   * cp.edges[0] !== cp2.edges[0] // true
   * cp.edges[0].v0 === cp2.edges[0].v0 // false
   *
   * cp.copy(null) // Error
   */
  copy (lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    const vertices = this.vertices.slice();
    const vMap = new WeakMap();
    for (let i = vertices.length - 1; i >= 0; i -= 1) {
      const v = lalg.copy(vertices[i]);
      vMap.set(vertices[i], v);
      vertices[i] = v;
    }
    const facets = this.facets.slice();
    const edges = this.edges.slice();
    for (let i = facets.length - 1; i >= 0; i -= 1) {
      facets[i] = facets[i].copy(lalg);
      facets[i].replaceVertices(vMap);
    }
    for (let i = edges.length - 1; i >= 0; i -= 1) {
      edges[i] = edges[i].copy();
      edges[i].replaceVertices(vMap);
    }
    return new ConvexPolytope(facets, vertices, edges, this.weight)
  }

  /**
   * @desc
   * The ConvexPolytope#isNull method checks if `this` is a null polytope.
   * `this` is considered to be a null polytope if it has no {@link Facet}.
   *
   * @return {boolean}
   * `true` if `this` is a null polytope (`this.facets.length === 0`)
   * and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { ConvexPolytope } from '@kkitahara/polytope-algebra'
   *
   * // ANTI-PATTERN
   * // This is just for a test.
   * // In practice, facets, vertices and edges must be consistently given.
   * const a = new ConvexPolytope([], [new M(1)])
   *
   * a.isNull() // false
   * new ConvexPolytope().isNull() // true
   */
  isNull () {
    return this.vertices.length === 0
  }

  /**
   * @desc
   * The ConvexPolytope#nullify method nullifies `this`.
   *
   * @return {ConvexPolytope}
   * `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { Matrix as M } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   *
   * const f1 = new Facet(new M(1, 1), 2, true)
   * const f2 = new Facet(new M(1, 1, 3), 2, true)
   *
   * // ANTI-PATTERN
   * // This is just for a test.
   * // In practice, facets, vertices and edges must be consistently given.
   * const facets = [f1, f2]
   * const a = new ConvexPolytope(facets, [1], [2, 3, 4])
   *
   * a.isNull() // false
   * a.facets.length // 2
   * a.vertices.length // 1
   * a.edges.length // 3
   *
   * a.nullify()
   * a.isNull() // true
   * a.facets.length // 0
   * a.vertices.length // 0
   * a.edges.length // 0
   */
  nullify () {
    this.facets.length = 0;
    this.vertices.length = 0;
    this.edges.length = 0;
    return this
  }

  /**
   * @desc
   * The ConvexPolytope#iaddFacet method adds a new facet to `this`,
   * find new vertices and new edges,
   * and removes obsolete facets, vertices and edges.
   * No copy of `newFacet` is generated.
   *
   * CAUTION: fast check must be done before calling this method.
   * See PolytopeAlgebra#iaddFacet or ConvexPolytope#mul for more detail.
   *
   * @param {Facet} newFacet
   * a {@link Facet} to be added.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {ConvexPolytope}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @throws {Error}
   * if `lalg` is not an implementation of real algebra.
   *
   * @throws {Error}
   * if `newFacet` is not an instance of {@link Facet}.
   *
   * @throws {Error}
   * if the dimension of `newFacet` is different from that of `this`.
   *
   * @version 1.2.6
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * cp.facets.length // 4
   * cp.vertices.length // 4
   * cp.edges.length // 4
   *
   * let cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, 1, true), l)
   * cp2.facets.length // 4
   * cp2.vertices.length // 4
   * cp2.edges.length // 4
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, 1, false), l)
   * cp2.facets.length // 0
   * cp2.vertices.length // 0
   * cp2.edges.length // 0
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, -1, true), l)
   * cp2.facets.length // 0
   * cp2.vertices.length // 0
   * cp2.edges.length // 0
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, -1, false), l)
   * cp2.facets.length // 4
   * cp2.vertices.length // 4
   * cp2.edges.length // 4
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), 2, true), l)
   * cp2.facets.length // 4
   * cp2.vertices.length // 4
   * cp2.edges.length // 4
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), 1, true), l)
   * cp2.facets.length // 5
   * cp2.vertices.length // 5
   * cp2.edges.length // 5
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), 0, true), l)
   * cp2.facets.length // 3
   * cp2.vertices.length // 3
   * cp2.edges.length // 3
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), -1, true), l)
   * cp2.facets.length // 3
   * cp2.vertices.length // 3
   * cp2.edges.length // 3
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), -2, true), l)
   * cp2.facets.length // 0
   * cp2.vertices.length // 0
   * cp2.edges.length // 0
   *
   * // invalid parameters
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, 2, true), null) // Error
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(null, l) // Error
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1, 1), 1, true), l) // Error
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * p[0].nullify()
   *
   * const cp = p[0].iaddFacet(p2d.facet([0, 1], 1), l)
   * cp.isNull() // true
   *
   * l.isReal = () => false
   * p[0].iaddFacet(p2d.facet([0, 1], 1), l) // Error
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p3d = new PolytopeAlgebra(3, l)
   *
   * const p = p3d.hypercube(1)
   *
   * const cp = p[0].iaddFacet(p3d.facet([1, 1, 0], 0), l)
   * cp.facets.length // 5
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p1d = new PolytopeAlgebra(1, l)
   *
   * const p = p1d.hypercube(1)
   *
   * const cp = p[0].iaddFacet(p1d.facet([1], 0), l)
   * cp.facets.length // 2
   */
  iaddFacet (newFacet, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (!lalg.isReal()) {
      throw Error('`lalg` must be an implementation of real algebra.')
    }
    if (!(newFacet instanceof Facet)) {
      throw Error('`newFacet` is not a `Facet`.')
    }
    if (this.isNull()) {
      return this
    }
    const dim = this.dim;
    if (newFacet.dim !== dim) {
      throw Error('`newFacet.dim` and `this.dim1 must be the same.')
    }
    const ralg = lalg.salg;
    // find vertices removed by the new facet
    const vPosition = new WeakMap();
    {
      let removed = false;
      for (let i = this.vertices.length - 1; i >= 0; i -= 1) {
        const v = this.vertices[i];
        const position = newFacet.position(v, lalg);
        vPosition.set(v, position);
        if (position === OUTSIDE_OF_FACET) {
          this.vertices.splice(i, 1);
          removed = true;
        } else if (position === ON_FACET) {
          newFacet.vertices.push(v);
        }
      }
      if (!removed) {
        return this
      }
    }
    // find facets truncated by the new facet
    const truncatedFacets = [];
    for (let i = this.facets.length - 1; i >= 0; i -= 1) {
      const fi = this.facets[i];
      let vCount = 0;
      let truncated = false;
      for (let j = fi.vertices.length - 1; j >= 0; j -= 1) {
        const vj = fi.vertices[j];
        const position = vPosition.get(vj);
        if (position === OUTSIDE_OF_FACET) {
          fi.vertices.splice(j, 1);
          truncated = true;
        } else if (position === INSIDE_OF_FACET) {
          vCount += 1;
        }
      }
      if (vCount === 0) {
        this.facets.splice(i, 1);
      } else if (truncated) {
        truncatedFacets.push(fi);
      }
    }
    truncatedFacets.push(newFacet);
    // check if `this` still remains
    if (this.facets.length === 0) {
      this.nullify();
      return this
    }
    // add the new facet
    this.facets.push(newFacet);
    // find edges truncated by the new facet
    const truncatedEdges = [];
    const removedIndex = new WeakMap();
    for (let i = this.edges.length - 1; i >= 0; i -= 1) {
      const ei = this.edges[i];
      const position0 = vPosition.get(ei.v0);
      const position1 = vPosition.get(ei.v1);
      if (position0 === OUTSIDE_OF_FACET) {
        if (position1 === INSIDE_OF_FACET) {
          truncatedEdges.push(ei);
          removedIndex.set(ei, 0);
        } else {
          this.edges.splice(i, 1);
        }
      } else if (position0 === INSIDE_OF_FACET) {
        if (position1 === OUTSIDE_OF_FACET) {
          truncatedEdges.push(ei);
          removedIndex.set(ei, 1);
        }
      } else if (position1 === OUTSIDE_OF_FACET) {
        this.edges.splice(i, 1);
      }
    }
    // find new vertices
    const newVertices = [];
    for (let i = truncatedEdges.length - 1; i >= 0; i -= 1) {
      const ei = truncatedEdges[i];
      const v01 = lalg.sub(ei.v1, ei.v0);
      const dot0 = lalg.dot(newFacet.nvec, ei.v0);
      const dot01 = lalg.dot(newFacet.nvec, v01);
      const factor = ralg.idiv(ralg.sub(newFacet.d, dot0), dot01);
      const v = lalg.iadd(lalg.ismul(v01, factor), ei.v0);
      this.vertices.push(v);
      newVertices.push(v);
      if (removedIndex.get(ei) === 0) {
        ei.v0 = v;
      } else {
        ei.v1 = v;
      }
    }
    // find new vertices on each facets
    for (let i = truncatedFacets.length - 1; i >= 0; i -= 1) {
      const fi = truncatedFacets[i];
      for (let j = newVertices.length - 1; j >= 0; j -= 1) {
        const vj = newVertices[j];
        if (fi.position(vj, lalg) === ON_FACET) {
          fi.vertices.push(vj);
        }
      }
    }
    // find new edges
    if (dim > 1) {
      const facets = this.facets;
      const fi = newFacet;
      const vfi = fi.vertices;
      const ridges = [];
      for (let j = facets.length - 1; j >= 0; j -= 1) {
        const fj = facets[j];
        if (fj === fi) {
          continue
        }
        const vfj = vfi.filter(v => fj.vertices.indexOf(v) !== -1);
        if (
          vfj.length > dim - 2 &&
          vfi.length !== vfj.length &&
          ridges.every(r =>
            r.vertices.length !== vfj.length ||
            r.vertices.some((vrk, k) => vrk !== vfj[k])
          )
        ) {
          ridges.push({ vertices: vfj });
        }
      }
      const edges = ConvexPolytope.genEdges(dim - 1, ridges);
      const newEdges = [];
      for (let i = edges.length - 1; i >= 0; i -= 1) {
        const ei = edges[i];
        if (this.edges.every((e) => {
          return !ei.isIdentical(e)
        })) {
          newEdges.push(ei);
        }
      }
      this.edges.push(...newEdges);
    }
    return this
  }

  /**
   * @desc
   * The ConvexPolytope#imul method
   * calculates the intersection of `this` and `another` *in-place*
   * and returns `this`.
   *
   * @param {ConvexPolytope} another
   * another instance of {@link ConvexPolytope}.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {ConvexPolytope}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @throws {Error}
   * if `lalg` is not an implementation of real algebra.
   *
   * @throws {Error}
   * if `another` is not an instance of {@link ConvexPolytope}.
   *
   * @throws {Error}
   * if the dimension of `another` is different from that of `this`.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * let facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * let vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * let edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   *
   * facets = [
   *   new Facet(x, 2, true),
   *   new Facet(x, 0, false),
   *   new Facet(y, 2, true),
   *   new Facet(y, 0, false)]
   * vertices = [
   *   l.$(2, 2),
   *   l.$(0, 2),
   *   l.$(2, 0),
   *   l.$(0, 0)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * edges = ConvexPolytope.genEdges(2, facets)
   * const cp2 = new ConvexPolytope(facets, vertices, edges)
   *
   * const cp3 = cp.imul(cp2, l)
   * cp3.facets.length // 4
   * cp3.vertices.length // 4
   * cp3.edges.length // 4
   *
   * cp.imul(cp2, null) // Error
   * cp.imul(null, l) // Error
   * cp2.vertices[0] = l.$(1, 1, 1)
   * cp.imul(cp2, l) // Error
   *
   * cp2.nullify()
   * const cp4 = cp.imul(cp2, l)
   * cp4.facets.length // 0
   * cp4.vertices.length // 0
   * cp4.edges.length // 0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * p[0].nullify()
   * const p2 = p2d.hypercube(1)
   *
   * const cp = p[0].imul(p2[0], l)
   * cp.isNull() // true
   *
   * l.isReal = () => false
   * p[0].imul(p2[0], l) // Error
   */
  imul (another, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (!lalg.isReal()) {
      throw Error('`lalg` must be an implementation of real algebra.')
    }
    if (this.isNull()) {
      return this
    }
    if (!(another instanceof ConvexPolytope)) {
      throw Error('`another` must be an instance of `ConvexPolytope`')
    }
    if (another.isNull()) {
      this.nullify();
      return this
    }
    if (this.dim !== another.dim) {
      throw Error('`this` and `another` must be the same dimension.')
    }
    const ralg = lalg.salg;
    // fast check
    const newFacets = [];
    for (let i = another.facets.length - 1; i >= 0; i -= 1) {
      const fi = another.facets[i];
      for (let j = this.facets.length - 1; j >= 0; j -= 1) {
        const fj = this.facets[j];
        if (fi.nvec === fj.nvec) {
          const dd = ralg.sub(fi.d, fj.d);
          if (fi.faceOutside === fj.faceOutside) {
            if (ralg.isZero(dd) || ralg.isPositive(dd) === fi.faceOutside) {
              break
            }
          } else {
            if (ralg.isZero(dd) || ralg.isPositive(dd) !== fi.faceOutside) {
              this.nullify();
              return this
            }
          }
        }
        if (j === 0) {
          // new facet without vertices
          newFacets.push(new Facet(fi.nvec, ralg.copy(fi.d), fi.faceOutside));
        }
      }
    }
    for (let i = newFacets.length - 1; i >= 0; i -= 1) {
      this.iaddFacet(newFacets[i], lalg);
    }
    return this
  }

  /**
   * @desc
   * The ConvexPolytope#imulSub method
   * calculates the intersection of `this` and `another` *in-place*
   * and returns an {@link Array} containing
   * instances of {@link ConvexPolytope} which represent
   * the set difference of `this` and `another`.
   *
   * @param {ConvexPolytope} another
   * another instance of {@link ConvexPolytope}.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Array}
   * an {@link Array} containing
   * instances of {@link ConvexPolytope} which represent
   * the set difference of `this` and `another`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @throws {Error}
   * if `lalg` is not an implementation of real algebra.
   *
   * @throws {Error}
   * if `another` is not an instance of {@link ConvexPolytope}.
   *
   * @throws {Error}
   * if the dimension of `another` is different from that of `this`.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * let facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * let vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * let edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   *
   * facets = [
   *   new Facet(x, 2, true),
   *   new Facet(x, 0, false),
   *   new Facet(y, 2, true),
   *   new Facet(y, 0, false)]
   * vertices = [
   *   l.$(2, 2),
   *   l.$(0, 2),
   *   l.$(2, 0),
   *   l.$(0, 0)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * edges = ConvexPolytope.genEdges(2, facets)
   * const cp2 = new ConvexPolytope(facets, vertices, edges)
   *
   * let arr = cp.imulSub(cp2, l)
   * cp.facets.length // 4
   * cp.vertices.length // 4
   * cp.edges.length // 4
   * arr.length // 2
   *
   * cp.imulSub(cp2, null) // Error
   * cp.imulSub(null, l) // Error
   * cp2.vertices[0] = l.$(1, 1, 1)
   * cp.imulSub(cp2, l) // Error
   *
   * cp2.nullify()
   * arr = cp.imulSub(cp2, l)
   * cp.facets.length // 4
   * cp.vertices.length // 4
   * cp.edges.length // 4
   * arr.length // 0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * let p = p2d.hypercube(1)
   * let a = Math.sqrt(2) / 2
   * let p2 = p2d.translate(p2d.irotate(p2d.hypercube(1),
   *   l.$(a, a, a, -a).setDim(2)), [3, 3])
   *
   * let arr = p[0].imulSub(p2[0], l)
   * arr.length // 1
   *
   * p = p2d.hypercube(1)
   * a = Math.sqrt(2) / 2
   * p2 = p2d.iaddFacet(p2d.hypercube(1), p2d.facet([1, 1], 1))
   * p2 = p2d.itranslate(p2, [1, 1])
   *
   * arr = p[0].imulSub(p2[0], l)
   * arr.length // 2
   *
   * p = p2d.hypercube(1)
   * p[0].nullify()
   * p2 = p2d.hypercube(1)
   *
   * arr = p[0].imulSub(p2[0], l)
   * arr.length // 0
   *
   * l.isReal = () => false
   * p[0].imulSub(p2[0], l) // Error
   */
  imulSub (another, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (!lalg.isReal()) {
      throw Error('`lalg` must be an implementation of real algebra.')
    }
    if (this.isNull()) {
      return []
    }
    if (!(another instanceof ConvexPolytope)) {
      throw Error('`another` must be an instance of `ConvexPolytope`.')
    }
    if (another.isNull()) {
      return []
    }
    if (this.dim !== another.dim) {
      throw Error('`this` and `another` must be the same dimension.')
    }
    const ralg = lalg.salg;
    // fast check
    const newFacets = [];
    for (let i = another.facets.length - 1; i >= 0; i -= 1) {
      const fi = another.facets[i];
      for (let j = this.facets.length - 1; j >= 0; j -= 1) {
        const fj = this.facets[j];
        if (fi.nvec === fj.nvec) {
          const dd = ralg.sub(fi.d, fj.d);
          if (fi.faceOutside === fj.faceOutside) {
            if (ralg.isZero(dd) || ralg.isPositive(dd) === fi.faceOutside) {
              break
            }
          } else {
            if (ralg.isZero(dd) || ralg.isPositive(dd) !== fi.faceOutside) {
              const arr = [this.copy(lalg)];
              this.nullify();
              return arr
            }
          }
        }
        if (j === 0) {
          // new facet without vertices
          newFacets.push(new Facet(fi.nvec, ralg.copy(fi.d), fi.faceOutside));
        }
      }
    }
    const n = newFacets.length;
    const intersections = [this.copy(lalg)];
    for (let i = 0; i < n; i += 1) {
      this.iaddFacet(newFacets[i], lalg);
      if (this.isNull()) {
        break
      } else {
        intersections.push(this.copy(lalg));
      }
    }
    if (this.isNull()) {
      return [intersections[0]]
    } else {
      const arr = [];
      for (let i = 0; i < n; i += 1) {
        const fi = newFacets[i];
        const fic = new Facet(fi.nvec, ralg.copy(fi.d), !fi.faceOutside);
        const cp = intersections[i];
        cp.iaddFacet(fic, lalg);
        if (!cp.isNull()) {
          arr.push(cp);
        }
      }
      return arr
    }
  }

  /**
   * @desc
   * The ConvexPolytope#irotate method
   * rotates `this` by a rotation matrix `m` *in place*.
   * A rotation matrix is a orthogonal matrix,
   * i.e. its inverse is equal to its transpose.
   *
   * CAUTION: this method does not check if `m` is an orthogonal matrix.
   *
   * @param {Matrix} m
   * an instance of {@link Matrix} representing an orthogonal matrix.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {ConvexPolytope}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @throws {Error}
   * if `m` is not a square matrix of the same dimension as `this`.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.irotate(l.$(0, -1, 1, 0).setDim(2), l)
   *
   * cp === cp2 // true
   * l.eq(cp.facets[0].nvec, y) // true
   * l.eq(cp.facets[1].nvec, y) // true
   * l.eq(cp.facets[2].nvec, l.neg(x)) // true
   * l.eq(cp.facets[3].nvec, l.neg(x)) // true
   *
   * cp.facets[0].d // 1
   * cp.facets[1].d // -1
   * cp.facets[2].d // 1
   * cp.facets[3].d // -1
   *
   * l.eq(cp.vertices[0], [-1, 1]) // true
   * l.eq(cp.vertices[1], [-1, -1]) // true
   * l.eq(cp.vertices[2], [1, 1]) // true
   * l.eq(cp.vertices[3], [1, -1]) // true
   *
   * cp.irotate(null, l) // Error
   * cp.irotate(l.$(0, 1, -1, 0).setDim(2), null) // Error
   * cp.irotate(l.$(0, 1, -1, 0).setDim(1), l) // Error
   */
  irotate (m, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    m = lalg.cast(m);
    if (!m.isSquare() || m.getDim()[0] !== this.dim) {
      throw Error('`m` must be a square matrix of the same dimension as ' +
          '`this`.')
    }
    const vMap = new WeakMap();
    for (let i = this.vertices.length - 1; i >= 0; i -= 1) {
      const v = lalg.mmul(m, this.vertices[i]);
      vMap.set(this.vertices[i], v);
      this.vertices[i] = v;
    }
    for (let i = this.facets.length - 1; i >= 0; i -= 1) {
      this.facets[i].irotate(m, lalg);
      this.facets[i].replaceVertices(vMap);
    }
    for (let i = this.edges.length - 1; i >= 0; i -= 1) {
      this.edges[i].replaceVertices(vMap);
    }
    return this
  }

  /**
   * @desc
   * The ConvexPolytope#itranslate method
   * translates `this` by `v` *in place*.
   *
   * @param {Matrix} v
   * an instance of {@link Matrix} representing a vector.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {ConvexPolytope}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.itranslate([1, 1], l)
   *
   * cp === cp2 // true
   * cp.facets[0].nvec === x // true
   * cp.facets[1].nvec === x // true
   * cp.facets[2].nvec === y // true
   * cp.facets[3].nvec === y // true
   *
   * cp.facets[0].d // 2
   * cp.facets[1].d // 0
   * cp.facets[2].d // 2
   * cp.facets[3].d // 0
   *
   * l.eq(cp.vertices[0], [2, 2]) // true
   * l.eq(cp.vertices[1], [0, 2]) // true
   * l.eq(cp.vertices[2], [2, 0]) // true
   * l.eq(cp.vertices[3], [0, 0]) // true
   *
   * cp.itranslate(null, l) // Error
   * cp.itranslate([1, 1], null) // Error
   */
  itranslate (v, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    for (let i = this.facets.length - 1; i >= 0; i -= 1) {
      this.facets[i].itranslate(v, lalg);
    }
    for (let i = this.vertices.length - 1; i >= 0; i -= 1) {
      this.vertices[i] = lalg.iadd(this.vertices[i], v);
    }
    return this
  }

  /**
   * @desc
   * The ConvexPolytope#iscale method scales `this` by `s` *in place*
   * around the origin.
   *
   * @param {RealAlgebraicElement} s
   * a {@link RealAlgebraicElement} representing a scale factor.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {ConvexPolytope}
   * `this`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of {@link LinearAlgebra}.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.iscale(2, l)
   *
   * cp === cp2 // true
   * cp.facets[0].nvec === x // true
   * cp.facets[1].nvec === x // true
   * cp.facets[2].nvec === y // true
   * cp.facets[3].nvec === y // true
   *
   * cp.facets[0].d // 2
   * cp.facets[1].d // -2
   * cp.facets[2].d // 2
   * cp.facets[3].d // -2
   *
   * l.eq(cp.vertices[0], [2, 2]) // true
   * l.eq(cp.vertices[1], [-2, 2]) // true
   * l.eq(cp.vertices[2], [2, -2]) // true
   * l.eq(cp.vertices[3], [-2, -2]) // true
   *
   * cp.iscale(2, null) // Error
   */
  iscale (s, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    for (let i = this.facets.length - 1; i >= 0; i -= 1) {
      this.facets[i].iscale(s, lalg);
    }
    for (let i = this.vertices.length - 1; i >= 0; i -= 1) {
      this.vertices[i] = lalg.ismul(this.vertices[i], s);
    }
    return this
  }

  /**
   * @desc
   * The ConvexPolytope.genEdges function
   * generates edges from the given facets.
   * The same vertex must be the same object.
   *
   * @param {number} dim
   * the dimension of the edges to be generated.
   *
   * @param {Array} facets
   * an {@link Array} containing {@link Facet}-like objects.
   * A {@link Facet}-like object is an object which has `vertices` property.
   * The `vertices` must be an array containing instances of {@link Matrix}
   * representing vectors.
   *
   * @return {Array}
   * an {@link Array} containing the generated edges.
   *
   * @throws {Error}
   * if `dim` is not a positive (non-zero) integer.
   *
   * @throws {Error}
   * if `facets` is not an {@link Array}.
   *
   * @throws {Error}
   * if `vertices` is not an {@link Array}.
   *
   * @throws {Error}
   * if `vertices` property of a facet is not an {@link Array}
   * or any element of `vertices` is not an an adaptive {@link Matrix}
   * representing a vector of which dimension is higher or equal to `dim`.
   *
   * @version 1.2.6
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * let facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * edges instanceof Array // true
   * edges.length // 4
   * const vCount = [0, 0, 0, 0]
   * for (let i = edges.length - 1; i >= 0; i -= 1) {
   *   for (let j = vertices.length - 1; j >= 0; j -= 1) {
   *     if (edges[i].v0 === vertices[j] || edges[i].v1 === vertices[j]) {
   *       vCount[j] += 1
   *     }
   *   }
   * }
   * vCount[0] // 2
   * vCount[1] // 2
   * vCount[2] // 2
   * vCount[3] // 2
   *
   * // invalid parameters
   * ConvexPolytope.genEdges(3, facets) // Error
   * ConvexPolytope.genEdges(null, facets) // Error
   * ConvexPolytope.genEdges(2.1, facets) // Error
   * ConvexPolytope.genEdges(2, null) // Error
   * facets.push(null)
   * ConvexPolytope.genEdges(2, facets) // Error
   * facets.pop()
   *
   * ConvexPolytope.genEdges(1, []) // Error
   * facets = [{ vertices: [] }, { vertices: [] }]
   * ConvexPolytope.genEdges(1, facets) // Error
   */
  static genEdges (dim, facets) {
    if (typeof dim !== 'number' || !Number.isInteger(dim) || dim <= 0) {
      throw Error('`dim` must be a positive (non-zero) integer.')
    }
    if (!Array.isArray(facets)) {
      throw Error('`facets` must be an array.')
    }
    if (facets.some(facet =>
      !facet.vertices ||
      !Array.isArray(facet.vertices) ||
      facet.vertices.some(v =>
        !(v instanceof Matrix) || !v.isAdaptive() || v.length < dim
      )
    )) {
      throw Error('vertices property of a facet is not an array ' +
        'containing adaptive matrices representing vectors of which ' +
        'dimension is higher or equal to `dim`.')
    }
    const edges = [];
    if (dim === 1) {
      if (facets.length !== 2) {
        throw Error('`facets.length` must be 2 when dim === 1.')
      }
      if (facets.some(facet => facet.vertices.length !== 1)) {
        throw Error('`facet.vertices.length` must be 1 when dim === 1.')
      }
      edges.push(new Edge(facets[0].vertices[0], facets[1].vertices[0]));
    } else {
      for (let i = facets.length - 1; i >= 0; i -= 1) {
        const fi = facets[i];
        const vfi = fi.vertices;
        const ridges = [];
        for (let j = facets.length - 1; j >= 0; j -= 1) {
          const fj = facets[j];
          if (fj === fi) {
            continue
          }
          const vfj = vfi.filter(v => fj.vertices.indexOf(v) !== -1);
          if (
            vfj.length > dim - 2 &&
            vfi.length !== vfj.length &&
            ridges.every(r =>
              r.vertices.length !== vfj.length ||
              r.vertices.some((vrk, k) => vrk !== vfj[k])
            )
          ) {
            ridges.push({ vertices: vfj });
          }
        }
        if (ridges.length > 0) {
          const efi = ConvexPolytope.genEdges(dim - 1, ridges);
          const newEdges = [];
          for (let j = efi.length - 1; j >= 0; j -= 1) {
            const efij = efi[j];
            if (edges.every((e) => {
              return !efij.isIdentical(e)
            })) {
              newEdges.push(efij);
            }
          }
          edges.push(...newEdges);
        }
      }
    }
    return edges
  }

  /**
   * @desc
   * The ConvexPolytope.genSimplexes function
   * generates simplexes from the given facets.
   * The same vertex must be the same object.
   * Each simplex is an {@link Array} containing the vertices of the simplex.
   *
   * @param {number} dim
   * the dimension of the edges to be generated.
   *
   * @param {Array} facets
   * An {@link Array} containing {@link Facet}-like objects.
   * A {@link Facet}-like object is an object which has `vertices` property.
   * The `vertices` must be an array containing instances of {@link Matrix}
   * representing vectors.
   *
   * @param {Array} vertices
   * an {@link Array} containing instances of {@link Matrix}
   * representing vectors.
   *
   * @return {Array}
   * an {@link Array} containing the generated simplexes.
   *
   * @throws {Error}
   * if `dim` is not a positive (non-zero) integer.
   *
   * @throws {Error}
   * if `facets` is not an {@link Array}.
   *
   * @throws {Error}
   * if `vertices` is not an {@link Array}.
   *
   * @throws {Error}
   * if `vertices` property of a facet is not an {@link Array}
   * or any element of `vertices` is not an an adaptive {@link Matrix}
   * representing a vector of which dimension is higher or equal to `dim`.
   *
   * @version 1.2.6
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * let facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * let simplexes = ConvexPolytope.genSimplexes(2, facets)
   * simplexes instanceof Array // true
   * simplexes.length // 2
   * simplexes[0].length // 3
   * simplexes[1].length // 3
   * const vCount = [0, 0, 0, 0]
   * for (let i = simplexes.length - 1; i >= 0; i -= 1) {
   *   for (let j = vertices.length - 1; j >= 0; j -= 1) {
   *     if (simplexes[i][0] === vertices[j] ||
   *       simplexes[i][1] === vertices[j] ||
   *       simplexes[i][2] === vertices[j]
   *     ) {
   *       vCount[j] += 1
   *     }
   *   }
   * }
   * vCount.sort()
   * vCount[0] // 1
   * vCount[1] // 1
   * vCount[2] // 2
   * vCount[3] // 2
   *
   * // invalid parameters
   * ConvexPolytope.genSimplexes(3, facets) // Error
   * ConvexPolytope.genSimplexes(null, facets) // Error
   * ConvexPolytope.genSimplexes(2.1, facets) // Error
   * ConvexPolytope.genSimplexes(2, null) // Error
   * facets.push(null)
   * ConvexPolytope.genSimplexes(2, facets) // Error
   * facets.pop()
   *
   * ConvexPolytope.genSimplexes(1, []) // Error
   * facets = [{ vertices: [] }, { vertices: [] }]
   * ConvexPolytope.genSimplexes(1, facets) // Error
   *
   * // 0-dim
   * simplexes = ConvexPolytope.genSimplexes(0, [])
   * simplexes.length // 1
   * simplexes[0].length // 1
   * ConvexPolytope.genSimplexes(0, [{ vertices: [] }]) // Error
   */
  static genSimplexes (dim, facets) {
    if (!Number.isInteger(dim) || dim < 0) {
      throw Error('`dim` must be a positive integer or zero.')
    }
    if (!(facets instanceof Array)) {
      throw Error('`facets` must be an array.')
    }
    if (facets.some(facet =>
      !facet.vertices ||
      !Array.isArray(facet.vertices) ||
      facet.vertices.some(v =>
        !(v instanceof Matrix) || !v.isAdaptive() || v.length < dim
      )
    )) {
      throw Error('vertices property of a facet is not an array ' +
        'containing adaptive matrices representing vectors of which ' +
        'dimension is higher or equal to `dim`.')
    }
    const simplexes = [];
    if (dim === 0) {
      if (facets.length !== 0) {
        throw Error('`facets.length` must be 0 when dim === 0.')
      }
      simplexes.push([[]]);
    } else if (dim === 1) {
      if (facets.length !== 2) {
        throw Error('`facets.length` must be 2 when dim === 1.')
      }
      if (facets.some(facet => facet.vertices.length !== 1)) {
        throw Error('`facet.vertices.length` must be 1 when dim === 1.')
      }
      simplexes.push([facets[0].vertices[0], facets[1].vertices[0]]);
    } else {
      const v0 = facets[0].vertices[0];
      for (let i = facets.length - 1; i >= 0; i -= 1) {
        const fi = facets[i];
        const vfi = fi.vertices;
        if (vfi.every((v) => {
          return v !== v0
        })) {
          const ridges = [];
          for (let j = facets.length - 1; j >= 0; j -= 1) {
            const fj = facets[j];
            if (fi === fj) {
              continue
            }
            const vfj = vfi.filter(v => fj.vertices.indexOf(v) !== -1);
            if (
              vfj.length > dim - 2 &&
              vfi.length !== vfj.length &&
              ridges.every(r =>
                r.vertices.length !== vfj.length ||
                r.vertices.some((vrk, k) => vrk !== vfj[k])
              )
            ) {
              ridges.push({ vertices: vfj });
            }
          }
          if (ridges.length > 0) {
            const sfi = ConvexPolytope.genSimplexes(dim - 1, ridges);
            for (let j = sfi.length - 1; j >= 0; j -= 1) {
              sfi[j].push(v0);
            }
            simplexes.push(...sfi);
          }
        }
      }
    }
    return simplexes
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/polytope-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The Polytope class is a class for polytopes.
 * Polytopes are represented as an array of convex polytopes.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class Polytope extends Array {
  /**
   * @desc
   * The constructor function of the {@link Polytope} class.
   * Null convex polytopes are ignored.
   *
   * CAUTION: this constructor function does not check if
   * `args` are valid instances of {@link ConvexPolytope}.
   * It checks only the dimension of the convex polytopes.
   *
   * @param {...ConvexPolytope} args
   * instances of {@link ConvexPolytope}.
   *
   * @throws {Error}
   * if some arguments are not instances of {@link ConvexPolytope}.
   *
   * @throws {Error}
   * if some convex polytopes have different dimensions.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.copy(l)
   *
   * let p = new Polytope(cp)
   * p instanceof Polytope // true
   * p.length // 1
   * p[0] === cp // true
   *
   * p = new Polytope(cp, cp2)
   * p.length // 2
   * p[0] === cp // true
   * p[1] === cp2 // true
   *
   * p = new Polytope()
   * p.length // 0
   *
   * // invalid argument
   * new Polytope(null) // Error
   *
   * // inconsistent dimension
   * cp2.vertices[0] = l.$(1)
   * new Polytope(cp, cp2) // Error
   *
   * // the dimension of null convex polytope is undefined,
   * // and the dimension check fails
   * cp2.nullify()
   * p = new Polytope(cp2)
   * p.length // 0
   */
  constructor (...args) {
    if (args.some((arg) => {
      return !(arg instanceof ConvexPolytope)
    })) {
      throw Error('an argument is not an instance of `ConvexPolytope`.')
    }
    const nonNullPolytopes = [];
    for (let i = 0, n = args.length; i < n; i += 1) {
      const arg = args[i];
      if (!arg.isNull()) {
        nonNullPolytopes.push(arg);
      }
    }
    if (nonNullPolytopes.length > 0) {
      const dim = nonNullPolytopes[0].dim;
      if (nonNullPolytopes.slice(1).some((cp) => {
        return cp.dim !== dim
      })) {
        throw Error('the dimension of the convex polytopes must be the same')
      }
    }
    super(...nonNullPolytopes);
  }

  /**
   * @desc
   * Thanks to this species, built-in {@link Array} methods,
   * such as the {@link Polytope}#slice method,
   * return an {@link Array} object.
   *
   * @type {function}
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * let facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * let vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * let edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   *
   * facets = [
   *   new Facet(x, 3, true),
   *   new Facet(x, 1, false),
   *   new Facet(y, 3, true),
   *   new Facet(y, 1, false)]
   * vertices = [
   *   l.$(3, 3),
   *   l.$(1, 3),
   *   l.$(3, 1),
   *   l.$(1, 1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * edges = ConvexPolytope.genEdges(2, facets)
   * const cp2 = new ConvexPolytope(facets, vertices, edges)
   *
   * const p = new Polytope(cp, cp2)
   * const arr = p.slice()
   * arr instanceof Array // true
   * p.constructor === Polytope // true
   * arr.constructor === Polytope // false
   * arr.constructor === Array // true
   */
  static get [Symbol.species] () {
    return Array
  }

  /**
   * @desc
   * The Polytope#dim method returns the dimension of `this`.
   * The dimension of polytopes is equal to that of the first convex polytope.
   *
   * @type {number}
   *
   * @throws {Error}
   * if `this` has no convex polytope.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   *
   * const p = new Polytope(cp)
   * p.dim // 2
   *
   * new Polytope().dim // Error
   */
  get dim () {
    if (this.isNull()) {
      throw Error('the dimension of null polytopes cannot be ditermined.')
    }
    return this[0].dim
  }

  /**
   * @desc
   * The Polytope#copy method returns a new instance of {@link Polytope}
   * which has copies of instances of {@link ConvexPolytope}
   * as generated by {@link ConvexPolytope#copy}.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.copy(l)
   *
   * let p = new Polytope(cp)
   * let p2 = p.copy(l)
   * p2 instanceof Polytope // true
   * p2 !== p // true
   * p2.length // 1
   * p2[0] === cp // false
   *
   * p = new Polytope(cp, cp2)
   * p2 = p.copy(l)
   * p2 instanceof Polytope // true
   * p2 !== p // true
   * p2.length // 2
   * p2[0] !== cp // true
   * p2[1] !== cp2 // true
   *
   * p = new Polytope()
   * p2 = p.copy(l)
   * p2 instanceof Polytope // true
   * p2 !== p // true
   * p2.length // 0
   */
  copy (lalg) {
    const arr = [];
    for (let i = 0, n = this.length; i < n; i += 1) {
      arr.push(this[i].copy(lalg));
    }
    return new Polytope(...arr)
  }

  /**
   * @desc
   * The Polytope#isNull method checks if `this` is null.
   * `this` is considered to be null if it has no {@link ConvexPolytope}
   * which is not null.
   *
   * @return {boolean}
   * `true` if `this` is null and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   *
   * let p = new Polytope()
   * p.isNull() // true
   *
   * p = new Polytope(cp)
   * p.isNull() // false
   */
  isNull () {
    return this.length === 0 || this.every((cp) => {
      return cp.isNull()
    })
  }

  /**
   * @desc
   * The Polytope#nullify method nullifies `this`.
   *
   * @return {Polytope}
   * `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   *
   * const p = new Polytope(cp)
   * p.isNull() // false
   * p.nullify()
   * p.isNull() // true
   * p.length === 0 // true
   */
  nullify () {
    this.length = 0;
    return this
  }

  /**
   * @desc
   * The Polytope#reduce method reduces the number of convex polytopes in
   * `this` by concatenating facing convex polytopes if possible.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Polytope}
   * `this`.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * let facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * let vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * let edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   *
   * facets = [
   *   new Facet(x, 3, true),
   *   new Facet(x, 1, false),
   *   new Facet(y, 3, true),
   *   new Facet(y, 1, false)]
   * vertices = [
   *   l.$(3, 3),
   *   l.$(1, 3),
   *   l.$(3, 1),
   *   l.$(1, 1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * edges = ConvexPolytope.genEdges(2, facets)
   * const cp2 = new ConvexPolytope(facets, vertices, edges)
   *
   * let p = new Polytope(cp, cp2)
   * p.length // 2
   *
   * p.reduce(l)
   * p.length // 2
   *
   * facets = [
   *   new Facet(x, 3, true),
   *   new Facet(x, 1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * vertices = [
   *   l.$(3, 1),
   *   l.$(1, 1),
   *   l.$(3, -1),
   *   l.$(1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * edges = ConvexPolytope.genEdges(2, facets)
   * const cp3 = new ConvexPolytope(facets, vertices, edges)
   *
   * p = new Polytope(cp, cp3)
   * p.length // 2
   *
   * p.reduce(l)
   * p.length // 1
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * let p2 = p2d.hypercube(1)
   * p2 = p2d.iaddFacet(p2, p2d.facet([-1, -1], 0, false))
   * p2 = p2d.itranslate(p2, [2, 0])
   *
   * p.push(p2[0])
   * p.reduce(l)
   * p.length // 1
   *
   * const p3 = p2d.translate(p2d.hypercube(1), [0, 2])
   * p.push(p3[0])
   * p.reduce(l)
   * p.length // 2
   *
   * let p4 = p2d.hypercube(1)
   * p4 = p2d.iaddFacet(p4, p2d.facet([1, 1], 0, false))
   * p4 = p2d.itranslate(p4, [2, 0])
   * p.push(p4[0])
   * p.reduce(l)
   * p.length // 2
   *
   * p.push(p4[0])
   * p[1].nullify()
   * p.reduce(l)
   * p.length // 2
   *
   * p.nullify()
   * p.reduce(l)
   * p.length // 0
   *
   * l.isReal = () => false
   * p.reduce(l) // Error
   *
   * p.reduce(null) // Error
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p3d = new PolytopeAlgebra(3, l)
   *
   * const p = p3d.hypercube(1)
   * let p2 = p3d.hypercube(1)
   * p2 = p3d.iaddFacet(p2, p3d.facet([-1, -1, -1], 1, true))
   * p2 = p3d.itranslate(p2, [0, 0, 2])
   * p.push(p2[0])
   * p.reduce(l)
   * p.length // 2
   *
   * p[1].nullify()
   * p.reduce(l)
   * p.length // 1
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   *
   * // test for issue #2
   *
   * const r = new RealAlgebra(1e-10)
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * let p1 = p2d.hypercube(1)
   * const n1 = [-1, 1]
   * const f1 = p2d.facet(n1, l.dot(n1, [-1, 0]), true)
   * p1 = p2d.itranslate(p2d.iaddFacet(p1, f1), [2, 0])
   * let p2 = p2d.hypercube(1)
   * const n2 = [-0.1, 0.01]
   * const f2 = p2d.facet(n2, l.dot(n2, [1, 0]), true)
   * p2 = p2d.iaddFacet(p2, f2)
   * p1.length // 1
   * p2.length // 1
   *
   * const p3 = p2d.add(p1, p2)
   * // shoud be 1
   * p3.length // 1
   */
  reduce (lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (!lalg.isReal()) {
      throw Error('`lalg` must be an implementation of real algebra.')
    }
    if (this.isNull()) {
      return this
    }
    const ralg = lalg.salg;
    const dim = this.dim;
    for (let i = this.length - 2; i >= 0; i -= 1) {
      const cpi = this[i];
      if (cpi.isNull()) {
        this.splice(i, 1);
        continue
      }
      const facetsi = cpi.facets;
      const verticesi = cpi.vertices;
      for (let j = this.length - 1; j > i; j -= 1) {
        const cpj = this[j];
        if (cpj.isNull()) {
          this.splice(j, 1);
          continue
        }
        const facetsj = cpj.facets;
        const verticesj = cpj.vertices;
        // find a pair of facing facets
        let fi = null;
        let fj = null;
        for (let k = facetsi.length - 1; k >= 0; k -= 1) {
          const fk = facetsi[k];
          for (let l = facetsj.length - 1; l >= 0; l -= 1) {
            const fl = facetsj[l];
            if (fk.nvec === fl.nvec && fk.faceOutside !== fl.faceOutside) {
              if (ralg.eq(fk.d, fl.d)) {
                fi = fk;
                fj = fl;
              }
              break
            }
          }
          if (fi !== null) {
            break
          }
        }
        if (fi === null) {
          continue
        }
        // check if the two facets are exactly the same
        const verticesfi = fi.vertices;
        const verticesfj = fj.vertices;
        if (verticesfi.length !== verticesfj.length) {
          continue
        }
        const vPairs = [];
        for (let k = verticesfi.length - 1; k >= 0; k -= 1) {
          const vk = verticesfi[k];
          for (let l = verticesfj.length - 1; l >= 0; l -= 1) {
            const vl = verticesfj[l];
            if (lalg.eq(vk, vl)) {
              vPairs.push([vk, vl]);
              break
            }
            if (l === 0) {
              vPairs.length = 0;
            }
          }
          if (vPairs.length === 0) {
            break
          }
        }
        if (vPairs.length === 0) {
          continue
        }
        // check if the concatenated polytope is convex
        const ridgesi = [];
        for (let k = facetsi.length - 1; k >= 0; k -= 1) {
          const fk = facetsi[k];
          if (fk === fi) {
            continue
          }
          const verticesk = fk.vertices;
          const onRidgeVertices = [];
          for (let l = verticesfi.length - 1; l >= 0; l -= 1) {
            const vl = verticesfi[l];
            for (let m = verticesk.length - 1; m >= 0; m -= 1) {
              const vm = verticesk[m];
              if (vl === vm) {
                onRidgeVertices.push(vl);
                break
              }
            }
          }
          if (onRidgeVertices.length >= dim - 1) {
            ridgesi.push({ facet: fk, vertices: onRidgeVertices });
          }
        }
        const ridgesj = [];
        for (let k = facetsj.length - 1; k >= 0; k -= 1) {
          const fk = facetsj[k];
          if (fk === fj) {
            continue
          }
          const verticesk = fk.vertices;
          const onRidgeVertices = [];
          for (let l = verticesfj.length - 1; l >= 0; l -= 1) {
            const vl = verticesfj[l];
            for (let m = verticesk.length - 1; m >= 0; m -= 1) {
              const vm = verticesk[m];
              if (vl === vm) {
                onRidgeVertices.push(vl);
                break
              }
            }
          }
          if (onRidgeVertices.length >= dim - 1) {
            ridgesj.push({ facet: fk, vertices: onRidgeVertices });
          }
        }
        const ridgeConditions = [];
        let isConvex = true;
        for (let l = 0, n = ridgesj.length; l < n; l += 1) {
          const ridgel = ridgesj[l];
          const verticesl = ridgel.vertices;
          for (let k = ridgesi.length - 1; k >= 0; k -= 1) {
            const ridgek = ridgesi[k];
            const verticesk = ridgek.vertices;
            // find the same ridge
            if (verticesl.every((v) => {
              let vPair;
              for (let m = vPairs.length - 1; m >= 0; m -= 1) {
                if (v === vPairs[m][1]) {
                  vPair = vPairs[m][0];
                  break
                }
              }
              for (let m = verticesk.length - 1; m >= 0; m -= 1) {
                if (verticesk[m] === vPair) {
                  return true
                }
              }
              return false
            })) {
              let isParallel;
              if (ridgek.facet.nvec === ridgel.facet.nvec) {
                isParallel = true;
              } else {
                isParallel = false;
                let nvec0 = fi.nvec;
                if (!fi.faceOutside) {
                  nvec0 = lalg.neg(nvec0);
                }
                let nvec1 = ridgek.facet.nvec;
                if (!ridgek.facet.faceOutside) {
                  nvec1 = lalg.neg(nvec1);
                }
                let nvec2 = ridgel.facet.nvec;
                if (!ridgel.facet.faceOutside) {
                  nvec2 = lalg.neg(nvec2);
                }
                const dot01 = lalg.dot(nvec0, nvec1);
                const dot02 = lalg.dot(nvec0, nvec2);
                const dot01IsPositive = ralg.isPositive(dot01);
                const dot02IsPositive = ralg.isPositive(dot02);
                if (dot01IsPositive !== dot02IsPositive) {
                  isConvex = dot02IsPositive;
                } else {
                  const dot11 = lalg.abs2(nvec1);
                  const dot22 = lalg.abs2(nvec2);
                  const tmp = ralg.isub(
                    ralg.idiv(ralg.mul(dot02, dot02), dot22),
                    ralg.idiv(ralg.mul(dot01, dot01), dot11));
                  isConvex = dot01IsPositive === ralg.isPositive(tmp);
                }
              }
              ridgeConditions.push({ ridgesiIndex: k, isParallel: isParallel });
              break
            }
          }
          if (!isConvex) {
            break
          }
        }
        if (!isConvex) {
          continue
        }
        // remove facing facets
        facetsi.splice(facetsi.indexOf(fi), 1);
        facetsj.splice(facetsj.indexOf(fj), 1);
        // add new vertices
        for (let k = verticesj.length - 1; k >= 0; k -= 1) {
          const vk = verticesj[k];
          if (vPairs.every((vPair) => {
            return vk !== vPair[1]
          })) {
            verticesi.push(vk);
          }
        }
        // add new facets
        for (let k = facetsj.length - 1; k >= 0; k -= 1) {
          const fk = facetsj[k];
          const verticesk = fk.vertices;
          for (let l = ridgesj.length - 1; l >= 0; l -= 1) {
            const ridgel = ridgesj[l];
            if (fk === ridgel.facet && ridgeConditions[l].isParallel) {
              const ridgei = ridgesi[ridgeConditions[l].ridgesiIndex];
              for (let m = verticesk.length - 1; m >= 0; m -= 1) {
                const vm = verticesk[m];
                if (vPairs.every((vPair) => {
                  return vm !== vPair[1]
                })) {
                  ridgei.facet.vertices.push(vm);
                }
              }
              break
            }
            if (l === 0) {
              for (let m = vPairs.length - 1; m >= 0; m -= 1) {
                for (let n = verticesk.length - 1; n >= 0; n -= 1) {
                  if (verticesk[n] === vPairs[m][1]) {
                    verticesk.splice(n, 1, vPairs[m][0]);
                    break
                  }
                }
              }
              facetsi.push(fk);
            }
          }
        }
        // remove vertices which are not needed
        for (let k = vPairs.length - 1; k >= 0; k -= 1) {
          const vk = vPairs[k][0];
          let fCount = 0;
          for (let l = facetsi.length - 1; l >= 0; l -= 1) {
            if (facetsi[l].vertices.includes(vk)) {
              fCount += 1;
            }
            if (fCount === dim) {
              break
            }
            if (l === 0) {
              for (let m = verticesi.length - 1; m >= 0; m -= 1) {
                if (verticesi[m] === vk) {
                  verticesi.splice(m, 1);
                  break
                }
              }
              for (let m = facetsi.length - 1; m >= 0; m -= 1) {
                const verticesm = facetsi[m].vertices;
                for (let n = verticesm.length - 1; n >= 0; n -= 1) {
                  if (verticesm[n] === vk) {
                    verticesm.splice(n, 1);
                    break
                  }
                }
              }
            }
          }
        }
        cpi.edges = ConvexPolytope.genEdges(dim, cpi.facets);
        this.splice(j, 1);
        j = this.length;
      }
    }
    return this
  }

  /**
   * @desc
   * The Polytope#pairAnnihilation method reduces
   * the number of convex polytopes in `this`
   * by removing pairs of convex polytopes which have different
   * weights if possible.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {Polytope}
   * `this`.
   *
   * @version 1.1.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra(1e-5)
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * let p = p2d.hypercube(1)
   * const a = Math.sqrt(2) / 2
   * const p2 = p2d.translate(p2d.rotate(p, l.$(a, a, a, -a).setDim(2)), [3, 3])
   * p = p2d.add(p, p2)
   * p[1].weight = false
   * p.pairAnnihilation(l)
   * p.length // 2
   *
   * p[1].nullify()
   * p.pairAnnihilation(l)
   * p.length // 1
   *
   * p = p2d.hypercube(1)
   * p = p2d.add(p, p2)
   * p[0].nullify()
   * p.pairAnnihilation(l)
   * p.length // 1
   *
   * p.pairAnnihilation(null) // Error
   */
  pairAnnihilation (lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (this.isNull()) {
      return this
    }
    const salg = lalg.salg;
    for (let i = this.length - 2; i >= 0; i -= 1) {
      const cpi = this[i];
      if (cpi.isNull()) {
        this.splice(i, 1);
        continue
      }
      const facetsi = cpi.facets;
      for (let j = this.length - 1; j > i; j -= 1) {
        const cpj = this[j];
        if (cpj.isNull()) {
          this.splice(j, 1);
          continue
        }
        const facetsj = cpj.facets;
        if (cpi.weight !== cpj.weight && facetsi.length === facetsj.length) {
          if (facetsi.every((fi) => {
            for (let k = facetsj.length - 1; k >= 0; k -= 1) {
              const fj = facetsj[k];
              if (fi.nvec === fj.nvec && fi.faceOutside === fj.faceOutside) {
                if (salg.eq(fi.d, fj.d)) {
                  return true
                } else {
                  return false
                }
              }
            }
            return false
          })) {
            this.splice(j, 1);
            this.splice(i, 1);
            break
          }
        }
      }
    }
    return this
  }

  /**
   * @desc
   * The Polytope#genSimplexes method
   * generates simplexes from `this`.
   * Each simplex is an {@link Array} containing the vertices of the simplex
   * with weight property.
   *
   * @return {Array}
   * an {@link Array} containing the generated simplexes.
   *
   * @throws {Error}
   * if `this.dim` is `0`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.copy(l)
   * // ANTI-PATTERN!
   * // this is just for a test
   * let p = new Polytope(cp, cp2)
   * let simplexes = p.genSimplexes()
   * simplexes instanceof Array // true
   * simplexes.length // 4
   * simplexes[0].weight // true
   *
   * p = new Polytope()
   * simplexes = p.genSimplexes()
   * simplexes instanceof Array // true
   * simplexes.length // 0
   */
  genSimplexes () {
    if (this.isNull()) {
      return []
    }
    const dim = this.dim;
    const simplexes = [];
    for (let i = this.length - 1; i >= 0; i -= 1) {
      const cp = this[i];
      const arr = ConvexPolytope.genSimplexes(dim, cp.facets);
      for (const simplex of arr) {
        simplex.weight = cp.weight;
        simplexes.push(simplex);
      }
    }
    return simplexes
  }

  /**
   * @desc
   * The Polytope#toJSON method converts
   * `this` to an object serialisable by `JSON.stringify`.
   *
   * @return {object}
   * a serialisable object for `this`.
   *
   * @version 1.1.4
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * const cp2 = cp.copy(l)
   *
   * const p = new Polytope(cp, cp2)
   *
   * // toJSON method is called by JSON.stringify
   * const s = JSON.stringify(p)
   * typeof s // 'string'
   *
   * p.push(new ConvexPolytope())
   * const s2 = JSON.stringify(p)
   * typeof s2 // 'string'
   * s === s2 // true
   */
  toJSON () {
    const obj = {};
    obj.reviver = 'Polytope';
    obj.version = '1.1.4';
    obj.nvecs = [];
    obj.convexPolytopes = [];
    for (let i = this.length - 1; i >= 0; i -= 1) {
      const cp = this[i];
      if (cp.isNull()) {
        this.splice(i, 1);
        continue
      }
      const facets = cp.facets;
      for (let j = facets.length - 1; j >= 0; j -= 1) {
        const nv = facets[j].nvec;
        if (!obj.nvecs.includes(nv)) {
          obj.nvecs.push(nv);
        }
      }
    }
    for (let i = this.length - 1; i >= 0; i -= 1) {
      const cp = this[i];
      const facets = [];
      const edges = [];
      for (let j = cp.facets.length - 1; j >= 0; j -= 1) {
        const fj = cp.facets[j];
        const fvID = [];
        for (let k = fj.vertices.length - 1; k >= 0; k -= 1) {
          fvID.push(cp.vertices.indexOf(fj.vertices[k]));
        }
        facets.push([obj.nvecs.indexOf(fj.nvec), fj.d, fj.faceOutside, fvID]);
      }
      for (let j = cp.edges.length - 1; j >= 0; j -= 1) {
        const ej = cp.edges[j];
        edges.push([cp.vertices.indexOf(ej.v0), cp.vertices.indexOf(ej.v1)]);
      }
      obj.convexPolytopes.push({
        facets: facets,
        vertices: cp.vertices,
        edges: edges,
        weight: cp.weight
      });
    }
    return obj
  }

  /**
   * @desc
   * The Polytope.volume function
   * calculates the sum of the volumes of simplexes.
   * A simplex is an array of vertices.
   * To generate the simplexes for an instance of {@link Polytope},
   * use Polytope#genSimplexes method.
   *
   * @param {Array} simplexes
   * an {@link Array} containing simplexes.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @return {RealAlgebraicElement}
   * the volume of the given simplexes.
   *
   * @throws {Error}
   * if `lalg` is not an instance of `LinearAlgebra`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of real algebra.
   *
   * @throws {Error}
   * if `simplexes` is not an {@link Array}.
   *
   * @throws {Error}
   * if a simplex does not have the same dimension.
   *
   * @throws {Error}
   * if a vertex is not an adaptive matrix representing a vector of the same
   * dimension.
   *
   * @version 1.1.4
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, ConvexPolytope, Polytope } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   *
   * const x = l.$(1, 0)
   * const y = l.$(0, 1)
   * const facets = [
   *   new Facet(x, 1, true),
   *   new Facet(x, -1, false),
   *   new Facet(y, 1, true),
   *   new Facet(y, -1, false)]
   * const vertices = [
   *   l.$(1, 1),
   *   l.$(-1, 1),
   *   l.$(1, -1),
   *   l.$(-1, -1)]
   * facets[0].vertices = [vertices[0], vertices[2]]
   * facets[1].vertices = [vertices[1], vertices[3]]
   * facets[2].vertices = [vertices[0], vertices[1]]
   * facets[3].vertices = [vertices[2], vertices[3]]
   * const edges = ConvexPolytope.genEdges(2, facets)
   * const cp = new ConvexPolytope(facets, vertices, edges)
   * let p = new Polytope(cp)
   * let simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 4
   *
   * let cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, 1, true), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 4
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, 1, false), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 0
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, -1, true), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 0
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(x, -1, false), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 4
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), 2, true), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 4
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), 1, true), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 3.5
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), 0, true), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 2
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), -1, true), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 0.5
   *
   * cp2 = cp.copy(l)
   * cp2.iaddFacet(new Facet(l.$(1, 1), -2, true), l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 0
   *
   * cp2 = cp.copy(l)
   * // ANTI-PATTERN!
   * // this is just for a test
   * p = new Polytope(cp, cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, l) // 8
   *
   * // 0-dim
   * simplexes = [[l.$()]]
   * simplexes[0].weight = true
   * Polytope.volume(simplexes, l) // 1
   *
   * cp2 = cp.copy(l)
   * p = new Polytope(cp2)
   * simplexes = p.genSimplexes()
   * Polytope.volume(simplexes, null) // Error
   * Polytope.volume(null, l) // Error
   * simplexes.push(null)
   * Polytope.volume(simplexes, l) // Error
   * simplexes.pop()
   * simplexes[0].push(l.$(1, 1))
   * Polytope.volume(simplexes, l) // Error
   * simplexes[0].pop()
   * simplexes[0].pop()
   * simplexes[0].push(l.$(1, 1, 1))
   * Polytope.volume(simplexes, l) // Error
   *
   * l.isReal = () => false
   * Polytope.volume(simplexes, l) // Error
   */
  static volume (simplexes, lalg) {
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (!lalg.isReal()) {
      throw Error('`lalg` must be an implementation of real algebra.')
    }
    if (!(simplexes instanceof Array)) {
      throw Error('`simplexes` must be an array.')
    }
    const ralg = lalg.salg;
    if (simplexes.length === 0) {
      return ralg.num(0)
    } else {
      const dim = simplexes[0].length - 1;
      if (simplexes.slice(1).some((simplex) => {
        return !(simplex instanceof Array) || simplex.length !== dim + 1
      })) {
        throw Error('all simplexes must be the same dimension.')
      }
      if (simplexes.some((simplex) => {
        return simplex.some((v) => {
          return !(v instanceof Matrix) ||
            !(v.isAdaptive() || v.length === 0) || v.length !== dim
        })
      })) {
        throw Error('all vertices must be the same dimension.')
      }
      return simplexes.reduce((vol, simplex) => {
        const arr = [];
        const v0 = simplex[dim];
        for (let i = dim - 1; i >= 0; i -= 1) {
          arr.push(...lalg.sub(simplex[i], v0));
        }
        let volSimplex = lalg.det(lalg.ilup(lalg.cast(arr).setDim(dim, dim)));
        volSimplex = ralg.iabs(volSimplex);
        if (!simplex.weight) {
          volSimplex = ralg.ineg(volSimplex);
        }
        for (let i = dim; i >= 2; i -= 1) {
          volSimplex = ralg.idiv(volSimplex, i);
        }
        return ralg.iadd(vol, volSimplex)
      }, ralg.num(0))
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/polytope-algebra
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The PolytopeAlgebra class is a class for set algebra of polytopes.
 *
 * @version 1.1.1
 * @since 1.0.0
 *
 * @example
 * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
 * // import { RealAlgebra } from '@kkitahara/real-algebra'
 * import { LinearAlgebra } from '@kkitahara/linear-algebra'
 * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
 * const r = new RealAlgebra(1e-8)
 * const l = new LinearAlgebra(r)
 * const dim = 2
 * const p2d = new PolytopeAlgebra(dim, l)
 *
 * // Generate a new hypercube of edge length `2 * d` centred at the origin.
 * let d = 1
 * let p1 = p2d.hypercube(d)
 *
 * // p1
 * // +-----------+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\o\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * // Calculate the volume of polytopes
 * const vol = p2d.volume(p1)
 * vol.toString() // '4'
 *
 * // Generate a new facet.
 * // A facet is characterised by its normal vector (nvec),
 * // distance from the origin (d),
 * // and the direction of the normal vector (faceOutside).
 * let nvec = [1, 0]
 * d = 1
 * let faceOutside = true
 * let f = p2d.facet(nvec, d, faceOutside)
 *
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 * // \\\\\\o\\\\\| f
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 *
 * nvec = [1, 0]
 * d = 1
 * faceOutside = false
 * f = p2d.facet(nvec, d, faceOutside)
 *
 * //             |\\\\\\\\\\\\
 * //             |\\\\\\\\\\\\
 * //             |\\\\\\\\\\\\
 * //       o   f |\\\\\\\\\\\\
 * //             |\\\\\\\\\\\\
 * //             |\\\\\\\\\\\\
 * //             |\\\\\\\\\\\\
 *
 * // No need to normalise the normal vector,
 * // provided that `d` is the dot product of the normal vector and
 * // the position vector of a vertex on the facet.
 * f = p2d.facet([2, 0], 1, true)
 *
 * // \\\\\\\\\|
 * // \\\\\\\\\|
 * // \\\\\\\\\|
 * // \\\\\\o\\| f
 * // \\\\\\\\\|
 * // \\\\\\\\\|
 * // \\\\\\\\\|
 *
 * f = p2d.facet([2, 0], 2, true)
 *
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 * // \\\\\\o\\\\\| f
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 * // \\\\\\\\\\\\|
 *
 * // Add a facet to polytopes (in place)
 * p1 = p2d.hypercube(d)
 *
 * // p1
 * // +-----------+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\o\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * f = p2d.facet([2, -1], 1, true)
 *
 * // \\\\\\\\\\\\/
 * // \\\\\\\\\\\/
 * // \\\\\\\\\\/
 * // \\\\\\o\\/ f
 * // \\\\\\\\/
 * // \\\\\\\/
 * // \\\\\\/
 *
 * p1 = p2d.iaddFacet(p1, f)
 * p2d.volume(p1).toString() // '3'
 *
 * // p1
 * // +-----------+
 * // |\\\\\\\\\\/
 * // |\\\\\\\\\/
 * // |\\\\\o\\/
 * // |\\\\\\\/
 * // |\\\\\\/
 * // +-----+
 *
 * // Copy (generate a new object)
 * let p2 = p2d.copy(p1)
 * p2d.volume(p2).toString() // '3'
 *
 * // p2
 * // +-----------+
 * // |\\\\\\\\\\/
 * // |\\\\\\\\\/
 * // |\\\\\o\\/
 * // |\\\\\\\/
 * // |\\\\\\/
 * // +-----+
 *
 * // Rotation (new object is genrated, since v1.1.0)
 * const c4 = l.$(0, -1, 1, 0).setDim(2)
 * p2 = p2d.rotate(p1, c4)
 * p1 !== p2 // true
 * p2d.volume(p2).toString() // '3'
 *
 * // p2
 * // +-__
 * // |\\\--_
 * // |\\\\\\--__
 * // |\\\\\o\\\\-+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * // In-place rotation (new object is not genrated, since v1.1.0)
 * p2 = p2d.irotate(p2, c4)
 * p2d.volume(p2).toString() // '3'
 *
 * // p2
 * //       +-----+
 * //      /\\\\\\|
 * //     /\\\\\\\|
 * //    /\\o\\\\\|
 * //   /\\\\\\\\\|
 * //  /\\\\\\\\\\|
 * // +-----------+
 *
 * // Translation (new object is generated)
 * p2 = p2d.translate(p1, [r.$(1, 2), 0])
 * p1 !== p2 // true
 * p2d.volume(p2).toString() // '3'
 *
 * // p2
 * //    +-----------+
 * //    |\\\\\\\\\\/
 * //    |\\\\\\\\\/
 * //    |\\o\\\\\/
 * //    |\\\\\\\/
 * //    |\\\\\\/
 * //    +-----+
 *
 * // In-place translation (new object is not generated)
 * p1 = p2d.itranslate(p1, [r.$(1, 2), 0])
 * p2d.volume(p1).toString() // '3'
 *
 * // p1
 * //    +-----------+
 * //    |\\\\\\\\\\/
 * //    |\\\\\\\\\/
 * //    |\\o\\\\\/
 * //    |\\\\\\\/
 * //    |\\\\\\/
 * //    +-----+
 *
 * // Scaling (new object is generated)
 * p2 = p2d.scale(p1, 2)
 * p1 !== p2 // true
 * p2d.volume(p2).toString() // '12'
 *
 * // p2
 * // +-----------------------+
 * // |\\\\\\\\\\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\\\\\\/
 * // |\\\\\o\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\\/
 * // |\\\\\\\\\\\\/
 * // +-----------+
 *
 * // In-place scaling (new object is not generated)
 * p1 = p2d.iscale(p1, r.$(1, 3))
 * p2d.volume(p1).toString() // '1 / 3'
 *
 * //      p1
 * //      +---+
 * //      |o\/
 * //      +-+
 *
 * // Multiplication (intersection, new object is generated)
 * p1 = p2d.hypercube(1)
 * p2 = p2d.itranslate(p2d.hypercube(1), [1, 1])
 * let p3 = p2d.mul(p1, p2)
 * p3 !== p1 // true
 * p3 !== p2 // true
 * p2d.volume(p3).toString() // '1'
 *
 * //
 * //
 * //
 * // p1
 * // +-----------+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\o\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * //       p2
 * //       +-----------+
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       o-----------+
 * //
 * //
 * //
 *
 * //
 * //
 * //
 * //       p3
 * //       +-----+
 * //       |\\\\\|
 * //       |\\\\\|
 * //       o-----+
 * //
 * //
 * //
 *
 * // Subtraction (set difference, new object is generated)
 * p1 = p2d.hypercube(1)
 * p2 = p2d.itranslate(p2d.hypercube(1), [1, 1])
 * p3 = p2d.sub(p1, p2)
 * p3 !== p1 // true
 * p3 !== p2 // true
 * p2d.volume(p3).toString() // '3'
 *
 * //
 * //
 * //
 * // p1
 * // +-----------+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\o\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * //       p2
 * //       +-----------+
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       o-----------+
 * //
 * //
 * //
 *
 * //
 * //
 * //
 * // p3
 * // +-----+
 * // |\\\\\|
 * // |\\\\\|
 * // |\\\\\o-----+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * // Addition (union, new object is generated)
 * p1 = p2d.hypercube(1)
 * p2 = p2d.itranslate(p2d.hypercube(1), [1, 1])
 * p3 = p2d.add(p1, p2)
 * p3 !== p1 // true
 * p3 !== p2 // true
 * p2d.volume(p3).toString() // '7'
 *
 * //
 * //
 * //
 * // p1
 * // +-----------+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\o\\\\\|
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * //       p2
 * //       +-----------+
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       |\\\\\\\\\\\|
 * //       o-----------+
 * //
 * //
 * //
 *
 * //
 * //       +-----------+
 * //       |\\\\\\\\\\\|
 * // p3    |\\\\\\\\\\\|
 * // +-----+\\\\\\\\\\\|
 * // |\\\\\\\\\\\\\\\\\|
 * // |\\\\\\\\\\\\\\\\\|
 * // |\\\\\o\\\\\+-----+
 * // |\\\\\\\\\\\|
 * // |\\\\\\\\\\\|
 * // +-----------+
 *
 * // JSON (stringify and parse)
 * const str = JSON.stringify(p3)
 * const p4 = JSON.parse(str, p2d.reviver)
 * const p5 = p2d.mul(p3, p4)
 * p2d.volume(p4).toString() // '7'
 * p2d.volume(p5).toString() // '7'
 */
class PolytopeAlgebra {
  /**
   * @desc
   * The constructor function of the {@link PolytopeAlgebra} class.
   *
   * @param {number} dim
   * the dimension to be treated.
   *
   * @param {LinearAlgebra} lalg
   * an instance of {@link LinearAlgebra}.
   *
   * @throws {Error}
   * if `lalg` is not an instance of `LinearAlgebra`.
   *
   * @throws {Error}
   * if `lalg` is not an instance of real algebra.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p3d = new PolytopeAlgebra(3, l)
   *
   * p3d instanceof PolytopeAlgebra // true
   *
   * new PolytopeAlgebra(3, null) // Error
   * new PolytopeAlgebra(null, l) // Error
   *
   * l.isReal = () => false
   * new PolytopeAlgebra(3, l) // Error
   */
  constructor (dim, lalg) {
    if (typeof dim !== 'number' || !Number.isInteger(dim) || dim < 0) {
      throw Error('`dim` must be an positive integer or zero')
    }
    if (!(lalg instanceof LinearAlgebra)) {
      throw Error('`lalg` must be an instance of `LinearAlgebra`.')
    }
    if (!lalg.isReal()) {
      throw Error('`lalg` must be an implementation of real algebra.')
    }
    /**
     * @desc
     * The PolytopeAlgebra#dim is the dimension
     * treated in `this` polytope algebra.
     *
     * @type {LinearAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.dim = dim;
    /**
     * @desc
     * The PolytopeAlgebra#lalg is used to manipurate vectors an matrices.
     *
     * @type {LinearAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.lalg = lalg;
    /**
     * @desc
     * The PolytopeAlgebra#nvecCache stores all the normal vectors.
     *
     * @type {Array}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.nvecCache = [];
    /**
     * @desc
     * The PolytopeAlgebra#nvecCacheAbs2 stores
     * the square of the abolute value of normal vectors.
     *
     * @type {WeakMap}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this.nvecCacheAbs2 = new WeakMap();
  }

  /**
   * @desc
   * The PolytopeAlgebra#copy method returns a new instance of
   * {@link Polytope}
   * which has copies of instances of {@link ConvexPolytope}
   * as generated by {@link ConvexPolytope#copy}.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Polytope, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * p.length // 1
   * p[0].facets.length // 4
   * p[0].vertices.length // 4
   * p[0].edges.length // 4
   *
   * const p2 = p2d.copy(p)
   * p2 instanceof Polytope // true
   * p2 !== p // true
   * p2.length // 1
   * p2[0].facets.length // 4
   * p2[0].vertices.length // 4
   * p2[0].edges.length // 4
   *
   * const p3 = p2d.copy(new Polytope())
   * p3 instanceof Polytope // true
   * p3.isNull() // true
   *
   * p2d.copy(null) // Error
   * p[0].facets[0].nvec.push(1)
   */
  copy (p) {
    if (!(p instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    return p.copy(this.lalg)
  }

  /**
   * @desc
   * The PolytopeAlgebra#facet method generates
   * a new instance of {@link Facet}.
   * If a normal vector parallel to the given `nvec` exists
   * in `this.nvecCache`,
   * then the `nvec` is replaced by the cheched one,
   * and the other parameters are automatically calculated.
   * If no normal vector parallel to `nvec` has not been cached,
   * then `nvec` is cached.
   *
   * @param {Matrix} nvec
   * a {@link Matrix} representing the normal vector of the new facet.
   *
   * @param {RealAlgebraicElement} d
   * a {@link RealAlgebraicElement} which is equal to
   * the dot product of `nvec` and a vertex on the new facet.
   *
   * @param {boolean} faceOutside
   * `nvec` is considered to face toward outside/inside
   * of the new facet if `faceOutside` is `true`/`false`.
   *
   * @return {Facet}
   * a new instance of {@link Facet}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Facet, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(5, l)
   *
   * const nvec = l.$(1, 1, 1, 1, 1)
   * let f = p2d.facet(nvec, 3, true)
   * f instanceof Facet // true
   * f.nvec === nvec // true
   * r.eq(f.d, 3) // true
   * f.faceOutside // true
   *
   * f = p2d.facet(nvec, 3, true)
   * f instanceof Facet // true
   * f.nvec === nvec // true
   * r.eq(f.d, 3) // true
   * f.faceOutside // true
   *
   * const nvec2 = l.$(2, 2, 2, 2, 2)
   * f = p2d.facet(nvec2, 3, true)
   * f instanceof Facet // true
   * f.nvec === nvec2 // false
   * f.nvec === nvec // true
   * r.ne(f.d, 3) // true
   * r.eq(f.d, r.$(3, 2)) // true
   * f.faceOutside // true
   *
   * const nvec3 = l.$(-2, -2, -2, -2, -2)
   * f = p2d.facet(nvec3, 3)
   * f instanceof Facet // true
   * f.nvec === nvec3// false
   * f.nvec === nvec // true
   * r.ne(f.d, 3) // true
   * r.eq(f.d, r.$(-3, 2)) // true
   * f.faceOutside // false
   *
   * p2d.facet([0, 0, 0, 0, 0], 1, true) // Error
   * p2d.facet([0, 0, 0, 0], 1, true) // Error
   */
  facet (nvec, d, faceOutside = true) {
    const lalg = this.lalg;
    const ralg = lalg.salg;
    const f = new Facet(lalg.cast(nvec), ralg.copy(ralg.cast(d)), faceOutside);
    if (f.dim !== this.dim) {
      throw Error('facet must be the same dimension as `this`.')
    }
    nvec = f.nvec;
    if (!(this.nvecCache.includes(nvec))) {
      const lalg = this.lalg;
      const ralg = lalg.salg;
      // find a parallel normal vector
      const nvAbs2 = lalg.abs2(nvec);
      if (ralg.isZero(nvAbs2)) {
        throw Error('`nvec` must be a non-zero vector.')
      }
      let found = false;
      for (let i = this.nvecCache.length - 1; i >= 0; i -= 1) {
        const nv2 = this.nvecCache[i];
        const nv2Abs2 = this.nvecCacheAbs2.get(nv2);
        const dot = lalg.dot(nvec, nv2);
        if (ralg.eq(ralg.mul(dot, dot), ralg.mul(nvAbs2, nv2Abs2))) {
          // a parallel normal vector already exist
          f.nvec = nv2;
          f.d = ralg.imul(f.d, ralg.div(dot, nvAbs2));
          if (ralg.isNegative(dot)) {
            f.faceOutside = !f.faceOutside;
          }
          found = true;
          break
        }
      }
      if (!found) {
        // new normal vector
        this.nvecCache.push(nvec);
        this.nvecCacheAbs2.set(nvec, nvAbs2);
      }
    }
    return f
  }

  /**
   * @desc
   * The PolytopeAlgebra#hypercube method generates
   * an instance of {@link Polytope} representing
   * a hypercube of edge length `2 * d`.
   *
   * @param {RealAlgebraicElement} [d = Number.MAX_SAFE_INTEGER]
   * half the edge length.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope} representing a hypercube.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p4d = new PolytopeAlgebra(4, l)
   *
   * let p = p4d.hypercube()
   * p.length // 1
   * p[0].facets.length // 8
   * p[0].vertices.length // 16
   * p[0].edges.length // 32
   *
   * p = p4d.hypercube(r.$(1, 2))
   * r.eq(p4d.volume(p), 1) // true
   *
   * p = p4d.hypercube(1)
   * r.eq(p4d.volume(p), 16) // true
   *
   * p = p4d.hypercube(r.$(0, 2))
   * r.eq(p4d.volume(p), 0) // true
   *
   * p = p4d.hypercube(r.$(-1, 2))
   * r.eq(p4d.volume(p), 0) // true
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p0d = new PolytopeAlgebra(0, l)
   *
   * // 0-dim test
   * const p = p0d.hypercube()
   * p.length // 1
   * p[0].facets.length // 0
   * p[0].vertices.length // 1
   * p[0].edges.length // 0
   * p[0].dim // 0
   */
  hypercube (d = Number.MAX_SAFE_INTEGER) {
    const lalg = this.lalg;
    const ralg = lalg.salg;
    const dim = this.dim;
    if (dim === 0) {
      const cp = new ConvexPolytope([], [lalg.$()], []);
      return new Polytope(cp)
    }
    d = ralg.cast(d);
    if (ralg.isZero(d)) {
      return new Polytope()
    } else if (ralg.isNegative(d)) {
      return new Polytope()
    }
    const facets = [];
    const vertices = [];
    for (let i = 0; i < dim; i += 1) {
      const arr = [];
      for (let j = 0; j < dim; j += 1) {
        if (j === i) {
          arr.push(1);
        } else {
          arr.push(0);
        }
      }
      const nvec = lalg.cast(arr);
      facets.push(this.facet(nvec, d, true));
      facets.push(this.facet(nvec, ralg.neg(d), false));
    }
    const arr = [-1];
    for (let i = 1; i < dim; i += 1) {
      arr.push(1);
    }
    let i = 0;
    while (i < dim) {
      for (let j = i; j >= 0; j -= 1) {
        arr[j] *= -1;
      }
      const vertex = lalg.ismul(lalg.cast(arr), d);
      vertices.push(vertex);
      for (let j = 0; j < dim; j += 1) {
        if (arr[j] === 1) {
          facets[2 * j].vertices.push(vertex);
        } else {
          facets[2 * j + 1].vertices.push(vertex);
        }
      }
      for (i = 0; i < dim; i += 1) {
        if (arr[i] === 1) {
          break
        }
      }
    }
    const edges = ConvexPolytope.genEdges(dim, facets);
    const cp = new ConvexPolytope(facets, vertices, edges);
    return new Polytope(cp)
  }

  /**
   * @desc
   * The PolytopeAlgebra#iaddFacet method adds a facet
   * to an instance of {@link Polytope} *in place*.
   * The result is the intersection of the polytopes and the facet.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @param {Facet} f
   * an instance of {@link Facet}.
   *
   * @return {Polytope}
   * `p`.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope} of which
   * dimension is equal to `this.dim`.
   *
   * @throws {Error}
   * if `f` is not an instance of {@link Facet} of which
   * dimension is equal to `this.dim`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Polytope, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * let p = p2d.hypercube(1)
   * p.length // 1
   * p[0].facets.length // 4
   * p[0].vertices.length // 4
   * p[0].edges.length // 4
   *
   * const f = p2d.facet([1, 1], 0, true)
   * p = p2d.iaddFacet(p, f)
   * p.length // 1
   * p[0].facets.length // 3
   * p[0].vertices.length // 3
   * p[0].edges.length // 3
   *
   * let p2 = new Polytope()
   * p2 = p2d.iaddFacet(p2, f)
   * p2 instanceof Polytope // true
   * p2.isNull() // true
   *
   * let p3 = p2d.hypercube(1)
   * p3 = p2d.iaddFacet(p3, p2d.facet([0, 1], 1, true))
   * p3 = p2d.iaddFacet(p3, p2d.facet([0, 1], r.$(1, 2), true))
   * p3 = p2d.iaddFacet(p3, p2d.facet([0, 1], -1, true))
   * p3 instanceof Polytope // true
   * p3.isNull() // true
   *
   * p2d.iaddFacet(null, f) // Error
   * p2d.iaddFacet(p, null) // Error
   * p[0].vertices[0].push(1)
   * // invalid dimension of `p`
   * p2d.iaddFacet(p, f) // Error
   * p[0].vertices[0].pop()
   * // invalid dimension of `f`
   * f.nvec.push(1)
   * p2d.iaddFacet(p, f) // Error
   */
  iaddFacet (p, f) {
    const dim = this.dim;
    const lalg = this.lalg;
    const ralg = lalg.salg;
    if (!(p instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    if (p.isNull()) {
      return p
    }
    if (p.dim !== dim) {
      throw Error('the dimension of `p` must be the same as `this`.')
    }
    if (!(f instanceof Facet)) {
      throw Error('`f` must be an instance of `Facet`.')
    }
    if (f.dim !== dim) {
      throw Error('the dimension of `f` must be the same as `this`.')
    }
    for (let i = p.length - 1; i >= 0; i -= 1) {
      const cpi = p[i];
      // fast check
      for (let j = cpi.facets.length - 1; j >= 0; j -= 1) {
        const fj = cpi.facets[j];
        if (f.nvec === fj.nvec) {
          const dd = ralg.sub(f.d, fj.d);
          if (f.faceOutside === fj.faceOutside) {
            if (ralg.isZero(dd) || ralg.isPositive(dd) === f.faceOutside) {
              break
            }
          } else {
            if (ralg.isZero(dd) || ralg.isPositive(dd) !== f.faceOutside) {
              cpi.nullify();
              break
            }
          }
        }
        if (j === 0) {
          const newF = new Facet(f.nvec, ralg.copy(f.d), f.faceOutside);
          cpi.iaddFacet(newF, lalg);
        }
      }
      if (cpi.isNull()) {
        p.splice(i, 1);
      }
    }
    return p
  }

  /**
   * @desc
   * The PolytopeAlgebra#add method
   * calculates the union of two instances of {@link Polytope}
   * `p1` and `p2`.
   *
   * @param {Polytope} p1
   * an instance of {@link Polytope}.
   *
   * @param {Polytope} p2
   * another instance of {@link Polytope}.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Polytope, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   * const p1d = new PolytopeAlgebra(1, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.translate(p, [1, 1])
   * const p3 = p2d.add(p, p2)
   * p3 instanceof Polytope // true
   * p3.length // 3
   * p3 !== p // true
   * p3 !== p2 // true
   *
   * const p4 = p2d.add(p2, p3)
   * p4 instanceof Polytope // true
   * p4.length // 3
   *
   * r.eq(p2d.volume(p), 4) // true
   *
   * r.eq(p2d.volume(p2), 4) // true
   *
   * r.eq(p2d.volume(p3), 7) // true
   *
   * const p5 = p2d.add(p4, new Polytope())
   * p5 instanceof Polytope // true
   * p5.length // 3
   *
   * const p6 = p2d.add(new Polytope(), p4)
   * p6 instanceof Polytope // true
   * p6.length // 3
   *
   * p2d.add(p1d.hypercube(1), p2) // Error
   * p2d.add(p2, p1d.hypercube(1)) // Error
   * p2d.add(null, p2) // Error
   * p2d.add(p2, null) // Error
   */
  add (p1, p2) {
    if (!(p1 instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    if (!(p2 instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    if (p2.isNull()) {
      return this.copy(p1)
    } else if (p1.isNull()) {
      return this.copy(p2)
    }
    const dim = this.dim;
    if (p1.dim !== dim) {
      throw Error('the dimension of `p` must be the same as `this`.')
    }
    if (p2.dim !== dim) {
      throw Error('the dimension of `p` must be the same as `this`.')
    }
    let p3;
    if (p1.length < p2.length) {
      p3 = this.copy(p1);
      p3.push(...this.sub(p2, p1));
    } else {
      p3 = this.copy(p2);
      p3.push(...this.sub(p1, p2));
    }
    p3.reduce(this.lalg);
    return p3
  }

  /**
   * @desc
   * The PolytopeAlgebra#sub method
   * calculates the set difference of two instances of {@link Polytope}
   * `p1` \ `p2`.
   *
   * @param {Polytope} p1
   * an instance of {@link Polytope}.
   *
   * @param {Polytope} p2
   * another instance of {@link Polytope}.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Polytope, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   * const p1d = new PolytopeAlgebra(1, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.translate(p, [1, 1])
   * const p3 = p2d.sub(p, p2)
   * p3 instanceof Polytope // true
   * p3.length // 2
   * p3 !== p // true
   * p3 !== p2 // true
   *
   * r.eq(p2d.volume(p), 4) // true
   *
   * r.eq(p2d.volume(p2), 4) // true
   *
   * r.eq(p2d.volume(p3), 3) // true
   *
   * p3.nullify()
   * const p4 = p2d.sub(p3, p2)
   * p4 instanceof Polytope // true
   * p4.length // 0
   *
   * p2d.sub(p2, p1d.hypercube(1)) // Error
   * p2d.sub(p1d.hypercube(1), p2) // Error
   * p2d.sub(null, p2) // Error
   * p2d.sub(p2, null) // Error
   */
  sub (p1, p2) {
    if (!(p1 instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    if (!(p2 instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    if (p1.isNull() || p2.isNull()) {
      return this.copy(p1)
    }
    const dim = this.dim;
    if (p1.dim !== dim) {
      throw Error('the dimension of `p` must be the same as `this`.')
    }
    if (p2.dim !== dim) {
      throw Error('the dimension of `p` must be the same as `this`.')
    }
    const lalg = this.lalg;
    let p3 = this.copy(p1);
    for (let j = p2.length - 1; j >= 0; j -= 1) {
      const cpj = p2[j];
      const p4 = new Polytope();
      for (let i = p3.length - 1; i >= 0; i -= 1) {
        p4.push(...p3[i].imulSub(cpj, lalg));
      }
      p3 = p4;
      p3.reduce(lalg);
    }
    return p3
  }

  /**
   * @desc
   * The PolytopeAlgebra#mul method
   * calculates the intersection of two instances of {@link Polytope}
   * `p1` and `p2`.
   *
   * @param {Polytope} p1
   * an instance of {@link Polytope}.
   *
   * @param {Polytope} p2
   * another instance of {@link Polytope}.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Polytope, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   * const p1d = new PolytopeAlgebra(1, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.translate(p, [1, 1])
   * const p3 = p2d.mul(p, p2)
   * p3 instanceof Polytope // true
   * p3.length // 1
   * p3 !== p // true
   * p3 !== p2 // true
   *
   * r.eq(p2d.volume(p), 4) // true
   *
   * r.eq(p2d.volume(p2), 4) // true
   *
   * r.eq(p2d.volume(p3), 1) // true
   *
   * p3.nullify()
   * const p4 = p2d.mul(p3, p2)
   * p4 instanceof Polytope // true
   * p4.length // 0
   *
   * const p1 = p1d.hypercube(1)
   * p2d.mul(p1, p2) // Error
   * p2d.mul(p2, p1) // Error
   * p2d.mul(null, p2) // Error
   * p2d.mul(p2, null) // Error
   */
  mul (p1, p2) {
    if (!(p1 instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    if (!(p2 instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    if (p1.isNull() || p2.isNull()) {
      return new Polytope()
    }
    const dim = this.dim;
    if (p1.dim !== dim) {
      throw Error('the dimension of `p` must be the same as `this`.')
    }
    if (p2.dim !== dim) {
      throw Error('the dimension of `p` must be the same as `this`.')
    }
    const lalg = this.lalg;
    const p3 = new Polytope();
    for (let i = p1.length - 1; i >= 0; i -= 1) {
      const cpi = p1[i];
      for (let j = p2.length - 1; j >= 0; j -= 1) {
        const cp = p2[j].copy(lalg).imul(cpi, lalg);
        if (!cp.isNull()) {
          p3.push(cp);
        }
      }
    }
    p3.reduce(lalg);
    return p3
  }

  /**
   * @desc
   * The PolytopeAlgebra#rotate method
   * returns a copy of `p` rotated by translated by a rotation matrix `m`.
   * A rotation matrix is a orthogonal matrix,
   * i.e. its inverse is equal to its transpose.
   *
   * CAUTION: this method does not check if `m` is an orthogonal matrix.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @param {Matrix} m
   * an instance of {@link Matrix} representing an orthogonal matrix.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.rotate(p, l.$(0, -1, 1, 0).setDim(2))
   * p !== p2 // true
   * p2.length // 1
   * l.eq(p2[0].facets[0].nvec, l.$(0, 1)) // true
   * l.eq(p2[0].facets[1].nvec, l.$(0, 1)) // true
   * l.eq(p2[0].facets[2].nvec, l.$(1, 0)) // true
   * l.eq(p2[0].facets[3].nvec, l.$(1, 0)) // true
   * p2[0].facets[0].nvec === p[0].facets[2].nvec // true
   * p2[0].facets[1].nvec === p[0].facets[2].nvec // true
   * p2[0].facets[2].nvec === p[0].facets[0].nvec // true
   * p2[0].facets[3].nvec === p[0].facets[0].nvec // true
   * r.eq(p2[0].facets[0].d, 1) // true
   * r.eq(p2[0].facets[1].d, -1) // true
   * r.eq(p2[0].facets[2].d, -1) // true
   * r.eq(p2[0].facets[3].d, 1) // true
   * l.eq(p2[0].vertices[0], [-1, 1]) // true
   * l.eq(p2[0].vertices[1], [-1, -1]) // true
   * l.eq(p2[0].vertices[2], [1, 1]) // true
   * l.eq(p2[0].vertices[3], [1, -1]) // true
   */
  rotate (p, m) {
    return this.irotate(this.copy(p), m)
  }

  /**
   * @desc
   * The PolytopeAlgebra#irotate method rotates an instance of
   * {@link Polytope} `p` by a rotation matrix `m` *in place*.
   * A rotation matrix is a orthogonal matrix,
   * i.e. its inverse is equal to its transpose.
   *
   * CAUTION: this method does not check if `m` is an orthogonal matrix.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @param {Matrix} m
   * an instance of {@link Matrix} representing an orthogonal matrix.
   *
   * @return {Polytope}
   * `p`.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.1.0
   * @since 1.1.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.irotate(p, l.$(0, -1, 1, 0).setDim(2))
   * p === p2 // true
   * p.length // 1
   * l.eq(p[0].facets[0].nvec, l.$(0, 1)) // true
   * l.eq(p[0].facets[1].nvec, l.$(0, 1)) // true
   * l.eq(p[0].facets[2].nvec, l.$(1, 0)) // true
   * l.eq(p[0].facets[3].nvec, l.$(1, 0)) // true
   * r.eq(p[0].facets[0].d, 1) // true
   * r.eq(p[0].facets[1].d, -1) // true
   * r.eq(p[0].facets[2].d, -1) // true
   * r.eq(p[0].facets[3].d, 1) // true
   * l.eq(p[0].vertices[0], [-1, 1]) // true
   * l.eq(p[0].vertices[1], [-1, -1]) // true
   * l.eq(p[0].vertices[2], [1, 1]) // true
   * l.eq(p[0].vertices[3], [1, -1]) // true
   *
   * p2d.irotate(null, l.cast([0, -1, 1, 0]).setDim(2)) // Error
   */
  irotate (p, m) {
    if (!(p instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    const lalg = this.lalg;
    for (let i = p.length - 1; i >= 0; i -= 1) {
      p[i].irotate(m, lalg);
      for (let j = p[i].facets.length - 1; j >= 0; j -= 1) {
        const fj = p[i].facets[j];
        p[i].facets[j] = this.facet(fj.nvec, fj.d, fj.faceOutside);
        p[i].facets[j].vertices = fj.vertices;
      }
    }
    return p
  }

  /**
   * @desc
   * The PolytopeAlgebra#translate method
   * returns a copy of `p` translated by `v`.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @param {Matrix} v
   * an instance of {@link Matrix} representing a vector.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.translate(p, [1, 1])
   * p !== p2 // true
   * p.length // 1
   * p2.length // 1
   * r.eq(p[0].facets[0].d, 1) // true
   * r.eq(p[0].facets[1].d, -1) // true
   * r.eq(p[0].facets[2].d, 1) // true
   * r.eq(p[0].facets[3].d, -1) // true
   * r.eq(p2[0].facets[0].d, 2) // true
   * r.eq(p2[0].facets[1].d, 0) // true
   * r.eq(p2[0].facets[2].d, 2) // true
   * r.eq(p2[0].facets[3].d, 0) // true
   * l.eq(p[0].vertices[0], [1, 1]) // true
   * l.eq(p[0].vertices[1], [-1, 1]) // true
   * l.eq(p[0].vertices[2], [1, -1]) // true
   * l.eq(p[0].vertices[3], [-1, -1]) // true
   * l.eq(p2[0].vertices[0], [2, 2]) // true
   * l.eq(p2[0].vertices[1], [0, 2]) // true
   * l.eq(p2[0].vertices[2], [2, 0]) // true
   * l.eq(p2[0].vertices[3], [0, 0]) // true
   *
   * p2d.translate(null, [1, 1]) // Error
   */
  translate (p, v) {
    return this.itranslate(this.copy(p), v)
  }

  /**
   * @desc
   * The PolytopeAlgebra#itranslate method
   * translates an instance of {@link Polytope} `p` by `v` *in place*.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @param {Matrix} v
   * an instance of {@link Matrix} representing a vector.
   *
   * @return {Polytope}
   * `p`.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.itranslate(p, [1, 1])
   * p === p2 // true
   * p.length // 1
   * r.eq(p[0].facets[0].d, 2) // true
   * r.eq(p[0].facets[1].d, 0) // true
   * r.eq(p[0].facets[2].d, 2) // true
   * r.eq(p[0].facets[3].d, 0) // true
   * l.eq(p[0].vertices[0], [2, 2]) // true
   * l.eq(p[0].vertices[1], [0, 2]) // true
   * l.eq(p[0].vertices[2], [2, 0]) // true
   * l.eq(p[0].vertices[3], [0, 0]) // true
   *
   * p2d.itranslate(null, [1, 1]) // Error
   */
  itranslate (p, v) {
    if (!(p instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    const lalg = this.lalg;
    for (let i = p.length - 1; i >= 0; i -= 1) {
      p[i].itranslate(v, lalg);
    }
    return p
  }

  /**
   * @desc
   * The PolytopeAlgebra#scale method returns a copy of `p`
   * scaled by `s` around the origin.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @param {RealAlgebraicElement} s
   * a {@link RealAlgebraicElement} representing a scale factor.
   *
   * @return {Polytope}
   * a new instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.scale(p, 2)
   * p === p2 // false
   * p.length // 1
   * p2.length // 1
   * r.eq(p[0].facets[0].d, 1) // true
   * r.eq(p[0].facets[1].d, -1) // true
   * r.eq(p[0].facets[2].d, 1) // true
   * r.eq(p[0].facets[3].d, -1) // true
   * r.eq(p2[0].facets[0].d, 2) // true
   * r.eq(p2[0].facets[1].d, -2) // true
   * r.eq(p2[0].facets[2].d, 2) // true
   * r.eq(p2[0].facets[3].d, -2) // true
   * l.eq(p[0].vertices[0], [1, 1]) // true
   * l.eq(p[0].vertices[1], [-1, 1]) // true
   * l.eq(p[0].vertices[2], [1, -1]) // true
   * l.eq(p[0].vertices[3], [-1, -1]) // true
   * l.eq(p2[0].vertices[0], [2, 2]) // true
   * l.eq(p2[0].vertices[1], [-2, 2]) // true
   * l.eq(p2[0].vertices[2], [2, -2]) // true
   * l.eq(p2[0].vertices[3], [-2, -2]) // true
   *
   * p2d.scale(null, 2) // Error
   */
  scale (p, s) {
    return this.iscale(this.copy(p), s)
  }

  /**
   * @desc
   * The PolytopeAlgebra#iscale method scales an instance of
   * {@link Polytope} `p` by `s` *in place* around the origin.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @param {RealAlgebraicElement} s
   * a {@link RealAlgebraicElement} representing a scale factor.
   *
   * @return {Polytope}
   * `p`.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.iscale(p, 2)
   * p === p2 // true
   * p.length // 1
   * r.eq(p[0].facets[0].d, 2) // true
   * r.eq(p[0].facets[1].d, -2) // true
   * r.eq(p[0].facets[2].d, 2) // true
   * r.eq(p[0].facets[3].d, -2) // true
   * l.eq(p[0].vertices[0], [2, 2]) // true
   * l.eq(p[0].vertices[1], [-2, 2]) // true
   * l.eq(p[0].vertices[2], [2, -2]) // true
   * l.eq(p[0].vertices[3], [-2, -2]) // true
   *
   * p2d.iscale(null, 2) // Error
   */
  iscale (p, s) {
    if (!(p instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    const lalg = this.lalg;
    for (let i = p.length - 1; i >= 0; i -= 1) {
      p[i].iscale(s, lalg);
    }
    return p
  }

  /**
   * @desc
   * The PolytopeAlgebra#genSimplexes method
   * generates simplexes from  an instance of {@link Polytope}.
   * Each simplex is an {@link Array} containing the vertices of the simplex.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @return {Array}
   * an {@link Array} containing the generated simplexes.
   *
   * @throws {Error}
   * if `p` is not an instance of {@link Polytope}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Polytope, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p3d = new PolytopeAlgebra(3, l)
   *
   * const p = p3d.hypercube(1)
   * let simplexes = p3d.genSimplexes(p)
   * simplexes instanceof Array // true
   * simplexes.length // 6
   * simplexes[0].length // 4
   *
   * simplexes = p3d.genSimplexes(new Polytope())
   * simplexes instanceof Array // true
   * simplexes.length // 0
   *
   * // invalid type
   * p3d.genSimplexes(null) // Error
   * p[0].vertices[0].push(1)
   * p.dim // 4
   * // inconsistent dimension
   * p3d.genSimplexes(p) // Error
   */
  genSimplexes (p) {
    if (!(p instanceof Polytope)) {
      throw Error('`p` must be an instance of `Polytope`.')
    }
    return p.genSimplexes()
  }

  /**
   * @desc
   * The PolytopeAlgebra#volume function calculates the volume of simplexes.
   *
   * @param {Polytope} p
   * an instance of {@link Polytope}.
   *
   * @return {RealAlgebraicElement}
   * the volume of the given simplexes.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * r.eq(p2d.volume(p), 4) // true
   */
  volume (p) {
    return Polytope.volume(this.genSimplexes(p), this.lalg)
  }

  /**
   * @desc
   * The reviver function for the {@link Polytope}.
   *
   * @type {Function}
   *
   * @version 1.1.4
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { Polytope, PolytopeAlgebra } from '@kkitahara/polytope-algebra'
   * const r = new RealAlgebra()
   * const l = new LinearAlgebra(r)
   * const p2d = new PolytopeAlgebra(2, l)
   *
   * const p = p2d.hypercube(1)
   * const p2 = p2d.translate(p, [1, 1])
   * const p3 = p2d.add(p, p2)
   *
   * const s = JSON.stringify(p3)
   * typeof s // 'string'
   *
   * const p4 = JSON.parse(s, p2d.reviver)
   * p4 instanceof Polytope // true
   * r.eq(p2d.volume(p4), 7) // true
   *
   * const s2 = s.replace('1.1.4', '0.0.0')
   * JSON.parse(s2, p2d.reviver) // Error
   */
  get reviver () {
    return (key, value) => {
      const lalg = this.lalg;
      if (value !== null && typeof value === 'object' &&
          value.reviver === 'Polytope') {
        if (value.version === '1.1.4') {
          const p = new Polytope();
          const nvecs = value.nvecs;
          for (let i = value.convexPolytopes.length - 1; i >= 0; i -= 1) {
            const cpData = value.convexPolytopes[i];
            const vertices = cpData.vertices;
            const facets = [];
            const edges = [];
            for (let j = cpData.facets.length - 1; j >= 0; j -= 1) {
              const fData = cpData.facets[j];
              const f = this.facet(nvecs[fData[0]], fData[1], fData[2]);
              const fvID = fData[3];
              for (let k = fvID.length - 1; k >= 0; k -= 1) {
                f.vertices.push(vertices[fvID[k]]);
              }
              facets.push(f);
            }
            for (let j = cpData.edges.length - 1; j >= 0; j -= 1) {
              const eData = cpData.edges[j];
              edges.push(new Edge(vertices[eData[0]], vertices[eData[1]]));
            }
            p.push(new ConvexPolytope(facets, vertices, edges, cpData.weight));
          }
          return p
        } else {
          throw Error('invalid version.')
        }
      } else {
        value = lalg.reviver(key, value);
        return value
      }
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @desc
 * The {@link InvalidValue} is the class for invalid values.
 *
 * @type {Error}
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class InvalidValue extends Error {
  constructor (...args) {
    super(...args);
    this.name = 'InvalidValue';
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const _value$1 = new WeakMap();

/**
 * @desc
 * The {@link MultiKeyWeakMap} is the class for multi-key weak map.
 *
 * @version 1.0.0
 * @since 1.0.0
 *
 * @example
 * import { MultiKeyWeakMap } from '@kkitahara/qc-tools'
 *
 * let a = new MultiKeyWeakMap()
 * let b = {}
 * let c = {}
 * let d = {}
 *
 * a.set([b, c], 1)
 * a.set([c, b], 2)
 * a.set([b], 3)
 * a.set([c, b, d], 4)
 *
 * a.get([b, c]) // 1
 * a.get([c, b]) // 2
 * a.get([b]) // 3
 * a.get([c, b, d]) // 4
 * a.get([c]) // undefined
 * a.get([c, d, b]) // undefined
 *
 * a.has([b, c]) // true
 * a.has([c, b]) // true
 * a.has([b]) // true
 * a.has([c, b, d]) // true
 * a.has([c]) // false
 * a.has([c, d, b]) // false
 *
 * a.delete([b]) // true
 * a.delete([c, b, d]) // true
 * a.delete([c]) // false
 * a.delete([c, d, b]) // false
 *
 * a.has([b, c]) // true
 * a.has([c, b]) // true
 * a.has([b]) // false
 * a.has([c, b, d]) // false
 * a.has([c]) // false
 * a.has([c, d, b]) // false
 *
 * a = new MultiKeyWeakMap([
 *   [[b, c], 1],
 *   [[c, b], 2],
 *   [[b], 3],
 *   [[c, b, d], 4]])
 * a.get([b, c]) // 1
 * a.get([c, b]) // 2
 * a.get([b]) // 3
 * a.get([c, b, d]) // 4
 * a.get([c]) // undefined
 * a.get([c, d, b]) // undefined
 */
class MultiKeyWeakMap$1 extends WeakMap {
  /**
   * @desc
   * The constructor function of the {@link MultiKeyWeakMap} class.
   *
   * @param {object} iterable
   * An iterable object of which elements are arrays of [keys, value] pairs.
   * Each `keys` is an array of keys.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (...args) {
    super();
    const iterable = args[0];
    if (iterable !== undefined && iterable !== null) {
      for (const [keys, value] of iterable) {
        this.set(keys, value);
      }
    }
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#delete} removes any value associated to the
   * `keys` from `this` weak map.
   *
   * @param {object[]} keys
   *
   * @return {boolean}
   * `true` if a value is successfully removed, and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  delete (keys) {
    if (keys.length === 0) {
      return _value$1.delete(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return false
    }
    return child.delete(keys.slice(1))
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#get} returns the value associated to the `keys`
   * if exist in `this` weak map, or `undefined` otherwise.
   *
   * @param {object[]} keys
   *
   * @return {object|undefined}
   * The value associated to the `keys` if exist, or `undefined.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get (keys) {
    if (keys.length === 0) {
      return _value$1.get(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return undefined
    }
    return child.get(keys.slice(1))
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#has} returns `true` if a value is associated to
   * the `keys` in `this` weak map, or `false` otherwise.
   *
   * @param {object[]} keys
   *
   * @return {boolean}
   * `true` if a value is associated to the `keys`, or `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  has (keys) {
    if (keys.length === 0) {
      return _value$1.has(this)
    }
    const child = super.get(keys[0]);
    if (!child) {
      return false
    }
    return child.has(keys.slice(1))
  }

  /**
   * @desc
   * The {@link MultiKeyWeakMap#set} sets the `value` for the `keys` in `this`
   * weak map.
   *
   * @param {object[]} keys
   * @param {Any} value
   *
   * @return {MultiKeyWeakMap}
   * `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  set (keys, value) {
    if (keys.length === 0) {
      _value$1.set(this, value);
      return this
    }
    const key0 = keys[0];
    let child = super.get(key0);
    if (!child) {
      child = new MultiKeyWeakMap$1();
      super.set(key0, child);
    }
    child.set(keys.slice(1), value);
    return this
  }
}

Object.defineProperty(
  MultiKeyWeakMap$1.prototype,
  Symbol.toStringTag,
  {
    value: 'MultiKeyWeakMap',
    writable: false,
    enumerable: false,
    configurable: true
  }
);

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @desc
 * The {@link DEFAULT_EPS} is used as a default tolerance for equality
 * for numerical algebra.
 *
 * @type {number}
 *
 * @version 1.0.0
 * @since 1.0.0
 */
const DEFAULT_EPS = 1e-10;

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The {@link Group} class is a class for groups.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class Group {
  /**
   * @desc
   * The constructor function of the {@link Group} class.
   *
   * @param {Array} g
   * An array containing one or more group elements, otherwise the constructor
   * returns an instance of {@link InvaldValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (g) {
    if (!Array.isArray(g) || g.length === 0) {
      return new InvalidValue(` (in Group constructor)
        \`g\` must be an array containing one or more group elements.`)
    }
    /**
     * @desc
     * The {@link Group#_g} stores all the group elements of `this` group.
     *
     * Users should not change this property directly.
     *
     * @type {Array}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._g = g;
  }

  /**
   * @desc
   * The {@link Group#order} is the number of the group elements of `this`
   * group.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get order () {
    return this._g.length
  }

  /**
   * @desc
   * The {@link Group.genOrbit} method returns an object with `orbit`, `orbitGIds`
   * and `gOrbitId` properties.
   *
   * The `orbit` is an array containing the elements of the orbit generated
   * from a given object `x`.
   *
   * The `orbitGIds` is an array containing arrays of the indices of
   * the group elements. The array at index `i` contains the indices of the
   * group elements which transform `x` to `i`-th element of the orbit.
   *
   * The `gOrbitId` is an array containing the indices of the elements of
   * the orbit. The index at index `i` is the index of the element of the orbit
   * which is generated by the `i`-th group element.
   *
   * @param {Object} x
   * An object from which orbit is generated.
   *
   * @param {Function} applyFunc
   * A function which takes `x` and an element of `this` group as parameters
   * and returns an element of `orbit`.
   *
   * @param {Function} eqFunc
   * A function which takes two elements of `orbit` as parameters
   * and returns `true` if the two elements are considered to be equal
   * and `false` otherwise.
   *
   * @return {Object}
   * An object with `orbit`, `orbitGIds` and `gOrbitId` properties.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  genOrbit (x, applyFunc, eqFunc) {
    const orbit = [];
    const orbitGIds = [];
    const gOrbitId = [];
    this._g.forEach((gi, i) => {
      const xi = applyFunc(x, gi);
      if (orbit.every((xj, j) => {
        if (!eqFunc(xi, xj)) {
          return true
        } else {
          gOrbitId.push(j);
          orbitGIds[j].push(i);
          return false
        }
      })) {
        gOrbitId.push(orbit.length);
        orbit.push(xi);
        orbitGIds.push([i]);
      }
    });
    return {
      orbit: orbit,
      orbitGIds: orbitGIds,
      gOrbitId: gOrbitId }
  }

  /**
   * @desc
   * The {@link Group.removeDuplicates} returns a new array containing the
   * nonduplicate elements in the given array `g`.
   *
   * @param {Array} g
   * An array containing group elements.
   *
   * @param {Function} eqFunc
   * A function which takes a two elements of `g` as parameters and returns
   * `true` if the two elements are considered to be equal and `false`
   * otherwise.
   *
   * @return {Array|Error}
   * An array containing nonduplicate group elements on successful exit, or an
   * {@link InvalidValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  static removeDuplicates (g, eqFunc) {
    if (!(g instanceof Array)) {
      return new InvalidValue(` (in Group.removeDuplicates)
        \`g\` must be an array.`)
    }
    return g.reduce((arr, gi) => {
      if (arr.every(gj => {
        return !eqFunc(gj, gi)
      })) {
        arr.push(gi);
      }
      return arr
    }, [])
  }

  /**
   * @desc
   * The {@link Group.genElements} generates all the group elements from the
   * given `generators`.
   *
   * @param {object} identity
   * The identity element of the group to be generated.
   *
   * @param {Array} generators
   * An array containing generators.
   *
   * @param {mulFunc}
   * A function which takes a generator and a group element as parameters and
   * returns the product of the two elements.
   *
   * @param {Function} eqFunc
   * A function which takes a generated element and a group element as
   * parameters and returns `true` if the two elements are considered to be
   * equal and `false` otherwise.
   *
   * @param {number} max
   * Stops if the number of group elements exceeds `max`. In that case, an
   * instance of {@link InvalidValue} is returned.
   *
   * @return {Array|Error}
   * An array containing generated group elements on successful exit, or an
   * {@link InvalidValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  static genElements (identity, generators, mulFunc, eqFunc, max) {
    if (!(generators instanceof Array)) {
      return new InvalidValue(` (in Group.genElements)
        \`generators\` must be an array.`)
    }
    if (!Number.isInteger(max) || max < 1) {
      return new InvalidValue(` (in Group.genElements)
        \`max\` must be a positive (non-zero) integer.`)
    }
    const g = [identity];
    let i = 0;
    let j = 0;
    const n = generators.length;
    while (g.length <= max) {
      if (i === n) {
        j += 1;
        i = 0;
      }
      if (j === g.length) {
        break
      }
      const gi = generators[i];
      const gj = g[j];
      const gk = mulFunc(gi, gj);
      if (g.every(gl => !eqFunc(gk, gl))) {
        g.push(gk);
      }
      i += 1;
    }
    if (g.length > max) {
      return new InvalidValue(` (in Group.genElements)
        The number of group elements excceds \`max\`.`)
    }
    return g
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @desc
 * The {@link SpaceGroupSymop} class is a class for space-group symmetry
 * operations. An operation has a rotation matrix `R` and a translation vector
 * `t`. An equivalent position `v'` is generated from a given position `v` as
 * `v' = R v + t`.
 *
 * @version
 * 1.0.0
 *
 * @since
 * 1.0.0
 */
class SpaceGroupSymop {
  /**
   * @desc
   * The constructor function of the {@link SpaceGroupSymop} class.
   * Users should not use this constructor directly.
   * Use {@link Quasicrystal#genSGSymop} method instead.
   *
   * @param {Matrix} rot
   * A rotation matrix.
   *
   * @param {Matrix} trans
   * A translation vector.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (rot, trans) {
    /**
     * @desc
     * The {@link SpaceGroupSymop#_rot} is the rotation matrix of `this`
     * space-group symmetry operation.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._rot = rot;
    /**
     * @desc
     * The {@link SpaceGroupSymop#_trans} is the translation vector of `this`
     * space-group symmetry operation.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._trans = trans;
  }

  /**
   * @desc
   * The {@link SpaceGroupSymop#dim} is the dimension to which `this` space-group
   * symmetry operaion conforms.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dim () {
    return this._trans.length
  }

  /**
   * @desc
   * The {@link SpaceGroupSymop#rot} is the rotation matrix of `this` space-group
   * symmetry operation.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get rot () {
    return this._rot
  }

  /**
   * @desc
   * The {@link SpaceGroupSymop#trans} is the translation vector of `this`
   * space-group symmetry operation.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get trans () {
    return this._trans
  }

  /**
   * @desc
   * The {@link SpaceGroupSymop#copy} method returns a copy of `this`
   * space-group symmetry operation.
   *
   * @param {LinearAlgebra} lalg
   * An instance of {@link LinearAlgebra}.
   *
   * @return {SpaceGroupSymop}
   * A copy of `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { SpaceGroupSymop } from '@kkitahara/qc-tools'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   *
   * let rot = [0, 1, 1, 0]
   * let trans = [0, 0]
   * let g = new SpaceGroupSymop(rot, trans, l)
   * let g2 = g.copy(l)
   * g.rot === g2.rot // false
   * g.trans === g2.trans // false
   * g.rot[0] === g2.rot[0] // false
   * g.trans[0] === g2.trans[0] // false
   * l.eq(g.rot, g2.rot) // true
   * l.eq(g.trans, g2.trans) // true
   */
  copy (lalg) {
    const rot = lalg.copy(this._rot);
    const trans = lalg.copy(this._trans);
    return new SpaceGroupSymop(rot, trans)
  }

  /**
   * @desc
   * The {@link SpaceGroupSymop.identity} creates a new instance of
   * {@link SpaceGroupSymop} which represents the identity operation in the given
   * dimension `dim`.
   *
   * @param {LinearAlgebra} lalg
   * An instance of {@link LinearAlgebra}.
   *
   * @param {number} dim
   * A dimension (positive integer).
   *
   * @return {SpaceGroupSymop}
   * An instance of {@link SpaceGroupSymop} representing the identity operation.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  static identity (lalg, dim) {
    const dimp1 = dim + 1;
    const rot = lalg.$(
      ...[...new Array(dim * dim)].map((x, i) => i % dimp1 === 0 ? 1 : 0)
    ).setDim(dim, dim);
    const trans = lalg.$(...new Array(dim).fill(0));
    return new SpaceGroupSymop(rot, trans)
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The {@link SpaceGroup} class is a class for space groups.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class SpaceGroup extends Group {
  /**
   * @desc
   * The constructor function of the {@link SpaceGroup} class.
   *
   * @param {SpaceGroupSymop[]} g
   * An array containing one or more space-group symmetry operations, otherwise
   * the constructor returns an instance of {@link InvaldValue}. `g` must not
   * contain any lattice periodic translations. The identity operation must be
   * the first element.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { SpaceGroup, SpaceGroupSymop, InvalidValue }
   *   from '@kkitahara/qc-tools'
   *
   * // non symop paramter
   * let g = new SpaceGroupSymop(
   *   [1, 0, 0, 1], [0, 0])
   * new SpaceGroup([null]) instanceof InvalidValue // true
   * new SpaceGroup([g, null]) instanceof InvalidValue // true
   *
   * // inconsistent dim
   * let g2 = new SpaceGroupSymop(
   *   [1], [0])
   * new SpaceGroup([g, g2]) instanceof InvalidValue // true
   */
  constructor (g) {
    super(g);
    if (!(g[0] instanceof SpaceGroupSymop)) {
      return new InvalidValue(` (in SpaceGroup constructor)
        All the elements of \`g\` must be instances of \`SpaceGroupSymops\`.`)
    }
    const dim = g[0].dim;
    if (g.slice(1).some(
      gi => !(gi instanceof SpaceGroupSymop) || gi.dim !== dim
    )) {
      return new InvalidValue(` (in SpaceGroup constructor)
        All the elements of \`g\` must be instances of \`SpaceGroupSymops\` of
        the same dimension.`)
    }
  }

  /**
   * @desc
   * The {@link SpaceGroup#dim} is the dimension to which `this` space group
   * conforms.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dim () {
    return this._g[0].dim
  }

  /**
   * @desc
   * The {@link SpaceGroup#symop} is an array containing all the symmetry
   * operations (excluding lattice periodic translations) of `this` space group.
   *
   * Users should not change the contents of the returned value.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get symop () {
    return this._g
  }

  /**
   * @desc
   * The {@link SpaceGroup#copy} method returns a copy of `this` space group.
   *
   * @param {LinearAlgebra} lalg
   * An instance of {@link LinearAlgebra}.
   *
   * @return {SpaceGroup}
   * A copy of `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  copy (lalg) {
    return new SpaceGroup(this._g.map(gi => gi.copy(lalg)))
  }

  /**
   * @desc
   * The {@link SpaceGroup#genStar} method is functionally equivalent to the
   * {@link Group#genOrbit} method, but the names of the properties of the
   * returned object are different.
   *
   * @param {Object} x
   * An object from which star is generated.
   *
   * @param {Function} applyFunc
   * A function which takes `x` and an element of `this` group as parameters
   * and returns an element of `star`.
   *
   * @param {Function} eqFunc
   * A function which takes two elements of `star` as parameters
   * and returns `true` if the two elements are considered to be equal
   * and `false` otherwise.
   *
   * @return {Object}
   * An object with `star`, `starSymopIds` and `symopStarId` properties.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  genStar (x, applyFunc, eqFunc) {
    const obj = this.genOrbit(x, applyFunc, eqFunc);
    return {
      star: obj.orbit,
      starSymopIds: obj.orbitGIds,
      symopStarId: obj.gOrbitId }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The {@link PointGroup} class is a class for point groups.
 *
 * All the group operationsceGroup} are assumed to be square matrices.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class PointGroup extends Group {
  /**
   * @desc
   * The constructor function of the {@link PointGroup} class.
   *
   * @param {Matrix[]} g
   * An array containing one or more point-group symmetry operations, otherwise
   * the constructor returns an instance of {@link InvaldValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (g) {
    super(g);
    const dim = g[0].getDim()[0];
    if (g.some(gi => !gi.isSquare() || gi.getDim()[0] !== dim)) {
      return new InvalidValue(` (in PointGroup constructor)
        All the elements of \`g\` must be square matrices of the same
        dimension.`)
    }
  }

  /**
   * @desc
   * The {@link PointGroup#symop} is an array containing all the symmetry
   * operations of `this` point group.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get symop () {
    return this._g
  }

  /**
   * @desc
   * The {@link PointGroup#dim} is the dimension to which `this` point group
   * conforms.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dim () {
    return this.symop[0].getDim()[0]
  }

  /**
   * @desc
   * The {@link PointGroup#copy} method returns a copy of `this` point group.
   *
   * @param {LinearAlgebra} lalg
   * An instance of {@link LinearAlgebra}.
   *
   * @return {PointGroup}
   * A copy of `this`.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  copy (lalg) {
    return new PointGroup(this._g.map(gi => lalg.copy(gi)))
  }

  /**
   * @desc
   * The {@link genAsymmetricUnit} method generates a polytope which represents
   * an asymmetric unit in `this` point group.
   *
   * This is an ad hoc implementation and may be improved in future.
   *
   * This method is valid only for the point groups represeted in the Cartesian
   * coordinate system.
   *
   * @param {PolytopeAlgebra} palg
   * An instance of {@link PolytopeAlgebra} of the dimension to which `this`
   * point group conforms.
   *
   * @param {RealNumber} d
   * Half the edge length of a huge hypercube, which approximates whole space.
   * It should not be too large in the case of numerical algebra.
   *
   * @param {Matrix} [hintGeneralPosition]
   * A user-specified general position (optional).
   *
   * @param {number} [max = 512]
   * Maximum number of trials.
   *
   * @return {Polytope|InvalidValue}
   * An polytope representing an asymmetric unit on successful exit, or an
   * instance of the {@link InvalidValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   *
   * @example
   * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
   * import { LinearAlgebra } from '@kkitahara/linear-algebra'
   * import { PolytopeAlgebra, Polytope } from '@kkitahara/polytope-algebra'
   * import { Quasicrystal } from '@kkitahara/qc-tools'
   * let r = new RealAlgebra()
   * let l = new LinearAlgebra(r)
   * let p3d = new PolytopeAlgebra(3, l)
   *
   * let aPar = []
   * let aPerp = [
   *   1, 0, 0,
   *   0, 1, 0,
   *   0, 0, 1]
   * let qc = new Quasicrystal(r, 3, aPar, aPerp)
   *
   * // P m -3
   * let generators = [
   *   qc.genSGSymop([
   *     0, 0, 1,
   *     1, 0, 0,
   *     0, 1, 0], [0, 0, 0]),
   *   qc.genSGSymop([
   *     -1, 0, 0,
   *     0, -1, 0,
   *     0, 0, 1], [0, 0, 0]),
   *   qc.genSGSymop([
   *     -1, 0, 0,
   *     0, 1, 0,
   *     0, 0, -1], [0, 0, 0]),
   *   qc.genSGSymop([
   *     -1, 0, 0,
   *     0, -1, 0,
   *     0, 0, -1], [0, 0, 0])]
   * let sgFract = qc.genSGFractFromGenerators(generators, 24)
   * sgFract.order // 24
   * qc.setSSGFractNoPhason(sgFract)
   *
   * qc.setAtomSite('Xx1', [0, 0, 0])
   *
   * let pg = qc.spgPerpCartnNoPhasonAtomSite('Xx1')
   *
   * let p = pg.genAsymmetricUnit(p3d, 100000)
   * p instanceof Polytope // true
   * let vol = r.mul(p3d.volume(p), 24)
   * r.eq(vol, p3d.volume(p3d.hypercube(100000))) // true
   */
  genAsymmetricUnit (palg, d, hintGeneralPosition, max = 512) {
    const dim = this.dim;
    const symop = this.symop;
    const order = this.order;
    if (!(palg instanceof PolytopeAlgebra) || palg.dim !== this.dim) {
      return new InvalidValue(` (in PointGroup#genAsymmetricUnit)
        \`palg\` must be an instance of \`PolytopeAlgebra\` of the dimensiton
        to which \`this\` point group conforms.`)
    }
    if (!Number.isInteger(max) || max < 1) {
      return new InvalidValue(` (in PointGroup#genAsymmetricUnit)
        \`max\` must be a positive (non-zero) integer.`)
    }
    if (dim === 0) {
      return palg.hypercube()
    }
    const lalg = palg.lalg;
    const ralg = lalg.salg;
    d = ralg.$(d);
    let generalPositions = null;
    if (hintGeneralPosition !== undefined) {
      let v1 = lalg.copy(hintGeneralPosition);
      const positions = [];
      for (let j = 0; j < order; j += 1) {
        const v2 = lalg.mmul(symop[j], v1);
        if (positions.every(v3 => lalg.ne(v2, v3))) {
          positions.push(v2);
        }
      }
      if (positions.length === order) {
        generalPositions = positions;
      }
    }
    if (generalPositions === null) {
      // try (1, 0,..., 0, 0)
      const v = [1, ...new Array(dim - 1).fill(0)];
      let v1 = lalg.$(...v);
      for (let i = 0; i < max; i += 1) {
        const positions = [];
        for (let j = 0; j < order; j += 1) {
          const v2 = lalg.mmul(symop[j], v1);
          if (positions.every(v3 => lalg.ne(v2, v3))) {
            positions.push(v2);
          }
        }
        if (positions.length === order) {
          generalPositions = positions;
          break
        }
        // add (dim, dim - 1,..., 1, 0)
        for (let j = 0; j < dim; j += 1) {
          v[j] += dim - j;
        }
        v1 = lalg.$(...v);
      }
      if (generalPositions === null) {
        return new InvalidValue(` (in PointGroup#genAsymmetricUnit)
          Any general positions are found in \`max\` (${max}) trials.`)
      }
    }
    const asym = palg.hypercube(d);
    generalPositions.slice(1).forEach(posi => {
      const nvec = lalg.sub(posi, generalPositions[0]);
      palg.iaddFacet(asym, palg.facet(nvec, 0, true));
    });
    return asym
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @desc
 * The {@link AtomType} class is a class for atom types.
 *
 * @version 1.0.0
 * @since 1.0.0
 *
 * @example
 * import {
 *   AtomType,
 *   scatCromerMannCoeffs,
 *   scatHiAngFoxCoeffs,
 *   Radiation,
 *   XRayRadiation,
 *   InvalidValue } from '@kkitahara/qc-tools'
 *
 * let cm = scatCromerMannCoeffs['Li1+']
 * let fox = scatHiAngFoxCoeffs['Li']
 * let li1p = new AtomType(cm, fox)
 * li1p._scatCromerMannCoeffs.length // 9
 * li1p._scatCromerMannCoeffs[0] // 0.696800
 * li1p._scatCromerMannCoeffs[1] // 4.62370
 * li1p._scatCromerMannCoeffs[2] // 0.788800
 * li1p._scatCromerMannCoeffs[3] // 1.95570
 * li1p._scatCromerMannCoeffs[4] // 0.341400
 * li1p._scatCromerMannCoeffs[5] // 0.631600
 * li1p._scatCromerMannCoeffs[6] // 0.156300
 * li1p._scatCromerMannCoeffs[7] // 10.0953
 * li1p._scatCromerMannCoeffs[8] // 0.016700
 * li1p._scatHiAngFoxCoeffs.length // 4
 * li1p._scatHiAngFoxCoeffs[0] // 0.89463
 * li1p._scatHiAngFoxCoeffs[1] // -2.43660
 * li1p._scatHiAngFoxCoeffs[2] // 0.232500
 * li1p._scatHiAngFoxCoeffs[3] // -0.0071949
 *
 * let o1m = new AtomType(
 *   scatCromerMannCoeffs['O1-'],
 *   scatHiAngFoxCoeffs['O'])
 * let rad = XRayRadiation.cuKL3
 * rad.wavelength // 1.540562
 * Math.abs(o1m.atomicScatteringFactor(1.5, rad) - 0.994) < 0.012 // true
 * Math.abs(o1m.atomicScatteringFactor(3.5, rad) - 0.196) < 0.196 * 0.03 // true
 * o1m.atomicScatteringFactor(-0.1, rad) instanceof InvalidValue // true
 * o1m.atomicScatteringFactor(6.1, rad) instanceof InvalidValue // true
 *
 * rad = new Radiation()
 * // invalid probe
 * o1m.atomicScatteringFactor(1.5, rad) instanceof InvalidValue // true
 */
class AtomType {
  /**
   * @desc
   * The constructor function of the {@link AtomType} class.
   *
   * @todo add parameters for dispersion, nuclear, electron.
   *
   * @param {number[]} scatCromerMannCoeffs
   * A set of Cromer-Mann coefficients [a1, b1, a2, b2, a3, b3, a4, b4, c] to be
   * set.
   *
   * @param {number[]} scatCoeffsFox
   * A set of Fox coefficients [a0, a1, a2 * 10, a3 * 100] to be set.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (scatCromerMannCoeffs, scatHiAngFoxCoeffs) {
    /**
     * @desc
     * The {@link AtomType#_scatCromerMannCoeffs} is the set of Cromer-Mann
     * coefficients [a1, b1, a2, b2, a3, b3, a4, b4, c] for `this` atom type.
     *
     * Users should not change this property directly.
     *
     * @type {number[]}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._scatCromerMannCoeffs = scatCromerMannCoeffs;
    /**
     * @desc
     * The {@link AtomType#_scatCromerMannCoeffs} is the set of Fox coefficients
     * [a0, a1, a2, a3] or `this` atom type.
     *
     * Users should not change this property directly.
     *
     * @type {number[]}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._scatHiAngFoxCoeffs = scatHiAngFoxCoeffs;
    this._scatHiAngFoxCoeffs[2] /= 10;
    this._scatHiAngFoxCoeffs[3] /= 100;
  }

  /**
   * @desc
   * The {@link AtomType#_atomicScatteringFactor} returns the atomic scattering
   * factor of `this` atom type for the given `stol` and `rad`.
   *
   * @todo dispersion correction, nuclear scattering, electron scattering.
   *
   * @param {number} stol
   * Sin(theta) over lambda = |qParCartn| / 2.
   *
   * @param {Radiation} rad
   * The radiation for which the atomic scattering factor is to be calculated.
   *
   * @return {number|InvalidValue}
   * The value of the atomic scattering factor or an instance of
   * {@link InvalidValue} if the given condition is not supported.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  atomicScatteringFactor (stol, rad) {
    if (rad.probe === 'x-ray') {
      if (stol < 0) {
        return new InvalidValue(` (in AtomType#atomicScatteringFactor)
          A negative value of \`stol\` (${stol}) is given.`)
      } else if (stol <= 2) {
        let f = this._scatCromerMannCoeffs[8];
        const s2 = stol ** 2;
        for (let i = 0; i < 8; i += 2) {
          f += this._scatCromerMannCoeffs[i] *
            Math.exp(-this._scatCromerMannCoeffs[i + 1] * s2);
        }
        return f
      } else if (stol <= 6) {
        const s = stol;
        const lnf =
          this._scatHiAngFoxCoeffs[0] +
          s * (this._scatHiAngFoxCoeffs[1] +
          s * (this._scatHiAngFoxCoeffs[2] +
          s * this._scatHiAngFoxCoeffs[3]));
        return Math.exp(lnf)
      } else {
        return new InvalidValue(` (in AtomType#atomicScatteringFactor)
          An unsuported value of \`stol\` (${stol}) is given.`)
      }
    } else {
      return new InvalidValue(` (in AtomType#atomicScatteringFactor)
        An unsuported probe (${rad.probe}) is given.`)
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @desc
 * The {@link AtomSite} class is a class for atom sites.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class AtomSite {
  /**
   * @desc
   * The constructor function of the {@link AtomSite} class.
   *
   * Users should not use this constructor directly.
   * Use {@link Quasicrystal#genAtomSite} method instead.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (posFract) {
    /**
     * @desc
     * The {@link AtomSite#_posFract} is the position of `this` atom site in a
     * fractional coordinate system.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._posFract = posFract;
  }

  /**
   * @desc
   * The {@link AtomSite#dim} is the dimension to which `this` atom site
   * conforms.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dim () {
    return this._posFract.length
  }

  /**
   * The {@link AtomSite#posFract} is the getter for the
   * {@link AtomSite#_posFract}.
   *
   * Users should not change the contents of the returned value.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get posFract () {
    return this._posFract
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * Copyright 2019 Koichi Kitahara
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @desc
 * The {@link AtomicSurface} class is a class for atomic surfaces of
 * quasicrystals.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class AtomicSurface {
  /**
   * @desc
   * The constructor function of the {@link AtomicSurface} class.
   *
   * @param {string} atomTypeSymbol
   * The atom-type symbol of the atomic surface to be constructed.
   *
   * @param {number} occupancy
   * The occupancy of the atomic surface to be constructed.
   *
   * @param {Matrix} adTensorBeta
   * Atomic displacement tensor beta (represented in a fractional coordinate
   * system.
   *
   * @param {OccupationDomain} occDomainAsym
   * An asymmetric unit of the occupation domain which represent the shape and
   * the position of the atomic surface to be constructed.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (
    atomTypeSymbol,
    occupancy,
    adTensorBeta,
    occDomainAsym,
    displayColour,
    displayOpacity,
    displayRadius
  ) {
    this.atomTypeSymbol = atomTypeSymbol;
    this.occupancy = occupancy;
    this.adTensorBeta = adTensorBeta;
    this.occDomainAsym = occDomainAsym;
    this.displayColour = displayColour;
    this.displayOpacity = displayOpacity;
    this.displayRadius = displayRadius;
  }

  /**
   * @desc
   * The {@link AtomicSurface#dim} is the total dimension (parallel plus
   * perpendicular) to which `this` atomic surface conforms.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dim () {
    return this.adTensorBeta.getDim()[0]
  }

  /**
   * @desc
   * The {@link AtomicSurface#dimPerp} is the dimension of the perpendicular
   * space to which `this` atomic surface conforms.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dimPerp () {
    return this.occDomainAsym.dimPerp
  }

  get atomSiteLabel () {
    return this.occDomainAsym.atomSiteLabel
  }

  occupancyFactor () {
    return this.occupancy
  }

  atomicDisplacementFactor (lnum, qFract) {
    const adTensorBeta = this.adTensorBeta;
    return Math.exp(lnum.dot(lnum.neg(qFract), lnum.mmul(adTensorBeta, qFract)))
  }

  /**
   * @desc
   * The {@link AtomicSurface#geometricalFormFactor} calculates the geometrical
   * form factor of the asymmetric unit of the occupation domain of `this`
   * atomic surface for the given *q* vector `qPerpCartn`.
   *
   * @param {PolytopeAlgebra} pnum
   * An instance of {@link PolytopeAlgebra} to be used. Only the numerical
   * algebra may be used.
   *
   * @param {RealNumber[]} qPerpCartn
   * The perpendicular-space component of a *q* vector represented in the
   * Cartesian coordinate system.
   *
   * @return {ComplexNumber}
   * The calculated geometrical form factor.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  geometricalFormFactor (pnum, qPerpCartn) {
    return this.occDomainAsym.geometricalFormFactor(pnum, qPerpCartn)
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

// caches
const _simplexesInfo = new MultiKeyWeakMap$1();

/**
 * @desc
 * The {@link OccupationDomain} class is a class for occupation domains of
 * quasicrystals.
 *
 * In this package, 'atomic surface' and 'occupation domain' are distinguished
 * although these are usually synonyms. An 'occupation domain' is considered to
 * be an 'atomic surface' minus any implication about chemical properties, e.g.
 * atom type.
 *
 * @version 1.0.0
 * @since 1.0.0
 */
class OccupationDomain {
  /**
   * @desc
   * The constructor function of the {@link OccupationDomain} class.
   *
   * @param {string} atomSiteLabel
   * The atom-site label of the atomic surface to be constructed.
   *
   * @param {Polytope} polytope
   * A polytope which represent the shape of the occupation domain to be
   * constructed.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (atomSiteLabel, polytope) {
    this.atomSiteLabel = atomSiteLabel;
    this.polytope = polytope;
  }

  /**
   * @desc
   * The {@link OccupationDomain#dimPerp} is the dimension of the perpendicular
   * space to which `this` occupation domain conforms.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dimPerp () {
    return this.polytope.dim
  }

  cutBy (palg, another) {
    if (this.atomSiteLabel === another.atomSiteLabel) {
      this.polytope = palg.sub(this.polytope, another.polytope);
    }
  }

  /**
   * @desc
   * The {@link OccupationDomain#simplexesInfo} contains the information about
   * the simplexes which represents the shape of `this` occupation domain.
   *
   * @param {PolytopeAlgebra} palg
   * An instance of {@link PolytopeAlgebra} to be used.
   *
   * @return {Object[]}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  simplexesInfo (palg) {
    const polytope = this.polytope;
    let simplexesInfo = _simplexesInfo.get(palg, polytope);
    if (!simplexesInfo) {
      const dimPerp = polytope.dim;
      const lalg = palg.lalg;
      const ralg = lalg.salg;
      const simplexes = palg.genSimplexes(polytope);
      simplexesInfo = simplexes.map(simplex => {
        const origin = simplex[0];
        const arr = simplex.slice(1).reduce((a, vi) => {
          a.push(...lalg.sub(vi, origin));
          return a
        }, []);
        const avec = lalg.itranspose(lalg.$(...arr).setDim(dimPerp, dimPerp));
        const absDet = ralg.abs(lalg.det(lalg.lup(avec)));
        return {
          origin: lalg.copy(origin),
          avec: avec,
          absDet: absDet }
      });
      _simplexesInfo.set(palg, polytope, simplexesInfo);
    }
    return simplexesInfo
  }

  /**
   * @desc
   * The {@link OccupationDomain#geometricalFormFactor} calculates the
   * geometrical form factor of `this` occupation domain for the given *q*
   * vector `qPerpCartn`.
   *
   * @param {PolytopeAlgebra} pnum
   * An instance of {@link PolytopeAlgebra} to be used. Only the numerical
   * algebra may be used.
   *
   * @param {RealNumber[]} qPerpCartn
   * The perpendicular-space component of a *q* vector represented in the
   * Cartesian coordinate system.
   *
   * @return {ComplexNumber}
   * The calculated geometrical form factor.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  geometricalFormFactor (pnum, qPerpCartn) {
    // numerical only
    const dimPerp = this.dimPerp;
    const lnum = pnum.lalg;
    const rnum = lnum.salg;
    const cnum = new ComplexAlgebra(rnum);
    if (dimPerp === 0) {
      return cnum.$(1)
    }
    const twopi = 2 * Math.PI;
    return this.simplexesInfo(pnum).reduce((g, simplex) => {
      const imPhase = twopi * lnum.dot(qPerpCartn, simplex.origin);
      // oblique coordinate system of the simplex
      const vi = lnum.ismul(lnum.mmul(qPerpCartn, simplex.avec), twopi).slice();
      for (let j = 1; j < dimPerp; j += 1) {
        vi[j - 1] -= vi[j];
      }
      let terms = [];
      terms.push({ polyCoef: [cnum.$(1)], v: 0 });
      for (let j = dimPerp - 1; j >= 0; j -= 1) {
        for (let k = terms.length - 1; k >= 0; k -= 1) {
          terms[k].v += vi[j];
        }
        // integrate
        const termsNew = [];
        termsNew.push({ polyCoef: [cnum.$(0)], v: 0 });
        for (let k = terms.length - 1; k >= 0; k -= 1) {
          const vk = terms[k].v;
          if (rnum.isZero(vk)) {
            let polyCoef = terms[k].polyCoef;
            const polyCoefNew = [cnum.$(0)];
            for (let l = 0, n = polyCoef.length; l < n; l += 1) {
              const coefNew = cnum.div(polyCoef[l], l + 1);
              polyCoefNew[0] = cnum.iadd(polyCoefNew[0], coefNew);
              polyCoefNew.push(cnum.neg(coefNew));
            }
            polyCoef = termsNew[0].polyCoef;
            for (let l = 0, n = polyCoef.length; l < n; l += 1) {
              if (l === polyCoefNew.length) {
                break
              }
              polyCoef[l] = cnum.iadd(polyCoef[l], polyCoefNew[l]);
            }
            for (let l = polyCoef.length; l < polyCoefNew.length; l += 1) {
              polyCoef.push(polyCoefNew[l]);
            }
          } else {
            const polyCoef = terms[k].polyCoef;
            const polyCoefNew = [];
            for (let l = polyCoef.length - 1; l >= 0; l -= 1) {
              polyCoefNew.push(cnum.$(0));
            }
            for (let l = polyCoef.length - 1; l >= 0; l -= 1) {
              // integration by parts
              const coefNew = cnum.div(polyCoef[l], cnum.$(0, vk));
              if (l !== 0) {
                polyCoef[l - 1] =
                    cnum.isub(polyCoef[l - 1], cnum.mul(coefNew, l));
              }
              const rePhFac = Math.cos(vk);
              const imPhFac = Math.sin(vk);
              const phFac = cnum.add(rePhFac, cnum.$(0, imPhFac));
              termsNew[0].polyCoef[0] =
                  cnum.iadd(termsNew[0].polyCoef[0], cnum.mul(phFac, coefNew));
              polyCoefNew[l] = cnum.isub(polyCoefNew[l], coefNew);
            }
            termsNew.push({ polyCoef: polyCoefNew, v: vk });
          }
        }
        terms = termsNew;
      }
      let factor = cnum.$(Math.cos(imPhase), Math.sin(imPhase));
      factor = cnum.imul(factor, simplex.absDet);
      return cnum.iadd(g, cnum.imul(terms.reduce((gis, term) => {
        return cnum.iadd(gis, term.polyCoef[0])
      }, cnum.$(0)), factor))
    }, cnum.$(0))
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

/**
 * @typedef {number|Polynomial} RealNumber
 *
 * @desc
 * A {@link RealNumber} denotes a {@link number} or an instance of
 * {@link Polynomial} depending on the real algebra to be used. See the
 * documents of @kkitahara/real-algebra for more details.
 */

/**
 * @typedef {object} ComplexNumber
 *
 * @desc
 * A {@link ComplexNumber} is an object with `re` and `im` properties. The
 * values of `re` and `im` are {link RealNumber}s. See the documents of
 * @kkitahara/complex-algebra for more details.
 */

/**
 * @desc
 * The {@link Quasicrystal} class is a class for quasicrystals.
 *
 * @version 1.0.0
 * @since 1.0.0
 *
 * @example
 * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
 * import { LinearAlgebra } from '@kkitahara/linear-algebra'
 * import { Quasicrystal, SpaceGroup } from '@kkitahara/qc-tools'
 * let r = new RealAlgebra()
 * let l = new LinearAlgebra(r)
 *
 * // octagonal
 * let aPar = [
 *   1, r.$(1, 2, 2), 0, r.$(-1, 2, 2),
 *   0, r.$(1, 2, 2), 1, r.$(1, 2, 2)]
 * let aPerp = [
 *   1, r.$(-1, 2, 2), 0, r.$(1, 2, 2),
 *   0, r.$(1, 2, 2), -1, r.$(1, 2, 2)]
 * let qc = new Quasicrystal(r, 4, aPar, aPerp)
 * qc.dim // 4
 * qc.dimPar // 2
 * qc.dimPerp // 2
 * qc.aParCartn.getDim()[0] // 2
 * qc.aParCartn.getDim()[1] // 4
 * qc.aPerpCartn.getDim()[0] // 2
 * qc.aPerpCartn.getDim()[1] // 4
 * qc.bParCartn.getDim()[0] // 4
 * qc.bParCartn.getDim()[1] // 2
 * qc.bPerpCartn.getDim()[0] // 4
 * qc.bPerpCartn.getDim()[1] // 2
 *
 * let identity = l.$(
 *   1, 0, 0, 0,
 *   0, 1, 0, 0,
 *   0, 0, 1, 0,
 *   0, 0, 0, 1).setDim(4, 4)
 * l.eq(l.mmul(qc.bCartn, qc.aCartn), identity) // true
 *
 * l.eq(qc.aParCartn, aPar) // true
 * l.eq(qc.aPerpCartn, aPerp) // true
 * l.eq(qc._originFract, [0, 0, 0, 0]) // true
 * l.eq(qc._phasonMatrix, [0, 0, 0, 0]) // true
 *
 * r.eq(qc.hyperVolume, 4) // true
 *
 * // P 8 m m
 * let notrans = [0, 0, 0, 0]
 * let generators = [
 *   qc.genSGSymop([
 *     0, 0, 0, -1,
 *     1, 0, 0, 0,
 *     0, 1, 0, 0,
 *     0, 0, 1, 0], notrans),
 *   qc.genSGSymop([
 *     1, 0, 0, 0,
 *     0, 0, 0, -1,
 *     0, 0, -1, 0,
 *     0, -1, 0, 0], notrans)]
 * let ssg = qc.genSGFractFromGenerators(generators, 16)
 * ssg instanceof SpaceGroup // true
 * ssg.order // 16
 * ssg.dim // 4
 *
 * @example
 * import { RealAlgebra } from '@kkitahara/real-algebra'
 * import { LinearAlgebra } from '@kkitahara/linear-algebra'
 * import { Quasicrystal, SpaceGroup } from '@kkitahara/qc-tools'
 * let r = new RealAlgebra(1e-10)
 * let l = new LinearAlgebra(r)
 *
 * // face-centred icosahedral (primitive cell)
 * let a = r.$(1)
 * let t = r.iadd(r.$(1, 2), r.$(1, 2, 5))
 * let t2 = r.mul(t, t)
 * let tinv = r.div(1, t)
 * let twot = r.mul(2, t)
 * let aPar = l.smul([
 *   t2, 1, t, 0, twot, 0,
 *   t, t2, 1, 0, 0, twot,
 *   1, t, t2, twot, 0, 0], a)
 * let aPerp = l.smul([
 *   tinv, t, -1, 0, -2, 0,
 *   -1, tinv, t, 0, 0, -2,
 *   t, -1, tinv, -2, 0, 0], a)
 * let qc = new Quasicrystal(r, 6, aPar, aPerp)
 * qc instanceof Quasicrystal // true
 * qc.dim // 6
 * qc.dimPar // 3
 * qc.dimPerp // 3
 *
 * let identity = l.$(
 *   1, 0, 0, 0, 0, 0,
 *   0, 1, 0, 0, 0, 0,
 *   0, 0, 1, 0, 0, 0,
 *   0, 0, 0, 1, 0, 0,
 *   0, 0, 0, 0, 1, 0,
 *   0, 0, 0, 0, 0, 1).setDim(6, 6)
 *
 * l.eq(l.mmul(qc.bCartn, qc.aCartn), identity) // true
 *
 * // Fm-3-5
 * let generators = [
 *   qc.genSGSymop([
 *     1, 0, 0, 0, 1, 1,
 *     -1, 0, 0, 0, 0, 0,
 *     0, 1, 0, 1, -1, 0,
 *     1, 0, 1, 0, 1, 0,
 *     0, 0, 0, -1, 0, 0,
 *     0, 0, 0, 0, -1, 0], [0, 0, 0, 0, 0, 0]),
 *   qc.genSGSymop([
 *     0, 1, 0, 0, 0, 0,
 *     0, 0, 1, 0, 0, 0,
 *     1, 0, 0, 0, 0, 0,
 *     0, 0, 0, 0, 1, 0,
 *     0, 0, 0, 0, 0, 1,
 *     0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0]),
 *   qc.genSGSymop([
 *     -1, 0, 0, 0, 0, 0,
 *     0, -1, 0, 0, 0, 0,
 *     0, 0, -1, 0, 0, 0,
 *     0, 0, 0, -1, 0, 0,
 *     0, 0, 0, 0, -1, 0,
 *     0, 0, 0, 0, 0, -1], [0, 0, 0, 0, 0, 0], l)]
 * let sg = qc.genSGFractFromGenerators(generators)
 * sg instanceof SpaceGroup // true
 * sg.order // 120
 * sg.dim // 6
 * qc.setSSGFractNoPhason(sg)
 *
 * // cubic phason strain
 * qc.setPhasonMatrix([
 *   1, 0, 0,
 *   0, 1, 0,
 *   0, 0, 1])
 *
 * l.eq(l.mmul(qc.bCartn, qc.aCartn), identity) // true
 *
 * let ssgSymopId = qc.ssgSymopId
 * ssgSymopId.length // 24
 *
 * // to cover 'cached` branch
 * ssgSymopId = qc.ssgSymopId
 * ssgSymopId.length // 24
 *
 * let ssgRightCosetsSymopId = qc.ssgRightCosetsSymopId
 * ssgRightCosetsSymopId.length // 5
 *
 * // to cover 'cached` branch
 * ssgRightCosetsSymopId = qc.ssgRightCosetsSymopId
 * ssgRightCosetsSymopId.length // 5
 *
 * // rhombohedral phason strain
 * qc.setPhasonMatrix([
 *   0, 0, r.$(1, 2),
 *   r.$(1, 2), 0, 0,
 *   0, r.$(1, 2), 0])
 *
 * ssgSymopId = qc.ssgSymopId
 * ssgSymopId.length // 6
 *
 * // to cover 'cached` branch
 * ssgSymopId = qc.ssgSymopId
 * ssgSymopId.length // 6
 *
 * ssgRightCosetsSymopId = qc.ssgRightCosetsSymopId
 * ssgRightCosetsSymopId.length // 20
 *
 * // to cover 'cached` branch
 * ssgRightCosetsSymopId = qc.ssgRightCosetsSymopId
 * ssgRightCosetsSymopId.length // 20
 *
 * @example
 * import { ExactRealAlgebra as RealAlgebra } from '@kkitahara/real-algebra'
 * import { LinearAlgebra } from '@kkitahara/linear-algebra'
 * import { Quasicrystal } from '@kkitahara/qc-tools'
 * let r = new RealAlgebra()
 * let l = new LinearAlgebra(r)
 * let half = r.$(1, 2)
 *
 * // cubic
 * let qc = new Quasicrystal(r, 3,
 *   [1, 0, 0, 0, 1, 0, 0, 0, 1], [])
 * qc.dim // 3
 * qc.dimPar // 3
 * qc.dimPerp // 0
 *
 * // I 2 1 3
 * let generators = [
 *   qc.genSGSymop([1, 0, 0, 0, 1, 0, 0, 0, 1], [half, half, half]),
 *   qc.genSGSymop([0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0]),
 *   qc.genSGSymop([-1, 0, 0, 0, -1, 0, 0, 0, 1], [half, 0, half]),
 *   qc.genSGSymop([-1, 0, 0, 0, 1, 0, 0, 0, -1], [0, half, half])]
 * let sg = qc.genSGFractFromGenerators(generators, 24)
 * sg.order // 24
 *
 * let sg2 = sg.copy(l)
 * sg2 !== sg // true
 * sg2.order === sg.order // true
 * sg2.dim === sg.dim // true
 * sg2.symop[0] !== sg.symop[0] // true
 * l.eq(sg2.symop[0].rot, sg.symop[0].rot) // true
 *
 * qc.setSSGFractNoPhason(sg)
 *
 * let transSymopIds = qc.ssgNoPhasonTransSymopId
 * transSymopIds.length // 8
 *
 * // to cover 'cached' branch
 * transSymopIds = qc.ssgNoPhasonTransSymopId
 */
class Quasicrystal {
  /**
   * @desc
   * The constructor function of the {@link Quasicrystal} class.
   *
   * @param {RealAlgebra} ralg
   * An instance of {@link RealAlgebra} to be used to manipulate
   * {@link RealNumber}s.
   *
   * @param {number} dim
   * The total dimension (parallel plus perpendicular).
   *
   * @param {RealNumber[]} aParCartn
   * Parallel-space components of lattice translation vectors (column vectors)
   * of the direct lattice represented in the Cartesian coordinate system (in
   * angstroms). The length of `aParCartn` is considered to be `dimPar * dim`,
   * and the elements are considered to be stored in row-major order.
   *
   * @param {RealNumber[]} aPerpCartn
   * Perpendicular-space components of lattice translation vectors (column
   * vectors) of the direct lattice represented in the Cartesian coordinate
   * system (in angstroms). The length of `aPerpCartn` is considered to be
   * `dimPerp * dim`, and the elements are considered to be stored in
   * row-major order.
   *
   * @param {number} [eps = DEFAULT_EPS]
   * A tolerance for equality in numerical algebra.
   *
   * @return {Quasicrystal|Error}
   * An instance of {@link Quasicrystal} on successful exit, or an
   * {@link InvalidValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  constructor (ralg, dim, aParCartn, aPerpCartn, eps = DEFAULT_EPS) {
    if (!(ralg instanceof RealAlgebra)) {
      return new InvalidValue(` (in Quasicrystal.constructor)
        \`ralg\` must be an instance of \`RealAlgebra\`.`)
    }
    const lalg = new LinearAlgebra(ralg);
    if (!Number.isInteger(dim) || dim < 1) {
      return new InvalidValue(` (in Quasicrystal.constructor)
        \`dim\` must be a positive (non-zero) integer.`)
    }
    if (!Array.isArray(aParCartn)) {
      return new InvalidValue(` (in Quasicrystal.constructor)
        \`aParCartn\` must be an array.`)
    }
    aParCartn = lalg.copy(aParCartn).setDim(0, dim);
    const dimPar = aParCartn.getDim()[0];
    aParCartn.setDim(dimPar, dim);
    if (!Array.isArray(aPerpCartn)) {
      return new InvalidValue(` (in Quasicrystal.constructor)
        \`aPerpCartn\` must be an array.`)
    }
    aPerpCartn = lalg.copy(aPerpCartn).setDim(0, dim);
    const dimPerp = aPerpCartn.getDim()[0];
    aPerpCartn.setDim(dimPerp, dim);
    if (dim !== dimPar + dimPerp) {
      return new InvalidValue(` (in Quasicrystal.constructor)
        \`dim\` must be equal to \`dimPar + \`dimPerp\`.`)
    }
    const palg = new PolytopeAlgebra(dimPerp, lalg);
    const aCartn = lalg.$(...aParCartn, ...aPerpCartn).setDim(dim, dim);
    const dimp1 = dim + 1;
    let m = [...new Array(dim * dim)].map((x, i) => i % dimp1 === 0 ? 1 : 0);
    const aLU = lalg.lup(aCartn);
    const bCartn = lalg.isolve(aLU, lalg.$(...m).setDim(dim, dim));
    m = lalg.transpose(bCartn);
    const bParCartn = lalg.itranspose(
      lalg.$(...m.slice(0, aParCartn.length)).setDim(dimPar, dim));
    const bPerpCartn = lalg.itranspose(
      lalg.$(...m.slice(aParCartn.length)).setDim(dimPerp, dim));
    const hyperVolume = ralg.abs(lalg.det(aLU));
    const rnum = new RealAlgebra(eps);
    const cnum = new ComplexAlgebra(rnum);
    const lnum = new LinearAlgebra(rnum);
    const pnum = new PolytopeAlgebra(dimPerp, lnum);
    /**
     * @desc
     * The {@link Quasicrystal#_ralg} stores the instance of {@link RealAlgebra}
     * for manipulating {@link RealNumber}s in `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {RealAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._ralg = ralg;
    /**
     * @desc
     * The {@link Quasicrystal#_lalg} stores the instance of
     * {@link LinearAlgebra} for manipulating vectors and matrices in `this`
     * quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {LinearAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._lalg = lalg;
    /**
     * @desc
     * The {@link Quasicrystal#_palg} stores the instance of
     * {@link PolytopeAlgebra} for manipulating atomic surfaces (as polytopes)
     * in `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {PolytopeAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._palg = palg;
    /**
     * @desc
     * The {@link Quasicrystal#_rnum} stores the instance of {@link RealAlgebra}
     * for manipulating {@link RealNumber}s numerically in `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {RealAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._rnum = rnum;
    /**
     * @desc
     * The {@link Quasicrystal#_cnum} stores the instance of
     * {@link ComplexAlgebra} for manipulating {@link ComplexNumber}s
     * numerically in `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {RealAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._cnum = cnum;
    /**
    /**
     * @desc
     * The {@link Quasicrystal#_lnum} stores the instance of
     * {@link LinearAlgebra} for manipulating vectors and matrices numerically
     * in `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {LinearAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._lnum = lnum;
    /**
     * @desc
     * The {@link Quasicrystal#_pnum} stores the instance of
     * {@link PolytopeAlgebra} for manipulating atomic surfaces (as polytopes)
     * numerically in `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {PolytopeAlgebra}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._pnum = pnum;

    /**
     * @desc
     * The {@link Quasicrystal#_dimPar} is the dimension of the parallel space
     * of `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {number}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._dimPar = dimPar;
    /**
     * @desc
     * The {@link Quasicrystal#_dimPerp} is the dimension of the perpendicular
     * space of `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {number}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._dimPerp = dimPerp;
    /**
     * @desc
     * The {@link Quasicrystal#_aParCartn} is the parallel-space components of
     * the lattice translation vectors (column vectors) of the direct lattice of
     * `this` quasicrystal represented in the Cartesian coordinate system (in
     * angstroms). Its dimension is `this.dimPar * this.dim`. The elements are
     * stored in row-major order.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._aParCartn = aParCartn;
    /**
     * @desc
     * The {@link Quasicrystal#_aPerpCartnNoPhason} is the perpendicular-space
     * components of the lattice translation vectors (column vectors) of the
     * direct lattice of `this` quasicrystal represented in the Cartesian
     * coordinate system (in angstroms). Its dimension is `this.dimPerp *
     * this.dim`. The elements are stored in row-major order.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._aPerpCartnNoPhason = aPerpCartn;
    /**
     * @desc
     * The {@link Quasicrystal#_bParCartnNoPhason} is the parallel-space
     * components of the lattice translation vectors (row vectors) of the
     * reciprocal lattice of `this` quasicrystal represented in the Cartesian
     * coordinate system (in reciprocal angstroms). Its dimension is
     * `this.dim * this.dimPar`. The elements are stored in row-major order.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._bParCartnNoPhason = bParCartn;
    /**
     * @desc
     * The {@link Quasicrystal#_bPerpCartn} is the perpendicular-space
     * components of the lattice translation vectors (row vectors) of the
     * reciprocal lattice of `this` quasicrystal represented in the Cartesian
     * coordinate system (in reciprocal angstroms). Its dimension is `this.dim *
     * this.dimPerp`. The elements are stored in row-major order.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._bPerpCartn = bPerpCartn;
    /**
     * @desc
     * The {@link Quasicrystal#_hyperVolume} is the hyper volume of a unit cell
     * of `this` quasicrystal in angstroms to the `this.dim`-th power.
     *
     * Users should not change this property directly.
     *
     * @type {RealNumber}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._hyperVolume = hyperVolume;
    /**
     * @desc
     * The {@link Quasicrystal#_hyperVolumeNumerical} is the numeical value of
     * the hyper volume of a unit cell of `this` quasicrystal in angstroms to
     * the `this.dim`-th power.
     *
     * Users should not change this property directly.
     *
     * @type {number}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._hyperVolumeNumerical = rnum.copy(hyperVolume);
    /**
     * @desc
     * The {@link Quasicrystal#_originFract} is the origin of the phisical
     * space represented in the fractional coordinate of `this` quasicrystal.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._originFract = lalg.$(...new Array(dim).fill(0));
    /**
     * @desc
     * The {@link Quasicrystal#_phasonMatrix} is the linear phason strain matrix
     * applied to `this` quasicrystal. A phason matrix (`T`) is applied to a
     * lattice translation vector (`a`) as
     * ```
     *  / a_par  \             / 1 0 \     / a_par  \
     * |          |         = |       | * |          |
     *  \ a_perp /_strained    \ T 1 /     \ a_perp /
     * ```
     * The elements are stored in row-major order.
     *
     * Users should not change this property directly.
     *
     * @type {Matrix}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._phasonMatrix = lalg.$(...new Array(dimPerp * dimPar).fill(0))
      .setDim(dimPerp, dimPar);
    /**
     * @desc
     * The {@link Quasicrystal#_ssgFractNoPhason} is the super space group of
     * `this` quasicrystal under no phason strain represented in the
     * fractional coordinate system.
     *
     * Users should not change this property directly.
     *
     * @type {SpaceGroup}
     *
     * @version 1.0.0
     * @since 1.0.0
     */
    this._ssgFractNoPhason =
      new SpaceGroup([SpaceGroupSymop.identity(lalg, dim)]);
    this._atomType = Object.create(null);
    this._atomSite = Object.create(null);
    this._atomicSurface = Object.create(null);
    // caches
    this._aPerpCartn = new WeakMap();
    this._bParCartn = new WeakMap();
    this._ssgFractNoPhasonNumerical = new WeakMap();
    this._ssgParCartnNoPhason = new WeakMap();
    this._ssgPerpCartnNoPhason = new WeakMap();
    this._ssgNoPhasonTransSymopId = new WeakMap();
    this._ssgSymopId = new MultiKeyWeakMap$1();
    this._ssgFract = new MultiKeyWeakMap$1();
    this._ssgParCartn = new MultiKeyWeakMap$1();
    this._ssgPerpCartn = new MultiKeyWeakMap$1();
    this._ssgRightCosetsSymopId = new MultiKeyWeakMap$1();
    this._ssgNoPhasonSymAtomSite = new MultiKeyWeakMap$1();
    this._ssgSymAtomSite = new MultiKeyWeakMap$1();
  }

  toJSON () {
    const obj = {
      aux: this.aux || {} // ad hoc
    };
    obj.reviver = '@kkitahara/qc-tools:Quasicrystal';
    obj.version = 'experimental';
    obj.dim = this.dim;
    obj.aParCartn = this._aParCartn;
    obj.aPerpCartnNoPhason = this._aPerpCartnNoPhason;
    obj.originFract = this._originFract;
    obj.phasonMatrix = this._phasonMatrix;
    obj.ssgFractNoPhason = this._ssgFractNoPhason.symop.map(
      g => [g.rot.slice(), g.trans.slice()]);
    obj.atomType = Object.entries(this._atomType).map(([symbol, atomType]) => {
      const scatHiAngFoxCoeffs = atomType._scatHiAngFoxCoeffs;
      scatHiAngFoxCoeffs[2] *= 10;
      scatHiAngFoxCoeffs[3] *= 100;
      return {
        symbol: symbol,
        scatCromerMannCoeffs: atomType._scatCromerMannCoeffs,
        scatHiAngFoxCoeffs: scatHiAngFoxCoeffs }
    });
    obj.atomSite = Object.entries(this._atomSite).map(([label, atomSite]) => {
      return {
        label: label,
        posFract: atomSite.posFract }
    });
    obj.atomicSurface = Object.entries(this._atomicSurface).map(
      ([label, atomicSurface]) => {
        const occDomainAsym = {
          atomSiteLabel: atomicSurface.occDomainAsym.atomSiteLabel,
          polytopeJSON: JSON.stringify(atomicSurface.occDomainAsym.polytope) };
        return {
          label: label,
          atomTypeSymbol: atomicSurface.atomTypeSymbol,
          occupancy: atomicSurface.occupancy,
          adTensorBeta: atomicSurface.adTensorBeta,
          occDomainAsym: occDomainAsym,
          displayColour: atomicSurface.displayColour,
          displayOpacity: atomicSurface.displayOpacity,
          displayRadius: atomicSurface.displayRadius
        }
      });
    return obj
  }

  static reviver (ralg, eps = DEFAULT_EPS) {
    const lalg = new LinearAlgebra(ralg);
    return (key, value) => {
      if (value !== null && typeof value === 'object' &&
          value.reviver === '@kkitahara/qc-tools:Quasicrystal') {
        if (value.version === 'experimental') {
          const dim = value.dim;
          const aParCartn = value.aParCartn;
          const aPerpCartn = value.aPerpCartnNoPhason;
          const qc = new Quasicrystal(ralg, dim, aParCartn, aPerpCartn, eps);
          qc.aux = value.aux || {}; // ad hoc
          qc._originFract = value.originFract;
          qc.setPhasonMatrix(value.phasonMatrix);
          qc.setSSGFractNoPhason(qc.genSpaceGroup(...value.ssgFractNoPhason.map(
            ([rot, trans]) => qc.genSGSymop(rot, trans))));
          value.atomType.forEach(({
            symbol,
            scatCromerMannCoeffs,
            scatHiAngFoxCoeffs
          }) => {
            qc.setAtomType(symbol,
              new AtomType(scatCromerMannCoeffs, scatHiAngFoxCoeffs));
          });
          value.atomSite.forEach(({
            label,
            posFract
          }) => qc.setAtomSite(label, posFract));
          const palg = qc._palg;
          value.atomicSurface.forEach(({
            label,
            atomTypeSymbol,
            occupancy,
            adTensorBeta,
            occDomainAsym,
            displayColour,
            displayOpacity,
            displayRadius
          }) => {
            const odAsym = new OccupationDomain(
              occDomainAsym.atomSiteLabel,
              JSON.parse(occDomainAsym.polytopeJSON, palg.reviver));
            qc.setAtomicSurface(label, new AtomicSurface(atomTypeSymbol,
              occupancy, adTensorBeta, odAsym, displayColour, displayOpacity,
              displayRadius));
          });
          return qc
        } else {
          throw Error('invalid version.')
        }
      } else {
        return lalg.reviver(key, value)
      }
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#dim} is the total dimension (parallel plus
   * perpendicular) of `this` quasicrystal.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dim () {
    return this._dimPar + this._dimPerp
  }

  /**
   * @desc
   * The {@link Quasicrystal#dimPar} is the dimension of the parallel space of
   * `this` quasicrystal.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dimPar () {
    return this._dimPar
  }

  /**
   * @desc
   * The {@link Quasicrystal#dimPerp} is the dimension of the perpendicular
   * space of `this` quasicrystal.
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get dimPerp () {
    return this._dimPerp
  }

  /**
   * @desc
   * The {@link Quasicrystal#aParCartn} is the parallel-space components of the
   * lattice translation vectors (column vectors) of the direct lattice of
   * `this` quasicrystal represented in the Cartesian coordinate system (in
   * angstroms). Its dimension is `this.dimPar * this.dim`. The elements are
   * stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get aParCartn () {
    return this._lalg.copy(this._aParCartn)
  }

  /**
   * @desc
   * The {@link Quasicrystal#aPerpCartnNoPhason} is the perpendicular-space
   * components of the lattice translation vectors (column vectors) of the
   * direct lattice of `this` quasicrystal under no phason strain represented
   * in the Cartesian coordinate system (in angstroms). Its dimension is
   * `this.dimPerp * this.dim`. The elements are stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get aPerpCartnNoPhason () {
    return this._lalg.copy(this._aPerpCartnNoPhason)
  }

  /**
   * @desc
   * The {@link Quasicrystal#aPerpCartn} is the perpendicular-space components
   * of the lattice translation vectors (column vectors) of the direct lattice
   * of `this` quasicrystal under the current phason strain represented in the
   * Cartesian coordinate system (in angstroms). Its dimension is
   * `this.dimPerp * this.dim`. The elements are stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get aPerpCartn () {
    const phasonMatrix = this._phasonMatrix;
    const lalg = this._lalg;
    let aPerpCartn = this._aPerpCartn.get(phasonMatrix);
    if (!aPerpCartn) {
      aPerpCartn = lalg.iadd(lalg.mmul(phasonMatrix, this._aParCartn),
        this._aPerpCartnNoPhason);
      this._aPerpCartn.set(phasonMatrix, aPerpCartn);
    }
    return lalg.copy(aPerpCartn)
  }

  /**
   * @desc
   * The {@link Quasicrystal#aCartnNoPhason} is the lattice translation vectors
   * (column vectors) of the direct lattice of `this` quasicrystal under no
   * phason strain represented in the Cartesian coordinate system (in
   * angstroms). Its dimension is `this.dim * this.dim`. The elements are stored
   * in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get aCartnNoPhason () {
    const dim = this.dim;
    return this._lalg.$(...this.aParCartn, ...this.aPerpCartnNoPhason)
      .setDim(dim, dim)
  }

  /**
   * @desc
   * The {@link Quasicrystal#aCartn} is the lattice translation vectors (column
   * vectors) of the direct lattice of `this` quasicrystal under the current
   * phason strain represented in the Cartesian coordinate system (in
   * angstroms). Its dimension is `this.dim * this.dim`. The elements are stored
   * in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get aCartn () {
    const dim = this.dim;
    return this._lalg.$(...this.aParCartn, ...this.aPerpCartn).setDim(dim, dim)
  }

  /**
   * @desc
   * The {@link Quasicrystal#bParCartnNoPhason} is the parallel-space components
   * of the lattice translation vectors (row vectors) of the reciprocal lattice
   * of `this` quasicrystal under no phason strain represented in the Cartesian
   * coordinate system (in reciprocal angstroms). Its dimension is `this.dim *
   * this.dimPar`. The elements are stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get bParCartnNoPhason () {
    return this._lalg.copy(this._bParCartnNoPhason)
  }

  /**
   * @desc
   * The {@link Quasicrystal#bParCartn} is the parallel-space components of the
   * lattice translation vectors (row vectors) of the reciprocal lattice of
   * `this` quasicrystal under the current phason strain represented in the
   * Cartesian coordinate system (in reciprocal angstroms). Its dimension is
   * `this.dim * this.dimPar`. The elements are stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get bParCartn () {
    const phasonMatrix = this._phasonMatrix;
    const lalg = this._lalg;
    let bParCartn = this._bParCartn.get(phasonMatrix);
    if (!bParCartn) {
      bParCartn = lalg.sub(this._bParCartnNoPhason, lalg.mmul(this._bPerpCartn,
        phasonMatrix));
      this._bParCartn.set(phasonMatrix, bParCartn);
    }
    return lalg.copy(bParCartn)
  }

  /**
   * @desc
   * The {@link Quasicrystal#bPerpCartn} is the perpendicular-space components
   * of the lattice translation vectors (row vectors) of the direct lattice of
   * `this` quasicrystal represented in the Cartesian coordinate system (in
   * angstroms). Its dimension is `this.dimPar * this.dim`. The elements are
   * stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get bPerpCartn () {
    return this._lalg.copy(this._bPerpCartn)
  }

  /**
   * @desc
   * The {@link Quasicrystal#bCartnNoPhason} is the lattice translation vectors
   * (row vectors) of the reciprocal lattice of `this` quasicrystal under no
   * phason strain represented in the Cartesian coordinate system (in reciprocal
   * angstroms). Its dimension is `this.dim * this.dimPar`. The elements are
   * stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get bCartnNoPhason () {
    const lalg = this._lalg;
    const dim = this.dim;
    return lalg.itranspose(lalg.$(...lalg.itranspose(this.bParCartnNoPhason),
      ...lalg.itranspose(this.bPerpCartn)).setDim(dim, dim))
  }

  /**
   * @desc
   * The {@link Quasicrystal#bCartn} is the lattice translation vectors (row
   * vectors) of the reciprocal lattice of `this` quasicrystal under the current
   * phason strain represented in the Cartesian coordinate system (in reciprocal
   * angstroms). Its dimension is `this.dim * this.dimPar`. The elements are
   * stored in row-major order.
   *
   * @type {Matrix}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get bCartn () {
    const lalg = this._lalg;
    const dim = this.dim;
    return lalg.itranspose(lalg.$(...lalg.itranspose(this.bParCartn),
      ...lalg.itranspose(this.bPerpCartn)).setDim(dim, dim))
  }

  /**
   * @desc
   * The {@link Quasicrystal#hyperVolume} is the getter for the
   * {@link Quasicrystal#_hyperVolume}
   *
   * @type {RealNumber}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get hyperVolume () {
    const ralg = this._ralg;
    return ralg.copy(this._hyperVolume)
  }

  /**
   * @desc
   * The {@link Quasicrystal#hyperVolumeNumerical} is the getter for the
   * {@link Quasicrystal#_hyperVolumeNumerical}
   *
   * @type {number}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get hyperVolumeNumerical () {
    return this._hyperVolumeNumerical
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgFractNoPhason} is the getter for the super space
   * group of `this` quasicrystal under no phason strain represented in the
   * fractional coordinate system of `this` quasicrystal.
   *
   * @type {SpaceGroup}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgFractNoPhason () {
    return this._ssgFractNoPhason.copy(this._lalg)
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgFractNoPhasonNumerical} is the numerical version
   * of the {@link Quasicrystal#ssgFractNoPhason}.
   *
   * @type {SpaceGroup}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgFractNoPhasonNumerical () {
    const lnum = this._lnum;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    let ssgFractNoPhasonNumerical =
      this._ssgFractNoPhasonNumerical.get(ssgFractNoPhason);
    if (!ssgFractNoPhasonNumerical) {
      ssgFractNoPhasonNumerical = ssgFractNoPhason.copy(lnum);
      this._ssgFractNoPhasonNumerical.set(ssgFractNoPhason,
        ssgFractNoPhasonNumerical);
    }
    return ssgFractNoPhasonNumerical.copy(lnum)
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgParCartnNoPhason} is the super space group of
   * `this` quasicrystal projected onto the parallel space under the no phason
   * strain represented in the Cartesian coordinate system.
   *
   * @type {SpaceGroup}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgParCartnNoPhason () {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    let ssgParCartnNoPhason = this._ssgParCartnNoPhason.get(ssgFractNoPhason);
    if (!ssgParCartnNoPhason) {
      const aParCartn = this.aParCartn;
      const bParCartnNoPhason = this.bParCartnNoPhason;
      const symop = ssgFractNoPhason.symop.map(symopi => {
        const rot = lalg.mmul(aParCartn, lalg.mmul(symopi.rot,
          bParCartnNoPhason));
        const trans = lalg.mmul(aParCartn, symopi.trans);
        return new SpaceGroupSymop(rot, trans)
      });
      ssgParCartnNoPhason = new SpaceGroup(symop);
      this._ssgParCartnNoPhason.set(ssgFractNoPhason, ssgParCartnNoPhason);
    }
    return ssgParCartnNoPhason.copy(lalg)
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgPerpCartnNoPhason} is the super space group of
   * `this` quasicrystal projected onto the perpendicular space under the no
   * phason strain represented in the Cartesian coordinate system.
   *
   * @type {SpaceGroup}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgPerpCartnNoPhason () {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    let ssgPerpCartnNoPhason = this._ssgPerpCartnNoPhason.get(ssgFractNoPhason);
    if (!ssgPerpCartnNoPhason) {
      const aPerpCartnNoPhason = this.aPerpCartnNoPhason;
      const bPerpCartn = this.bPerpCartn;
      const symop = ssgFractNoPhason.symop.map(symopi => {
        const rot = lalg.mmul(aPerpCartnNoPhason, lalg.mmul(symopi.rot,
          bPerpCartn));
        const trans = lalg.mmul(aPerpCartnNoPhason, symopi.trans);
        return new SpaceGroupSymop(rot, trans)
      });
      ssgPerpCartnNoPhason = new SpaceGroup(symop);
      this._ssgPerpCartnNoPhason.set(ssgFractNoPhason, ssgPerpCartnNoPhason);
    }
    return ssgPerpCartnNoPhason.copy(lalg)
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgNoPhasonTransSymopId} is an array containing
   * arrays containing indices of super-space-group symmetry operations. Each
   * array contains the indices (in the super space group) of the operations of
   * which translation vector is equivalent to each other.
   *
   * @type {Array}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgNoPhasonTransSymopId () {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    let ssgNoPhasonTransSymopId =
      this._ssgNoPhasonTransSymopId.get(ssgFractNoPhason);
    if (!ssgNoPhasonTransSymopId) {
      ssgNoPhasonTransSymopId = ssgFractNoPhason.genStar(null,
        (x, gi) => gi.trans,
        (t1, t2) => lalg.isInteger(lalg.sub(t1, t2))).starSymopIds;
      this._ssgNoPhasonTransSymopId.set(ssgFractNoPhason,
        ssgNoPhasonTransSymopId);
    }
    return ssgNoPhasonTransSymopId.map(gIds => gIds.slice())
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgSymopId} is an array containing the indices (in
   * the super space group under no phason strain) of the super-space-group
   * symmetry operations of `this` quasicrystal under the current phason strain.
   *
   * @type {Array}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgSymopId () {
    const ssgFractNoPhason = this._ssgFractNoPhason;
    const phasonMatrix = this._phasonMatrix;
    let ssgSymopId = this._ssgSymopId.get([ssgFractNoPhason, phasonMatrix]);
    if (!ssgSymopId) {
      ssgSymopId = ssgFractNoPhason.symop
        .map((gi, i) => [gi, i])
        .filter(([gi]) => this.isSSGSymopFract(gi))
        .map(([, i]) => i);
      this._ssgSymopId.set([ssgFractNoPhason, phasonMatrix], ssgSymopId);
    }
    return ssgSymopId.slice()
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgRightConsetsSymopId} is an array containing
   * arrays containing indices of super-space-group symmetry operations. Each
   * array contains the indices (in the super space group under no phason
   * strain) of the super-space-group symmetry operations in a right coset of
   * the super space group under the current phason strain. The first array
   * contains the indices of the operations in the super space group under the
   * current phason strain, i.e. the right coset with respect to the identity.
   *
   * @type {Array}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgRightCosetsSymopId () {
    const ssgFractNoPhason = this._ssgFractNoPhason;
    const phasonMatrix = this._phasonMatrix;
    let ssgRightCosetsSymopId =
      this._ssgRightCosetsSymopId.get([ssgFractNoPhason, phasonMatrix]);
    if (!ssgRightCosetsSymopId) {
      const lalg = this._lalg;
      const ssgSymopId = this.ssgSymopId;
      const ssgFractNoPhasonSymop = ssgFractNoPhason.symop;
      const rcSymopId = [[]];
      const rc = [ssgSymopId.map(id => ssgFractNoPhasonSymop[id])];
      ssgFractNoPhasonSymop.forEach((gi, i) => {
        let gj = ssgFractNoPhasonSymop[ssgSymopId[0]];
        let rot = lalg.mmul(gj.rot, gi.rot);
        let trans = lalg.iadd(lalg.mmul(gj.rot, gi.trans), gj.trans);
        if (rc.every((rck, k) => {
          if (rcSymopId[k].length !== rck.length && rck.some(gl =>
            lalg.eq(gl.rot, rot) && lalg.isInteger(lalg.sub(gl.trans, trans))
          )) {
            rcSymopId[k].push(i);
            return false
          }
          return true
        })) {
          rcSymopId.push([i]);
          rc.push([
            new SpaceGroupSymop(rot, trans),
            ...ssgSymopId.slice(1).map(id => {
              gj = ssgFractNoPhasonSymop[id];
              rot = lalg.mmul(gj.rot, gi.rot);
              trans = lalg.iadd(lalg.mmul(gj.rot, gi.trans), gj.trans);
              return new SpaceGroupSymop(rot, trans)
            })
          ]);
        }
      });
      ssgRightCosetsSymopId = rcSymopId;
      this._ssgRightCosetsSymopId.set(
        [ssgFractNoPhason, phasonMatrix], ssgRightCosetsSymopId);
    }
    return ssgRightCosetsSymopId.map(
      ssgRCSymopId => ssgRCSymopId.slice())
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgFract} is the the super space group of `this`
   * quasicrystal represented in the fractional coordinate system under the
   * current phason strain.
   *
   * Order of the operations conforms to the {@link Quasicrystal#ssgSymopId}.
   *
   * @type {SpaceGroup}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgFract () {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    const phasonMatrix = this._phasonMatrix;
    let ssgFract = this._ssgFract.get([ssgFractNoPhason, phasonMatrix]);
    if (!ssgFract) {
      const ssgFractNoPhasonSymop = ssgFractNoPhason.symop;
      ssgFract = new SpaceGroup(this.ssgSymopId.map(
        id => ssgFractNoPhasonSymop[id]));
      this._ssgFract.set([ssgFractNoPhason, phasonMatrix], ssgFract);
    }
    return ssgFract.copy(lalg)
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgParCartn} is the super space group of `this`
   * quasicrystal projected onto the parallel space under the current phason
   * strain represented in the Cartesian coordinate system.
   *
   * Order of the operations conforms to the {@link Quasicrystal#ssgSymopId}.
   *
   * @type {SpaceGroup}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgParCartn () {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    const phasonMatrix = this._phasonMatrix;
    let ssgParCartn = this._ssgParCartn.get([ssgFractNoPhason, phasonMatrix]);
    if (!ssgParCartn) {
      const ssgFractNoPhasonSymop = ssgFractNoPhason.symop;
      const aParCartn = this.aParCartn;
      const bParCartn = this.bParCartn;
      ssgParCartn = new SpaceGroup(this.ssgSymopId.map(id => {
        const gi = ssgFractNoPhasonSymop[id];
        const rot = lalg.mmul(aParCartn, lalg.mmul(gi.rot, bParCartn));
        const trans = lalg.mmul(aParCartn, gi.trans);
        return new SpaceGroupSymop(rot, trans)
      }));
      this._ssgParCartn.set([ssgFractNoPhason, phasonMatrix], ssgParCartn);
    }
    return ssgParCartn.copy(lalg)
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgPerpCartn} is the super space group of `this`
   * quasicrystal projected onto the perpendicular space under the current
   * phason strain represented in the Cartesian coordinate system.
   *
   * Order of the operations conforms to the {@link Quasicrystal#ssgSymopId}.
   *
   * @type {SpaceGroup}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  get ssgPerpCartn () {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    const phasonMatrix = this._phasonMatrix;
    let ssgPerpCartn = this._ssgPerpCartn.get([ssgFractNoPhason, phasonMatrix]);
    if (!ssgPerpCartn) {
      const ssgFractNoPhasonSymop = ssgFractNoPhason.symop;
      const aPerpCartn = this.aPerpCartn;
      const bPerpCartn = this.bPerpCartn;
      ssgPerpCartn = new SpaceGroup(this.ssgSymopId.map(id => {
        const gi = ssgFractNoPhasonSymop[id];
        const rot = lalg.mmul(aPerpCartn, lalg.mmul(gi.rot, bPerpCartn));
        const trans = lalg.mmul(aPerpCartn, gi.trans);
        return new SpaceGroupSymop(rot, trans)
      }));
      this._ssgPerpCartn.set([ssgFractNoPhason, phasonMatrix], ssgPerpCartn);
    }
    return ssgPerpCartn.copy(lalg)
  }

  /**
   * @desc
   * The {@link Quasicrystal#setSSGFractNoPhason} sets `ssgFractNoPhason` to the
   * `this._ssgFractNoPhason`. If `ssgFract` is not a space group of the
   * dimension to which `this` quasicrystal conforms, `this._ssgFractNoPhason`
   * is not set at `ssgFractNoPhason`.
   *
   * CAUTION: `ssgFractNoPhason` must be a super space group under no phason
   * strain, but currently this condition is not checked.
   *
   * @param {SpaceGroup} ssgFractNoPhason
   * A super space group to be set.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  setSSGFractNoPhason (ssgFractNoPhason) {
    const dim = this.dim;
    if (
      ssgFractNoPhason instanceof SpaceGroup &&
      ssgFractNoPhason.dim === dim
    ) {
      this._ssgFractNoPhason = ssgFractNoPhason;
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#setPhasonMatrix} sets `phasonMatrix` to the
   * `this._phasonMatrix`.
   *
   * If `phasonMatrix` cannot be interpreted as a matrix of the dimension
   * `this.dimPerp * this.dimPar`, `this._phasonMatrix` is not set at
   * `this.phasonMatrix`.
   *
   * @param {RealNumber[]} phasonMatrix
   * An array of real numbers representing a phason matrix.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  setPhasonMatrix (phasonMatrix) {
    const dimPar = this.dimPar;
    const dimPerp = this.dimPerp;
    const lalg = this._lalg;
    if (
      Array.isArray(phasonMatrix) && phasonMatrix.length === dimPar * dimPerp
    ) {
      this._phasonMatrix = lalg.$(...phasonMatrix).setDim(dimPerp, dimPar);
    }
  }

  setAtomType (atomTypeSymbol, atomType) {
    if (atomType instanceof AtomType) {
      this._atomType[atomTypeSymbol] = atomType;
    }
  }

  removeAtomType (atomTypeSymbol) {
    delete this._atomType[atomTypeSymbol];
  }

  getAtomTypeEntries () {
    return Object.entries(this._atomType)
  }

  /**
   * @desc
   * The {@link Quasicrystal#setAtomSite} sets a new instance of the
   * {@link AtomSite} which represents an atom site at `posFract` in the
   * fractional coordinate system to `this` quasicrystal with the given label
   * `label`.
   *
   * @param {string} atomSiteLabel
   * Used as a key.
   *
   * @param {RealNumber[]} posFract
   * The position of the atom site to be generated in the fractional coordinate
   * system of `this` quasicrystal.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  setAtomSite (atomSiteLabel, posFract) {
    const dim = this.dim;
    if (Array.isArray(posFract) && posFract.length === dim) {
      this._atomSite[atomSiteLabel] = new AtomSite(posFract);
    }
  }

  removeAtomSite (atomSiteLabel) {
    delete this._atomSite[atomSiteLabel];
  }

  getAtomSiteEntries () {
    return Object.entries(this._atomSite)
  }

  getAtomSite (atomSiteLabel) {
    return this._atomSite[atomSiteLabel]
  }

  // currently, only the first equivalent position is supported
  getAtomSiteLabel (posFract) {
    const lalg = this._lalg;
    for (const [label, atomSite] of this.getAtomSiteEntries()) {
      if (lalg.isInteger(lalg.sub(atomSite.posFract, posFract))) {
        return label
      }
    }
  }

  setAtomicSurface (atomicSurfaceLabel, atomicSurface) {
    const dim = this.dim;
    const dimPerp = this.dimPerp;
    if (
      atomicSurface instanceof AtomicSurface &&
      atomicSurface.dim === dim &&
      atomicSurface.dimPerp === dimPerp
    ) {
      this._atomicSurface[atomicSurfaceLabel] = atomicSurface;
    }
  }

  removeAtomicSurface (atomicSurfaceLabel) {
    delete this._atomicSurface[atomicSurfaceLabel];
  }

  getAtomicSurfaceEntries () {
    return Object.entries(this._atomicSurface)
  }

  getAtomicSurfaceEntriesAtAtomSite (atomSiteLabel) {
    return this.getAtomicSurfaceEntries().filter(
      ([, surf]) => atomSiteLabel === surf.occDomainAsym.atomSiteLabel)
  }

  /**
   * @desc
   * The {@link Quasicrystal#genSGSymop} returns a new instance of
   * {@link SpaceGroupSymop} constructed from a rotation matrix `rot` and a
   * translation vector `trans`.
   *
   * @param {RealNumber[]} rot
   * An array containing `dim * dim` elements of rotation matrix in row-major
   * order.
   *
   * @param {RealNumber[]} trans
   * An array containing `dim` elements of translation vector.
   *
   * @return {SpaceGroupSymop|Error}
   * An instance of {@link SpaceGroupSymop} on successful exit, or an
   * {@link InvalidValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  genSGSymop (rot, trans) {
    const lalg = this._lalg;
    const dim = this.dim;
    if (!Array.isArray(rot) || rot.length !== dim * dim) {
      return new InvalidValue(` (in Quasicrystal.genSGSymop)
        \`rot\` must be an array of length \`dim * dim\`.`)
    }
    if (!Array.isArray(trans) || trans.length !== dim) {
      return new InvalidValue(` (in Quasicrystal.genSGSymop)
        \`trans\` must be an array of length \`dim\`.`)
    }
    rot = lalg.copy(rot).setDim(dim, dim);
    trans = lalg.copy(trans).setDim(dim);
    return new SpaceGroupSymop(rot, trans)
  }

  /**
   * @desc
   * The {@link Quasicrystal#isSSGSymopFractNoPhason} checks if a given
   * space-group symmetry operation represented in the fractional coordinate
   * system of `this` quasicrystal is a super-space-group symmetry operation
   * under no phason strain or not.
   *
   * @param {SpaceGroupSymop} symopFract
   * A space-group symmetry operation to be checked.
   *
   * @return {boolean}
   * `true` is the `symopFract` is a super-space-group symmetry operation under
   * no phason strain, and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  isSSGSymopFractNoPhason (symopFract) {
    const lalg = this._lalg;
    const aParCartn = this.aParCartn;
    const aPerpCartnNoPhason = this.aPerpCartnNoPhason;
    const bParCartnNoPhason = this.bParCartnNoPhason;
    const bPerpCartn = this.bPerpCartn;
    const rot = symopFract.rot;
    const perpPar = lalg.mmul(aPerpCartnNoPhason,
      lalg.mmul(rot, bParCartnNoPhason));
    if (lalg.isZero(perpPar)) {
      const parPerp = lalg.mmul(aParCartn, lalg.mmul(rot, bPerpCartn));
      return lalg.isZero(parPerp)
    } else {
      return false
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#isSSGSymopFract} checks if a given space-group
   * symmetry operation represented in the fractional coordinate system of
   * `this` quasicrystal is a super-space-group symmetry operation under the
   * current phason strain or not.
   *
   * @param {SpaceGroupSymop} symopFract
   * A space-group symmetry operation to be checked.
   *
   * @return {boolean}
   * `true` is the `symopFract` is a super-space-group symmetry operation under
   * the current phason strain, and `false` otherwise.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  isSSGSymopFract (symopFract) {
    const lalg = this._lalg;
    const aParCartn = this.aParCartn;
    const aPerpCartn = this.aPerpCartn;
    const bParCartn = this.bParCartn;
    const bPerpCartn = this.bPerpCartn;
    const rot = symopFract.rot;
    const perpPar = lalg.mmul(aPerpCartn, lalg.mmul(rot, bParCartn));
    if (lalg.isZero(perpPar)) {
      const parPerp = lalg.mmul(aParCartn, lalg.mmul(rot, bPerpCartn));
      return lalg.isZero(parPerp)
    } else {
      return false
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#genSpaceGroup} generates a new instance of
   * {@link SpaceGroup} from the copies of the space-group symmetry operations
   * given as `symops`. `symops` must contain all the operations including the
   * identity operation (excluding lattice periodic translations). The identity
   * operation must be the first element.
   *
   * If no operation is given, the identity operation is used.
   *
   * If `symops` contains any invalid value, returns an instance of
   * {@link InvalidValue}.
   *
   * @param {...SpaceGroupSymop} symops
   * Space group operations to be used.
   *
   * @return {SpaceGroup|Error}
   * Generated space group on successful exit, or an {@link InvalidValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  genSpaceGroup (...symop) {
    const lalg = this._lalg;
    const dim = this.dim;
    if (symop.length === 0) {
      // use identity
      return new SpaceGroup([SpaceGroupSymop.identity(lalg, dim)])
    } else {
      const sg = new SpaceGroup(symop.map(symopi => symopi.copy(lalg)));
      if (sg.dim !== dim) {
        return new InvalidValue(` (in Quasicrystal#genSpaceGroup)
          The dimension of \`sg\` (${sg.dim}) is not consistent with
          the dimension of \`this\` quasicrystal (${dim}).`)
      }
      return sg
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#genSGFractFromGenerators} generates a new instance
   * of {@link SpaceGroup} represented in the fractional coordinate system from
   * the given `generators` represented in the fractional coordinate system. The
   * `generators` may not include lattice periodic translations. The identity
   * operation need not be given explicitly since it is automatically generated.
   *
   * If `generators` contains any invalid value, returns an instance of
   * {@link InvalidValue}.
   *
   * @param {SpaceGroupSymop[]} generators
   * An array containing generators represented in the fractional coordinate
   * system.
   *
   * @param {number} [max = 192]
   * Stops if the number of space-group symmetry operations (excluding lattice
   * periodic translations) exceeds `max`. In this case, an instance of
   * {@link InvalidValue} is returned.
   *
   * @return {SpaceGroup|Error}
   * Generated space group on successful exit, or an {@link InvalidValue}.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  genSGFractFromGenerators (generators, max = 192) {
    const ralg = this._ralg;
    const lalg = this._lalg;
    const dim = this.dim;
    if (!(generators instanceof Array)) {
      return new InvalidValue(` (in Quasicrystal#genSGFractFromGenerators)
        \`generators\` must be an array.`)
    }
    if (generators.some(
      symop => !(symop instanceof SpaceGroupSymop) || symop.dim !== dim
    )) {
      return new InvalidValue(` (in Quasicrystal#genSGFractFromGenerators)
        All the elements of \`generators\` must be an instanceof
        \`SpaceGroupSymops\` of the dimension which conforms to \`this\`
        quasicrystal.`)
    }
    const symop = Group.genElements(
      SpaceGroupSymop.identity(lalg, dim),
      generators,
      (gen, symopi) => {
        const rot = lalg.mmul(symopi.rot, gen.rot);
        const trans = lalg.iadd(lalg.mmul(symopi.rot, gen.trans), symopi.trans);
        for (let k = trans.length - 1; k >= 0; k -= 1) {
          if (ralg.isInteger(trans[k])) {
            trans[k] = ralg.$(0);
          }
        }
        return new SpaceGroupSymop(rot, trans)
      },
      (generated, symopi) =>
        lalg.eq(symopi.rot, generated.rot) &&
        lalg.isInteger(lalg.sub(symopi.trans, generated.trans)),
      max);
    if (symop instanceof InvalidValue) {
      return symop
    } else {
      return new SpaceGroup(symop)
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgNoPhasonSymAtomSite} returns the information
   * about the atomic sites equivalent to the `atomSite` generated by the
   * super-space-group symmetry operations of `this` quasictystal under no
   * phason strain.
   *
   * @param {string} atomSiteLabel
   *
   * @return {object}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  ssgNoPhasonSymAtomSite (atomSiteLabel) {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    const atomSite = this._atomSite[atomSiteLabel];
    let ssgNoPhasonSymAtomSite =
      this._ssgNoPhasonSymAtomSite.get([ssgFractNoPhason, atomSiteLabel]);
    if (!ssgNoPhasonSymAtomSite) {
      const pos = atomSite.posFract;
      const symPos = ssgFractNoPhason.genStar(pos,
        (x, gi) => lalg.iadd(lalg.mmul(gi.rot, pos), gi.trans),
        (x, y) => lalg.isInteger(lalg.sub(x, y)));
      ssgNoPhasonSymAtomSite = {
        eqvPos: symPos.star,
        eqvPosSymopIds: symPos.starSymopIds,
        symopEqvPosId: symPos.symopStarId };
      this._ssgNoPhasonSymAtomSite.set([ssgFractNoPhason, atomSite],
        ssgNoPhasonSymAtomSite);
    }
    return {
      eqvPos: ssgNoPhasonSymAtomSite.eqvPos.map(pos => lalg.copy(pos)),
      eqvPosSymopIds: ssgNoPhasonSymAtomSite.eqvPosSymopIds.map(
        symopIds => symopIds.slice()),
      symopEqvPosId: ssgNoPhasonSymAtomSite.symopEqvPosId.slice()
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#ssgSymAtomSite} returns the information about the
   * atomic sites equivalent to the `atomSite` generated by the
   * super-space-group symmetry operations of `this` quasictystal under the
   * current phason strain and also the atomic sites nonequivqlent to the
   * `atomSite` which are equivalent if there is no phason strain.
   *
   * @param {string} atomSiteLabel
   *
   * @return {object}
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  ssgSymAtomSite (atomSiteLabel) {
    const lalg = this._lalg;
    const ssgFractNoPhason = this._ssgFractNoPhason;
    const phasonMatrix = this._phasonMatrix;
    const atomSite = this._atomSite[atomSiteLabel];
    let ssgSymAtomSite =
      this._ssgSymAtomSite.get([ssgFractNoPhason, phasonMatrix, atomSite]);
    if (!ssgSymAtomSite) {
      const ssgNoPhasonSymAtomSite = this.ssgNoPhasonSymAtomSite(atomSite);
      const ssgNoPhasonEqvPos = ssgNoPhasonSymAtomSite.eqvPos;
      const ssgNoPhasonEqvPosSymopIds = ssgNoPhasonSymAtomSite.eqvPosSymopIds;
      const ssgNoPhasonSymopEqvPosId = ssgNoPhasonSymAtomSite.symopEqvPosId;
      const ssgRightCosetsSymopId = this.ssgRightCosetsSymopId;
      const noneqvSite = [];
      const symopNoneqvPosId = [];
      const symopEqvPosId = [];
      const done = new Array(ssgFractNoPhason.order).fill(false);
      for (const rcSymopId of ssgRightCosetsSymopId) {
        const eqvPos = [];
        const eqvPosSSGNoPhasonSymopIds = [];
        const eqvPosSSGSymopIds = [];
        const symopSSGId = new Array(ssgFractNoPhason.order).fill(-1);
        for (const [i, idi] of rcSymopId.entries()) {
          if (!done[idi]) {
            const eqvPosId = ssgNoPhasonSymopEqvPosId[idi];
            for (const idj of ssgNoPhasonEqvPosSymopIds[eqvPosId]) {
              done[idj] = true;
              symopSSGId[idj] = eqvPosSSGSymopIds.length;
              symopEqvPosId[idj] = eqvPos.length;
              symopNoneqvPosId[idj] = noneqvSite.length;
            }
            eqvPos.push(ssgNoPhasonEqvPos[eqvPosId]);
            eqvPosSSGNoPhasonSymopIds.push(ssgNoPhasonEqvPosSymopIds[eqvPosId]);
            eqvPosSSGSymopIds.push([i]);
          } else if (symopSSGId[idi] !== -1) {
            eqvPosSSGSymopIds[symopSSGId[idi]].push(i);
          }
        }
        if (eqvPos.length > 0) {
          noneqvSite.push({
            eqvPos: eqvPos,
            eqvPosSSGNoPhasonSymopIds: eqvPosSSGNoPhasonSymopIds,
            eqvPosSSGSymopIds: eqvPosSSGSymopIds
          });
        }
      }
      ssgSymAtomSite = {
        noneqvSite: noneqvSite,
        symopNoneqvPosId: symopNoneqvPosId,
        symopEqvPosId: symopEqvPosId };
      this._ssgSymAtomSite.set(
        [ssgFractNoPhason, phasonMatrix, atomSite], ssgSymAtomSite);
    }
    return {
      noneqvSite: ssgSymAtomSite.noneqvSite.map(obj => ({
        eqvPos: obj.eqvPos.map(pos => lalg.copy(pos)),
        eqvPosSSGNoPhasonSymopIds:
          obj.eqvPosSSGNoPhasonSymopIds.map(symopIds => symopIds.slice()),
        eqvPosSSGSymopIds:
          obj.eqvPosSSGSymopIds.map(symopIds => symopIds.slice())
      })),
      symopNoneqvPosId: ssgSymAtomSite.symopNoneqvPosId.slice(),
      symopEqvPosId: ssgSymAtomSite.symopEqvPosId.slice()
    }
  }

  /**
   * @desc
   * The {@link Quasicrystal#spgFractNoPhasonAtomSite} returns the super
   * point group under no phason strain of the first equivalent position of the
   * given atom site `atomSite` represented in the fractional coordinate system
   * of `this` quasicrystal.
   *
   * @param {string} atomSiteLabel
   * An atom site for which the super point group is generated.
   *
   * @return {PointGroup}
   * The generated super point group.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  spgFractNoPhasonAtomSite (atomSiteLabel) {
    const ssgFractNoPhason = this.ssgFractNoPhason;
    const ssgFractNoPhasonSymop = ssgFractNoPhason.symop;
    const ssgNoPhasonSymAtomSite = this.ssgNoPhasonSymAtomSite(atomSiteLabel);
    const eqvPos0SymopIds = ssgNoPhasonSymAtomSite.eqvPosSymopIds[0];
    return new PointGroup(
      eqvPos0SymopIds.map(id => ssgFractNoPhasonSymop[id].rot))
  }

  /**
   * @desc
   * The {@link Quasicrystal#spgPerpCartnNoPhasonAtomSite} returns the
   * super point group projected onto the perpendicular space of `this`
   * quasicrystal under no phason strain of the first equivalent position of the
   * given atom site `atomSite` represented in the Cartesian coordinate system
   *
   * @param {string} atomSiteLabel
   * An atom site for which the super point group is generated.
   *
   * @return {PointGroup}
   * The generated super point group.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  spgPerpCartnNoPhasonAtomSite (atomSiteLabel) {
    const lalg = this._lalg;
    const ssgPerpCartnNoPhason = this.ssgPerpCartnNoPhason;
    const ssgPerpCartnNoPhasonSymop = ssgPerpCartnNoPhason.symop;
    const ssgNoPhasonSymAtomSite = this.ssgNoPhasonSymAtomSite(atomSiteLabel);
    const eqvPos0SymopIds = ssgNoPhasonSymAtomSite.eqvPosSymopIds[0];
    const symop = Group.removeDuplicates(
      eqvPos0SymopIds.map(id => ssgPerpCartnNoPhasonSymop[id].rot),
      (gi, gj) => lalg.eq(gi, gj));
    return new PointGroup(symop)
  }

  /**
   * @desc
   * The {@link Quasicrystal#spgPerpCartnAtomSite} returns the super point
   * groups projected onto the perpendicular space of `this` quasicrystal under
   * the current phason strain for the nonequivalent sites of the given atom
   * site `atomSite`.
   *
   * @param {string} atomSiteLabel
   * An atom site for which the super point groups are generated.
   *
   * @return {PointGroup[]}
   * An array containing the super point groups for the nonequivalent sites.
   * The order of the elements conforms to the `noneqvSite` property of the
   * returned value of the {@link Quasicrystal#ssgPhasonSymAtomSite} method.
   * Each element is the super point group for the first position in the set of
   * the equivalent positions of the corresponding nonequivalent site.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  // WIP
  // spgPerpCartnAtomSite (atomSiteLabel) {
  //   const ssgPerpCartn = this.ssgPerpCartn
  //   const ssgPerpCartnSymop = ssgPerpCartn.symop
  //   const ssgSymAtomSite = this.ssgSymAtomSite(atomSite)
  //   const noneqvSite = ssgSymAtomSite.noneqvSite
  //   return noneqvSite.map(({ eqvPosSSGSymopIds: [eqvPos0SymopIds] }) =>
  //     new PointGroup(eqvPos0SymopIds.map(id => ssgPerpCartnSymop[id].rot)))
  // }

  /**
   * @desc
   * The {@link Quasicrystal#genADTensorBetaNoPhasonFromUCartn} calculates the
   * atomic displacement tensor beta in `this` quasicrystal under no phason
   * strain from the given atomic displacement parameter *U* represented in the
   * Cartesian coordinate system.
   *
   * @param {number[]} uCartn
   * An array containing the elements of an atomic displacement parameter *U*
   * represented in the Cartesian coordinate system. The elements are considered
   * to be stored in row-major order.
   *
   * @return {Matrix}
   * A matrix representing the atomic diplacement tensor beta corresponding to
   * the `uCartn`.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  genADTensorBetaNoPhasonFromUCartn (uCartn) {
    // only numerical
    const lnum = this._lnum;
    const dim = this.dim;
    const bCartnNoPhason = lnum.copy(this.bCartnNoPhason);
    const twopi2 = 2 * (Math.PI ** 2);
    uCartn = lnum.$(...uCartn).setDim(dim, dim);
    return lnum.ismul(lnum.mmul(bCartnNoPhason, lnum.mmul(uCartn,
      lnum.transpose(bCartnNoPhason))), twopi2)
  }

  /**
   * @desc
   * The {@link Quasicrystal#structureFactor} returns the structure factor
   * for a reciprocal-space vector and a `rad`. The parameter `symQFract`
   * is an object containing the star generated from a reciprocal-space vector
   * represented in the fractional coordinate system of `this` quasicrystal.
   *
   * CAUTION: In this method, the possibility of `this` quasicrystal being an
   * approximant crystal due to a phason strain is not take into account.
   *
   * @param {Object} symQFrac
   * An object containing the star generated from the reciprocal-space vector
   * for which the structure factor is to be calculated.
   *
   * @param {Radiation} rad
   * A radiation for which the structure factor is to be calcualted.
   *
   * @version 1.0.0
   * @since 1.0.0
   */
  structureFactor (
    stolQNoneqv,
    rad,
    symQFractNoPhason,
    qPerpCartnStarNoPhason
  ) {
    // numerical only
    const rnum = this._rnum;
    const cnum = this._cnum;
    const lnum = this._lnum;
    const pnum = this._pnum;
    const twopi = 2 * Math.PI;
    const hyperVolume = this.hyperVolumeNumerical;
    const qFractStar = symQFractNoPhason.star;
    const qPerpCartnStar = qPerpCartnStarNoPhason;
    const symopQStarId = symQFractNoPhason.symopStarId;
    const qStarSymopIds = symQFractNoPhason.starSymopIds;
    const qFract0 = qFractStar[0];
    const ssgFract = this.ssgFractNoPhasonNumerical;
    const ssgTransSymopId = this.ssgNoPhasonTransSymopId;
    const atomTypeEntries = this.getAtomTypeEntries();
    const atomSiteEntries = this.getAtomSiteEntries();
    const atomicSurfaceEntries = this.getAtomicSurfaceEntries();
    // atomic scattering factor
    const stolQNoneqvASF = stolQNoneqv.map(stol =>
      new Map(atomTypeEntries.map(([symbol, atomType]) =>
        [symbol, atomType.atomicScatteringFactor(stol, rad)])));
    // translation factor
    const transFactor = new Array(ssgFract.order).fill(0);
    for (const symopId of ssgTransSymopId) {
      const trans = ssgFract.symop[symopId[0]].trans;
      const iPhase = twopi * lnum.dot(qFract0, trans);
      const factor = cnum.$(Math.cos(iPhase), Math.sin(iPhase));
      for (const id of symopId) {
        transFactor[id] = factor;
      }
    }
    // positional phase factor
    const atomSiteInfo = new Map(atomSiteEntries.map(([label, atomSite]) => {
      const spgFract = this.spgFractNoPhasonAtomSite(label);
      const spgPerpCartn = this.spgPerpCartnNoPhasonAtomSite(label);
      const spgPerpCartnMultiplicity =
        rnum.div(spgFract.order, spgPerpCartn.order);
      const symAtomSite = this.ssgNoPhasonSymAtomSite(label);
      const eqvPos0 = symAtomSite.eqvPos[0];
      const effEqvPosEffQFractStar = [];
      const effEqvPosEffQPerpCartnStar = [];
      const effEqvPosEffQStarMult = [];
      const effEqvPosPhaseFactor = [];
      const phaseFactorCache = new Map();
      const symopEffEqvPosId = new Array(ssgFract.order).fill(-1);
      symAtomSite.eqvPosSymopIds.forEach((eqvPosiSymopIds, i) => {
        let effEqvPosId = symopEffEqvPosId[eqvPosiSymopIds[0]];
        if (effEqvPosId === -1) {
          effEqvPosId = effEqvPosEffQFractStar.length;
          const effQStarIds = Array.from(new Set(
            eqvPosiSymopIds.map(id => symopQStarId[id])));
          for (const qStarId of effQStarIds) {
            for (const id of qStarSymopIds[qStarId]) {
              symopEffEqvPosId[id] = effEqvPosId;
            }
          }
          effEqvPosPhaseFactor.push(cnum.$(0));
          effEqvPosEffQFractStar.push(
            effQStarIds.map(id => qFractStar[id]));
          effEqvPosEffQPerpCartnStar.push(
            effQStarIds.map(id => qPerpCartnStar[id]));
          effEqvPosEffQStarMult.push(
            rnum.$(eqvPosiSymopIds.length, effQStarIds.length));
        }
        const effQStarId =
          Math.min(...eqvPosiSymopIds.map(id => symopQStarId[id]));
        let factor = phaseFactorCache.get(effQStarId);
        if (factor === undefined) {
          const effQFract = qFractStar[effQStarId];
          const iPhase = twopi * lnum.dot(effQFract, eqvPos0);
          factor = cnum.$(Math.cos(iPhase), Math.sin(iPhase));
          phaseFactorCache.set(effQStarId, factor);
        }
        effEqvPosPhaseFactor[effEqvPosId] = cnum.iadd(
          effEqvPosPhaseFactor[effEqvPosId],
          cnum.mul(factor, transFactor[eqvPosiSymopIds[0]]));
      });
      for (let i = effEqvPosPhaseFactor.length - 1; i >= 0; i -= 1) {
        effEqvPosPhaseFactor[i] = cnum.imul(
          effEqvPosPhaseFactor[i], effEqvPosEffQStarMult[i]);
      }
      return [label, {
        effEqvPosEffQFractStar: effEqvPosEffQFractStar,
        effEqvPosEffQPerpCartnStar: effEqvPosEffQPerpCartnStar,
        effEqvPosPhaseFactor: effEqvPosPhaseFactor,
        spgPerpCartnMultiplicity: spgPerpCartnMultiplicity
      }]
    }));
    // structure factor
    const fQNoneqv = new Array(stolQNoneqv.length).fill(cnum.$(0));
    for (const [, atomicSurface] of atomicSurfaceEntries) {
      const atomSiteLabel = atomicSurface.atomSiteLabel;
      const atomTypeSymbol = atomicSurface.atomTypeSymbol;
      const {
        effEqvPosEffQFractStar,
        effEqvPosEffQPerpCartnStar,
        effEqvPosPhaseFactor,
        spgPerpCartnMultiplicity } = atomSiteInfo.get(atomSiteLabel);
      let fAS = cnum.$(0);
      for (let i = effEqvPosEffQFractStar.length - 1; i >= 0; i -= 1) {
        const effQFractStar = effEqvPosEffQFractStar[i];
        const effQPerpCartnStar = effEqvPosEffQPerpCartnStar[i];
        const phaseFactor = effEqvPosPhaseFactor[i];
        let fi = cnum.$(0);
        for (let j = effQFractStar.length - 1; j >= 0; j -= 1) {
          const qFract = effQFractStar[j];
          const qPerpCartn = effQPerpCartnStar[j];
          // geometrical form factor
          const gff = cnum.div(
            atomicSurface.geometricalFormFactor(pnum, qPerpCartn),
            spgPerpCartnMultiplicity);
          // atomic displacement factor
          const adp = atomicSurface.atomicDisplacementFactor(lnum, qFract);
          fi = cnum.iadd(fi, cnum.mul(gff, adp));
        }
        // positional phase factor
        fi = cnum.imul(fi, phaseFactor);
        fAS = cnum.iadd(fAS, fi);
      }
      // occupancy factor
      fAS = cnum.imul(fAS, atomicSurface.occupancyFactor());
      // atomic scattering factor for each stol
      stolQNoneqvASF.forEach((atomTypeASFi, i) => {
        const asfi = atomTypeASFi.get(atomTypeSymbol);
        fQNoneqv[i] = cnum.iadd(fQNoneqv[i], cnum.mul(fAS, asfi));
      });
    }
    // normalisation
    for (let i = fQNoneqv.length - 1; i >= 0; i -= 1) {
      fQNoneqv[i] = cnum.idiv(fQNoneqv[i], hyperVolume);
    }
    return fQNoneqv
  }

  * qFractNoPhasonGenerator (maxQParCartn, maxQPerpCartn) {
    const dim = this.dim;
    const dimPar = this.dimPar;
    const dimPerp = this.dimPerp;
    if (typeof maxQParCartn !== 'number' || maxQParCartn <= 0) {
      throw Error('`maxQParCartn` must be a positive (non-zero) number.')
    }
    if (dimPerp > 0) {
      if (typeof maxQPerpCartn !== 'number' || maxQPerpCartn <= 0) {
        throw Error('`maxQPerpCartn` must be a positive (non-zero) number.')
      }
    }
    // numerical only
    const lnum = this._lnum;
    const bParCartn = lnum.copy(this.bParCartn);
    const bPerpCartn = lnum.copy(this.bPerpCartn);
    const bCartn = lnum.copy(this.bCartn);
    const maxQParCartn2 = maxQParCartn ** 2;
    const maxQPerpCartn2 = maxQPerpCartn ** 2;
    const g = (() => {
      let scale = [];
      for (let i = 0; i < dimPar; i += 1) {
        for (let j = 0; j < dim; j += 1) {
          if (i === j) {
            scale.push(1 / maxQParCartn);
          } else {
            scale.push(0);
          }
        }
      }
      for (let i = dimPar; i < dim; i += 1) {
        for (let j = 0; j < dim; j += 1) {
          if (i === j) {
            scale.push(1 / maxQPerpCartn);
          } else {
            scale.push(0);
          }
        }
      }
      scale = lnum.$(...scale).setDim(dim);
      if (dimPerp > 0) {
        scale = lnum.ismul(scale, 1 / Math.sqrt(2));
      }
      let b = lnum.mmul(bCartn, scale);
      return lnum.mmul(b, lnum.transpose(bCartn))
    })();
    const h1 = [];
    const h2 = [];
    for (let i = 0; i < dim - 1; i += 1) {
      const i1 = i + 1;
      const g1 = lnum.$(...g.filter((a, j) => {
        return Math.floor(j / dim) > i && j % dim > i
      })).setDim(dim - i1);
      let g2 = lnum.$(...g.filter((a, j) => {
        return Math.floor(j / dim) > i && j % dim <= i
      })).setDim(dim - i1);
      g2 = lnum.ismul(lnum.isolve(lnum.ilup(g1), g2), -1);
      h1.push(lnum.$(...g2.filter((a, j) => {
        return j % i1 < i
      })).setDim(dim - i1));
      h2.push(lnum.$(...g2.filter((a, j) => {
        return j % i1 === i
      })));
    }
    const g11 = [];
    const g12 = [];
    const g22 = [];
    for (let i = 0; i < dim; i += 1) {
      g11.push(lnum.$(...g.filter((a, j) => {
        return Math.floor(j / dim) < i && j % dim < i
      })).setDim(i));
      g12.push(lnum.$(...g.filter((a, j) => {
        return Math.floor(j / dim) < i && j % dim >= i
      })).setDim(i));
      g22.push(lnum.$(...g.filter((a, j) => {
        return Math.floor(j / dim) >= i && j % dim >= i
      })).setDim(dim - i));
    }
    const realRootsOfQuadEq = (a, b, c) => {
      let d = b ** 2 - 4 * a * c;
      if (d <= 0) {
        const dummy = -b / (2 * a);
        return [dummy, dummy]
      }
      const rtd = Math.sqrt(d);
      const x = [];
      if (b > 0) {
        x.push(-(b + rtd) / (2 * a));
      } else {
        x.push((-b + rtd) / (2 * a));
      }
      x.push(c / a / x[0]);
      if (x[0] > x[1]) {
        const swap = x[0];
        x[0] = x[1];
        x[1] = swap;
      }
      return x
    };
    const findRangeForDepth = (depth, current) => {
      current = current.slice(0, depth);
      let a;
      let b;
      let c;
      if (depth === 0) {
        const v1 = lnum.$(1, ...h2[depth]);
        a = lnum.dot(v1, lnum.mmul(g22[depth], v1));
        b = 0;
        c = -1;
      } else if (depth === dim - 1) {
        a = g22[depth][0];
        b = lnum.mmul(current, g12[depth])[0] * 2;
        c = lnum.dot(current, lnum.mmul(g11[depth], current)) - 1;
      } else {
        const v0 = lnum.$(0, ...lnum.mmul(h1[depth], current));
        const v1 = lnum.$(1, ...h2[depth].slice(0, dim - depth));
        a = lnum.dot(v1, lnum.mmul(g22[depth], v1));
        b = lnum.dot(v0, lnum.mmul(g22[depth], v1)) * 2;
        b += lnum.dot(current, lnum.mmul(g12[depth], v1)) * 2;
        c = lnum.dot(v0, lnum.mmul(g22[depth], v0));
        c += lnum.dot(current, lnum.mmul(g12[depth], v0)) * 2;
        c += lnum.dot(current, lnum.mmul(g11[depth], current)) - 1;
      }
      return realRootsOfQuadEq(a, b, c)
    };
    const stop = [];
    const nextIncrement = [];
    const current = [];
    for (let i = 0; i < dim; i += 1) {
      stop.push(0);
      nextIncrement.push(0);
      current.push(0);
    }
    let depth = 0;
    {
      const range = findRangeForDepth(depth, current);
      const min = Math.floor(range[0]) + 1;
      const max = Math.ceil(range[1]) - 1;
      const diff = max - min;
      current[depth] = min + Math.floor(diff / 2);
      if (diff % 2 === 0) {
        nextIncrement[depth] = -1;
      } else {
        nextIncrement[depth] = 1;
      }
      stop[depth] = min - 1;
    }
    while (true) {
      if (current[depth] !== stop[depth]) {
        if (depth < dim - 1) {
          depth += 1;
          const range = findRangeForDepth(depth, current);
          const min = Math.floor(range[0]) + 1;
          const max = Math.ceil(range[1]) - 1;
          const diff = max - min;
          current[depth] = min + Math.floor(diff / 2);
          if (diff % 2 === 0) {
            nextIncrement[depth] = -1;
          } else {
            nextIncrement[depth] = 1;
          }
          stop[depth] = -(diff + 1);
          continue
        }
        const qParCartn = lnum.mmul(current, bParCartn);
        if (lnum.abs2(qParCartn) < maxQParCartn2) {
          const qPerpCartn = lnum.mmul(current, bPerpCartn);
          if (lnum.abs2(qPerpCartn) < maxQPerpCartn2) {
            yield current;
          }
        }
      } else {
        if (depth === 0) {
          break
        } else {
          depth -= 1;
        }
      }
      current[depth] += nextIncrement[depth];
      if (nextIncrement[depth] > 0) {
        nextIncrement[depth] = -(nextIncrement[depth] + 1);
      } else {
        nextIncrement[depth] = -(nextIncrement[depth] - 1);
      }
    }
  }

  * symQFractNoPhasonGenerator (maxQParCartn, maxQPerpCartn) {
    // numerical only
    const lnum = this._lnum;
    const ssg = this.ssgFractNoPhason.copy(lnum);
    const qFractCache = {};
    for (const qFract of
      this.qFractNoPhasonGenerator(maxQParCartn, maxQPerpCartn)
    ) {
      const g2 = lnum.abs2(qFract);
      if (!qFractCache[g2]) {
        qFractCache[g2] = [];
      }
      const qFractCacheG2 = qFractCache[g2];
      if (qFractCacheG2.every((qFractCached, i) => {
        if (lnum.eq(qFractCached, qFract)) {
          qFractCacheG2.splice(i, 1);
          if (qFractCacheG2.length === 0) {
            delete qFractCache[g2];
          }
          return false
        } else {
          return true
        }
      })) {
        const ssgSymQFract = ssg.genStar(qFract,
          (a, g) => lnum.mmul(a, g.rot),
          (a, b) => lnum.eq(a, b));
        for (const qFracti of ssgSymQFract.star) {
          const g2i = lnum.abs2(qFracti);
          if (!qFractCache[g2i]) {
            qFractCache[g2i] = [];
          }
          qFractCache[g2i].push(qFracti);
        }
        // ??? not confirmed ???
        yield ssgSymQFract;
      }
    }
  }

  genPseudoWSCellPerpAsymNoPhason (
    atomSiteLabel,
    pseudoLattVecsFract,
    hintVAsymPerpCartn,
    dAsym
  ) {
    const palg = this._palg;
    const lalg = this._lalg;
    const ralg = this._ralg;
    const spgPerpCartn = this.spgPerpCartnNoPhasonAtomSite(atomSiteLabel);
    const aPerp = this.aPerpCartnNoPhason;
    const symVOrbit = [];
    for (const v0 of pseudoLattVecsFract) {
      symVOrbit.push(...spgPerpCartn.genOrbit(lalg.mmul(aPerp, v0),
        (a, g) => lalg.mmul(g, a),
        (a, b) => lalg.eq(a, b)
      ).orbit);
    }
    let pAsym = spgPerpCartn.genAsymmetricUnit(palg, dAsym, hintVAsymPerpCartn);
    for (const v of symVOrbit) {
      const f = palg.facet(v, ralg.div(lalg.abs2(v), 2), true);
      pAsym = palg.iaddFacet(pAsym, f);
    }
    return new OccupationDomain(atomSiteLabel, pAsym)
  }

  // possible variants
  // * odStarAsymNoPhasonGenerator
  // * odAsymStarAsymNoPhasonGenerator

  * odStarNoPhasonGenerator (occDomain, displacementVecFract) {
    const palg = this._palg;
    const lalg = this._lalg;
    const atomSiteLabel0 = occDomain.atomSiteLabel;
    const atomSite0 = this.getAtomSite(atomSiteLabel0);
    const posFract0 = atomSite0.posFract;
    const spgFract = this.spgFractNoPhasonAtomSite(atomSiteLabel0);
    const spgPerpCartn = this.spgPerpCartnNoPhasonAtomSite(atomSiteLabel0);
    const aPerp = this.aPerpCartnNoPhason;
    const symV = spgFract.genOrbit(displacementVecFract,
      (a, g) => lalg.mmul(g, a),
      (a, b) => lalg.eq(a, b));
    const atomSiteDisplaced = symV.orbit.map(v => {
      const posFract = lalg.add(v, posFract0);
      const atomSiteLabel = this.getAtomSiteLabel(posFract);
      const vPerpCartn = lalg.ineg(lalg.mmul(aPerp, v));
      return {
        atomSiteLabel: atomSiteLabel,
        vPerpCartn: vPerpCartn }
    });
    for (const rot of spgPerpCartn.symop) {
      const pRot = palg.rotate(occDomain.polytope, rot);
      for (const { atomSiteLabel, vPerpCartn } of atomSiteDisplaced) {
        const pRotTrans = palg.translate(pRot, vPerpCartn);
        yield new OccupationDomain(atomSiteLabel, pRotTrans);
      }
    }
  }

  * odAsymStarNoPhasonGenerator (occDomain, displacementVecFract) {
    const palg = this._palg;
    const lalg = this._lalg;
    const atomSiteLabel0 = occDomain.atomSiteLabel;
    const atomSite0 = this.getAtomSite(atomSiteLabel0);
    const posFract0 = atomSite0.posFract;
    const spgFract = this.spgFractNoPhasonAtomSite(atomSiteLabel0);
    const aPerp = this.aPerpCartnNoPhason;
    const symV = spgFract.genOrbit(displacementVecFract,
      (a, g) => lalg.mmul(g, a),
      (a, b) => lalg.eq(a, b));
    const atomSiteDisplaced = symV.orbit.map(v => {
      const posFract = lalg.add(v, posFract0);
      const atomSiteLabel = this.getAtomSiteLabel(posFract);
      const vPerpCartn = lalg.ineg(lalg.mmul(aPerp, v));
      return {
        atomSiteLabel: atomSiteLabel,
        vPerpCartn: vPerpCartn }
    });
    for (const { atomSiteLabel, vPerpCartn } of atomSiteDisplaced) {
      const pTrans = palg.translate(occDomain.polytope, vPerpCartn);
      yield new OccupationDomain(atomSiteLabel, pTrans);
    }
  }
}

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

// Known bug:
//   NaN is serialised into null,
//   and then if it is parsed into a number, it becomes 0.

const legacyQCReviver = Quasicrystal.reviver(rnum$5, rnum$5.eps);

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

// class names
const QC_EDITOR_CLASS_NAME = "qc-editor";

const QCEditorMain = ({ resetQCData, resetPanels }) => {
  const dispatch = useDispatch();
  const onChange = react_9(
    (e) => {
      const files = e.currentTarget.files;
      if (files.length === 1) {
        const file = files[0];
        const reader = new window.FileReader();
        reader.onload = (e) => {
          const qc = /\.json$/.test(file.name)
            ? JSON.parse(e.target.result, legacyQCReviver)
            : /\.cif$/.test(file.name)
            ? null // fromCIFString(e.target.result)
            : null;
          if (!qc) {
            return;
          }
          const data = new Map();
          const dim = qc.dim;
          data.set(
            "cell",
            new Map([
              ["parallel_space_dimension", storedItem(qc.dimPar)],
              ["perpendicular_space_dimension", storedItem(qc.dimPerp)],
              ["basis_parallel_no_strain", storedItem(qc.aParCartn)],
              [
                "basis_perpendicular_no_strain",
                storedItem(qc.aPerpCartnNoPhason),
              ],
              ["origin_fract", storedItem(qc._originFract.setDim(dim))],
              ["linear_phason_strain_matrix", storedItem(qc._phasonMatrix)],
            ])
          );
          const ssgFractNoPhasonSymop = qc.ssgFractNoPhason.symop;
          data.set(
            "superspace_group_symop",
            ssgFractNoPhasonSymop.map(
              (g) =>
                new Map([
                  ["r", storedItem(g.rot)],
                  ["t", storedItem(g.trans.setDim(dim))],
                ])
            )
          );
          const atomSites = qc.getAtomSiteEntries();
          data.set(
            "atom_site",
            atomSites.map(
              ([label, site]) =>
                new Map([
                  ["label", storedItem(toCanonicalCaseFold(label))],
                  ["fract_coord", storedItem(newMatrix([dim], site.posFract))],
                ])
            )
          );
          const ods = qc.getAtomicSurfaceEntries();
          data.set(
            "occupation_domain",
            ods.map(
              ([label, od]) =>
                new Map([
                  ["label", storedItem(toCanonicalCaseFold(label))],
                  [
                    "atom_site_label",
                    storedItem(toCanonicalCaseFold(od.atomSiteLabel)),
                  ],
                  [
                    "polytope_asymmetric_unit",
                    storedItem(od.occDomainAsym.polytope),
                  ],
                  ["display_colour", storedItem(od.displayColour || null)],
                  ["display_opacity", storedItem(od.displayOpacity || null)],
                  ["display_radius", storedItem(od.displayRadius || null)],
                ])
            )
          );
          const aux = qc.aux;
          if (aux) {
            const overlayPanelState = aux.overlayPanelState;
            if (overlayPanelState) {
              dispatch(resetPanels(overlayPanelState));
            }
            const asymBond = aux.asym_bond;
            if (asymBond) {
              data.set(
                "asym_bond",
                asymBond.map(
                  ({
                    atom_site_label_1: atomSiteLabel1,
                    symop_id_1: symopId1,
                    cell_translation_1: cellTranslation1,
                    atom_site_label_2: atomSiteLabel2,
                    symop_id_2: symopId2,
                    cell_translation_2: cellTranslation2,
                  }) =>
                    new Map([
                      [
                        "atom_site_label_1",
                        storedItem(toCanonicalCaseFold(atomSiteLabel1)),
                      ],
                      ["symop_id_1", storedItem(symopId1)],
                      [
                        "cell_translation_1",
                        storedItem(newMatrix([dim], cellTranslation1)),
                      ],
                      [
                        "atom_site_label_2",
                        storedItem(toCanonicalCaseFold(atomSiteLabel2)),
                      ],
                      ["symop_id_2", storedItem(symopId2)],
                      [
                        "cell_translation_2",
                        storedItem(newMatrix([dim], cellTranslation2)),
                      ],
                    ])
                )
              );
            }
            const geomBond = aux.geom_bond;
            if (geomBond) {
              data.set(
                "geom_bond",
                geomBond.map(
                  ({
                    atom_site_label_1: atomSiteLabel1,
                    symop_id_1: symopId1,
                    cell_translation_1: cellTranslation1,
                    atom_site_label_2: atomSiteLabel2,
                    symop_id_2: symopId2,
                    cell_translation_2: cellTranslation2,
                  }) =>
                    new Map([
                      [
                        "atom_site_label_1",
                        storedItem(toCanonicalCaseFold(atomSiteLabel1)),
                      ],
                      ["symop_id_1", storedItem(symopId1)],
                      [
                        "cell_translation_1",
                        storedItem(newMatrix([dim], cellTranslation1)),
                      ],
                      [
                        "atom_site_label_2",
                        storedItem(toCanonicalCaseFold(atomSiteLabel2)),
                      ],
                      ["symop_id_2", storedItem(symopId2)],
                      [
                        "cell_translation_2",
                        storedItem(newMatrix([dim], cellTranslation2)),
                      ],
                    ])
                )
              );
            }
            const clusterVertex = aux.cluster_vertex;
            if (clusterVertex) {
              data.set(
                "cluster_vertex",
                clusterVertex.map(
                  ({
                    atom_site_label: atomSiteLabel,
                    symop_id: symopId,
                    cell_translation: cellTranslation,
                    atom_site_label_1: atomSiteLabel1,
                    symop_id_1: symopId1,
                    cell_translation_1: cellTranslation1,
                  }) =>
                    new Map([
                      [
                        "atom_site_label",
                        storedItem(toCanonicalCaseFold(atomSiteLabel)),
                      ],
                      ["symop_id", storedItem(symopId)],
                      [
                        "cell_translation",
                        storedItem(newMatrix([dim], cellTranslation)),
                      ],
                      [
                        "atom_site_label_1",
                        storedItem(toCanonicalCaseFold(atomSiteLabel1)),
                      ],
                      ["symop_id_1", storedItem(symopId1)],
                      [
                        "cell_translation_1",
                        storedItem(newMatrix([dim], cellTranslation1)),
                      ],
                    ])
                )
              );
            }
            const clusterEdge = aux.cluster_edge;
            if (clusterEdge) {
              data.set(
                "cluster_edge",
                clusterEdge.map(
                  ({
                    atom_site_label: atomSiteLabel,
                    symop_id: symopId,
                    cell_translation: cellTranslation,
                    atom_site_label_1: atomSiteLabel1,
                    symop_id_1: symopId1,
                    cell_translation_1: cellTranslation1,
                    atom_site_label_2: atomSiteLabel2,
                    symop_id_2: symopId2,
                    cell_translation_2: cellTranslation2,
                  }) =>
                    new Map([
                      [
                        "atom_site_label",
                        storedItem(toCanonicalCaseFold(atomSiteLabel)),
                      ],
                      ["symop_id", storedItem(symopId)],
                      [
                        "cell_translation",
                        storedItem(newMatrix([dim], cellTranslation)),
                      ],
                      [
                        "atom_site_label_1",
                        storedItem(toCanonicalCaseFold(atomSiteLabel1)),
                      ],
                      ["symop_id_1", storedItem(symopId1)],
                      [
                        "cell_translation_1",
                        storedItem(newMatrix([dim], cellTranslation1)),
                      ],
                      [
                        "atom_site_label_2",
                        storedItem(toCanonicalCaseFold(atomSiteLabel2)),
                      ],
                      ["symop_id_2", storedItem(symopId2)],
                      [
                        "cell_translation_2",
                        storedItem(newMatrix([dim], cellTranslation2)),
                      ],
                    ])
                )
              );
            }
            const clusterFace = aux.cluster_face;
            if (clusterFace) {
              data.set(
                "cluster_face",
                clusterFace.map(
                  ({
                    atom_site_label: atomSiteLabel,
                    symop_id: symopId,
                    cell_translation: cellTranslation,
                    atom_site_label_1: atomSiteLabel1,
                    symop_id_1: symopId1,
                    cell_translation_1: cellTranslation1,
                    atom_site_label_2: atomSiteLabel2,
                    symop_id_2: symopId2,
                    cell_translation_2: cellTranslation2,
                    atom_site_label_3: atomSiteLabel3,
                    symop_id_3: symopId3,
                    cell_translation_3: cellTranslation3,
                  }) =>
                    new Map([
                      [
                        "atom_site_label",
                        storedItem(toCanonicalCaseFold(atomSiteLabel)),
                      ],
                      ["symop_id", storedItem(symopId)],
                      [
                        "cell_translation",
                        storedItem(newMatrix([dim], cellTranslation)),
                      ],
                      [
                        "atom_site_label_1",
                        storedItem(toCanonicalCaseFold(atomSiteLabel1)),
                      ],
                      ["symop_id_1", storedItem(symopId1)],
                      [
                        "cell_translation_1",
                        storedItem(newMatrix([dim], cellTranslation1)),
                      ],
                      [
                        "atom_site_label_2",
                        storedItem(toCanonicalCaseFold(atomSiteLabel2)),
                      ],
                      ["symop_id_2", storedItem(symopId2)],
                      [
                        "cell_translation_2",
                        storedItem(newMatrix([dim], cellTranslation2)),
                      ],
                      [
                        "atom_site_label_3",
                        storedItem(toCanonicalCaseFold(atomSiteLabel3)),
                      ],
                      ["symop_id_3", storedItem(symopId3)],
                      [
                        "cell_translation_3",
                        storedItem(newMatrix([dim], cellTranslation3)),
                      ],
                    ])
                )
              );
            }
          }
          dispatch(resetQCData(data));
        };
        reader.readAsText(file);
      }
    },
    [dispatch, resetQCData]
  );

  const onClickDownloadButton = () => {
    const link = document.createElement("a");
    link.href = "./sample-data.zip";
    link.setAttribute("download", "sample-data");
    link.click();
  };

  return react_13(
    () =>
      react.createElement(
        "div",
        null,
        react.createElement("input", {
          type: "file",
          accept: ".json", // ".json,.cif",
          onChange,
        }),
        react.createElement(
          "button",
          { onClick: onClickDownloadButton },
          "Download sample data"
        )
      ),
    [onChange]
  );
};

const QCEditorCreator = (
  quasicrystalSelector = (state) => state,
  qcEditorActionPrefix = "",
  overlayPanelActionPrefix = ""
) => {
  const dictSelector = (state) => quasicrystalSelector(state).dictionary;
  const dataSelector = (state) => quasicrystalSelector(state).data;
  const resetQCData = resetQCDataCreator(qcEditorActionPrefix);
  const resetPanels = resetPanelsCreator(overlayPanelActionPrefix);
  const QCEditor = () => {
    const dict = useSelector(dictSelector);
    const data = useSelector(dataSelector);
    const dictCats = dict.get(["Categories"]);
    const tabHeadings = react_13(
      () =>
        Array.from(dictCats, (catId) =>
          react.createElement(Tab, { key: catId }, catId.toUpperCase())
        ),
      [dictCats]
    );
    const mainPanel = react_13(
      () =>
        react.createElement(
          TabPanel,
          null,
          react.createElement(QCEditorMain, { resetQCData, resetPanels })
        ),
      []
    );
    const tabPanels = react_13(
      () =>
        Array.from(dictCats, (catId) =>
          react.createElement(
            TabPanel,
            { key: catId },
            react.createElement(CategoryEditor, {
              quasicrystalSelector,
              actionPrefix: qcEditorActionPrefix,
              categoryId: catId,
              dict,
              data,
            })
          )
        ),
      [dictCats, dict, data]
    );
    // visibility filter ...
    //
    // ... visibility filter
    return react_13(
      () =>
        react.createElement(
          Tabs,
          { className: QC_EDITOR_CLASS_NAME },
          react.createElement(
            TabList,
            null,
            react.createElement(Tab, null, "\u{2003}"),
            react.createElement(Tab, null, "QC_EDITOR"),
            tabHeadings
          ),
          react.createElement(TabPanel),
          mainPanel,
          tabPanels
        ),
      [tabHeadings, tabPanels]
    );
  };
  return QCEditor;
};

/* @license-end */

/**
 * @source: https://www.npmjs.com/package/@kkitahara/qc-tools
 * @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
 */

// actions
const OVERLAY_PANEL_ACTION_PREFIX = 'overlay-panel-';
const QC_EDITOR_ACTION_PREFIX = 'qc-editor-';

// class names
const QCWEB2_CLASS_NAME = 'qcweb2';

// reducer
const initialState$2 = {
  quasicrystal: quasicrystal(),
  overlayPanel: splittablePanelRoot()
};

const qcweb2 = (state = initialState$2, action = { type: '' }) => {
  const type = action.type;
  if (type.indexOf(OVERLAY_PANEL_ACTION_PREFIX) === 0) {
    const prev = state.overlayPanel;
    const next = splittablePanelRoot(
      prev,
      {
        ...action,
        type: type.slice(OVERLAY_PANEL_ACTION_PREFIX.length)
      }
    );
    return prev === next ? state : { ...state, overlayPanel: next }
  } else if (type.indexOf(QC_EDITOR_ACTION_PREFIX) === 0) {
    const prev = state.quasicrystal;
    const next = quasicrystal(
      prev,
      {
        ...action,
        type: type.slice(QC_EDITOR_ACTION_PREFIX.length)
      }
    );
    return prev === next ? state : { ...state, quasicrystal: next }
  } else {
    return state
  }
};

// components
const QCWeb2Viewer = QCWeb2ViewerCreator(
  state => state.overlayPanel,
  OVERLAY_PANEL_ACTION_PREFIX,
  state => state.quasicrystal
);

const QCEditor = QCEditorCreator(
  state => state.quasicrystal,
  QC_EDITOR_ACTION_PREFIX,
  OVERLAY_PANEL_ACTION_PREFIX
);

const QCWeb2 = () => {
  const Viewer = react_13(
    () => react.createElement(QCWeb2Viewer),
    []
  );
  const Editor = react_13(
    () => react.createElement(QCEditor),
    []
  );
  return react_13(
    () => react.createElement(
      'div',
      { className: QCWEB2_CLASS_NAME },
      Editor,
      Viewer
    ),
    [Viewer, Editor]
  )
};

// root renderer
const renderQCWeb2Below = (rootElement) => {
  const store = createStore(qcweb2);
  reactDom.render(
    react.createElement(
      Provider,
      { store },
      react.createElement(QCWeb2)
    ),
    rootElement
  );
};

/* @license-end */

export { renderQCWeb2Below };
